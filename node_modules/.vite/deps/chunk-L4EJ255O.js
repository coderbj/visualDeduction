import {
  DataHelper,
  Line,
  LineData,
  PathArrow,
  PathCommandMap,
  PointHelper,
  UI,
  attr,
  dataProcessor,
  decorateLeafAttr,
  doStrokeType,
  registerUI,
  strokeType
} from "./chunk-ART566W7.js";

// node_modules/.pnpm/@leafer-in+arrow@1.0.10_@leafer-in+interface@1.0.10_@leafer-ui+draw@1.0.10_@leafer-ui+interface@1.0.10/node_modules/@leafer-in/arrow/dist/arrow.esm.js
function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var ArrowData = class extends LineData {
};
var Arrow = class Arrow2 extends Line {
  get __tag() {
    return "Arrow";
  }
  constructor(data) {
    super(data);
    this.__.__useArrow = true;
  }
};
__decorate([
  dataProcessor(ArrowData)
], Arrow.prototype, "__", void 0);
__decorate([
  strokeType("angle")
], Arrow.prototype, "endArrow", void 0);
Arrow = __decorate([
  registerUI()
], Arrow);
var { M: M$1, L: L$1, C: C$1, Q: Q$1, O: O$1 } = PathCommandMap;
var { rotate: rotate$1, copyFrom: copyFrom$1, scale } = PointHelper;
var point = {};
var PathMatrixHelper = {
  layout(data, x, y, scaleX, scaleY, rotation, origin) {
    let command, i = 0, j, len = data.length;
    while (i < len) {
      command = data[i];
      switch (command) {
        case M$1:
        case L$1:
          setPoint$1(data, i + 1, x, y, scaleX, scaleY, rotation, origin);
          i += 3;
          break;
        case C$1:
          for (j = 1; j < 6; j += 2)
            setPoint$1(data, i + j, x, y, scaleX, scaleY, rotation, origin);
          i += 7;
          break;
        case Q$1:
          for (j = 1; j < 4; j += 2)
            setPoint$1(data, i + j, x, y, scaleX, scaleY, rotation, origin);
          i += 5;
          break;
        case O$1:
          data[i + 1] += x;
          data[i + 2] += y;
          if (scaleX)
            data[i + 3] *= scaleX;
          if (rotation) {
            data[i + 4] += rotation;
            data[i + 5] += rotation;
          }
          i += 7;
          break;
      }
    }
  },
  rotate(data, rotation, center) {
    PathMatrixHelper.layout(data, 0, 0, 1, 1, rotation, center);
  }
};
function setPoint$1(data, startIndex, x, y, scaleX, scaleY, rotation, origin) {
  copyFrom$1(point, data[startIndex], data[startIndex + 1]);
  if (rotation)
    rotate$1(point, rotation, origin);
  if (scaleX)
    scale(point, scaleX, scaleY);
  data[startIndex] = x + point.x;
  data[startIndex + 1] = y + point.y;
}
var { layout, rotate } = PathMatrixHelper;
var { getAngle } = PointHelper;
var half = { x: -0.5 };
var angle = { connect: half, offset: { x: -0.71, bevelJoin: 0.36, roundJoin: 0.22 }, path: [1, -3, -3, 2, 0, 0, 2, -3, 3] };
var angleSide = { connect: half, offset: { x: -1.207, bevelJoin: 0.854, roundJoin: 0.707 }, path: [1, -3, -3, 2, 0, 0, 2, -1, 0] };
var triangleLinePath = [1, -3, 0, 2, -3, -2, 2, 0, 0, 2, -3, 2, 2, -3, 0];
var triangle = { connect: half, offset: { x: -0.9, bevelJoin: 0.624, roundJoin: 0.4 }, path: [...triangleLinePath, 1, -2.05, 1.1, 2, -2.05, -1.1] };
var arrowLinePath = [1, -3, 0, 2, -3.5, -1.8, 2, 0, 0, 2, -3.5, 1.8, 2, -3, 0];
var arrow = { connect: half, offset: { x: -1.1, bevelJoin: 0.872, roundJoin: 0.6 }, path: [...arrowLinePath, 1, -2.25, 0.95, 2, -2.25, -0.95] };
var triangleFlip = { offset: half, path: [...triangle.path] };
rotate(triangleFlip.path, 180, { x: -1.5, y: 0 });
var circleLine = { connect: { x: -1.3 }, path: [1, 1.8, -0.1, 2, 1.8, 0, 26, 0, 0, 1.8, 0, 359, 0] };
var circle = { connect: { x: 0.5 }, path: [...circleLine.path, 1, 0, 0, 26, 0, 0, 1, 0, 360, 0] };
var squareLine = { connect: { x: -1.3 }, path: [1, -1.4, 0, 2, -1.4, -1.4, 2, 1.4, -1.4, 2, 1.4, 1.4, 2, -1.4, 1.4, 2, -1.4, 0] };
var square = { path: [...squareLine.path, 2, -1.4, -0.49, 2, 1, -0.49, 1, -1.4, 0.49, 2, 1, 0.49] };
var diamondLine = DataHelper.clone(squareLine);
var diamond = DataHelper.clone(square);
rotate(diamondLine.path, 45);
rotate(diamond.path, 45);
var mark = { offset: half, path: [1, 0, -2, 2, 0, 2] };
var arrows = {
  angle,
  "angle-side": angleSide,
  arrow,
  triangle,
  "triangle-flip": triangleFlip,
  circle,
  "circle-line": circleLine,
  square,
  "square-line": squareLine,
  diamond,
  "diamond-line": diamondLine,
  mark
};
function getArrowPath(ui2, arrow2, from, to, scale2, connectOffset) {
  const { strokeCap, strokeJoin } = ui2.__;
  const { offset, connect, path } = typeof arrow2 === "object" ? arrow2 : arrows[arrow2];
  let connectX = connect ? connect.x : 0;
  let offsetX = offset ? offset.x : 0;
  const data = [...path];
  if (strokeCap !== "none")
    connectX -= 0.5;
  if (offset) {
    if (strokeJoin === "round" && offset.roundJoin)
      offsetX += offset.roundJoin;
    else if (strokeJoin === "bevel" && offset.bevelJoin)
      offsetX += offset.bevelJoin;
  }
  if (offsetX)
    layout(data, offsetX, 0);
  layout(data, to.x, to.y, scale2, scale2, getAngle(from, to));
  connectOffset.x = (connectX + offsetX) * scale2;
  return data;
}
var { M, L, C, Q, Z, N, D, X, G, F, O, P, U } = PathCommandMap;
var { copy, copyFrom, getDistancePoint } = PointHelper;
var connectPoint = {};
var first = {};
var second = {};
var last = {};
var now = {};
var PathArrowModule = {
  list: arrows,
  addArrows(ui2, changeRenderPath) {
    const { startArrow, endArrow, strokeWidth, __pathForRender: data } = ui2.__;
    let command, i = 0, len = data.length, count = 0, useStartArrow = startArrow && startArrow !== "none";
    while (i < len) {
      command = data[i];
      switch (command) {
        case M:
        case L:
          if (count < 2 || i + 6 >= len) {
            copyFrom(now, data[i + 1], data[i + 2]);
            if (!count && useStartArrow)
              copy(first, now);
          }
          i += 3;
          break;
        case C:
          if (count === 1 || i + 7 === len)
            copyPoints(data, last, now, i + 3);
          i += 7;
          break;
        case Q:
          if (count === 1 || i + 5 === len)
            copyPoints(data, last, now, i + 1);
          i += 5;
          break;
        case Z:
          return;
        case N:
          i += 5;
          break;
        case D:
          i += 9;
          break;
        case X:
          i += 6;
          break;
        case G:
          i += 9;
          break;
        case F:
          i += 5;
          break;
        case O:
          i += 7;
          break;
        case P:
          i += 4;
          break;
        case U:
          if (count === 1 || i + 6 === len)
            copyPoints(data, last, now, i + 1);
          i += 6;
          break;
      }
      count++;
      if (count === 1 && command !== M)
        return;
      if (count === 2 && useStartArrow)
        copy(second, command === L ? now : last);
      if (i === len) {
        const p = ui2.__.__pathForRender = changeRenderPath ? [...data] : data;
        if (useStartArrow) {
          p.push(...getArrowPath(ui2, startArrow, second, first, strokeWidth, connectPoint));
          if (connectPoint.x) {
            getDistancePoint(first, second, -connectPoint.x, true);
            p[1] = second.x;
            p[2] = second.y;
          }
        }
        if (endArrow && endArrow !== "none") {
          p.push(...getArrowPath(ui2, endArrow, last, now, strokeWidth, connectPoint));
          if (connectPoint.x) {
            getDistancePoint(now, last, -connectPoint.x, true);
            let index;
            switch (command) {
              case L:
                index = i - 3 + 1;
                break;
              case C:
                index = i - 7 + 5;
                break;
              case Q:
                index = i - 5 + 3;
                break;
              case U:
                index = i - 6 + 3;
                break;
            }
            if (index)
              setPoint(p, last, index);
          }
        }
      } else {
        copy(last, now);
      }
    }
  }
};
function copyPoints(data, from, to, startIndex) {
  copyFrom(from, data[startIndex], data[startIndex + 1]);
  copyFrom(to, data[startIndex + 2], data[startIndex + 3]);
}
function setPoint(data, point2, startIndex) {
  data[startIndex] = point2.x;
  data[startIndex + 1] = point2.y;
}
function arrowType(defaultValue) {
  return decorateLeafAttr(defaultValue, (key) => attr({
    set(value) {
      if (this.__setAttr(key, value)) {
        const data = this.__;
        data.__useArrow = data.startArrow !== "none" || data.endArrow !== "none";
        doStrokeType(this);
      }
    }
  }));
}
var ui = UI.prototype;
arrowType("none")(ui, "startArrow");
arrowType("none")(ui, "endArrow");
Object.assign(PathArrow, PathArrowModule);

export {
  ArrowData,
  Arrow,
  PathMatrixHelper,
  PathArrowModule,
  arrowType
};
//# sourceMappingURL=chunk-L4EJ255O.js.map
