import { ILeaferCanvas as ILeaferCanvas$1, IScreenSizeData as IScreenSizeData$1 } from '@leafer/interface';

interface IPointData {
    x: number;
    y: number;
}
interface IUnitPointData extends IPointData {
    type?: 'percent' | 'px';
}
interface IFromToData {
    from: IPointData;
    to: IPointData;
}
interface IRotationPointData extends IPointData {
    rotation: number;
}
interface IScrollPointData {
    scrollX: number;
    scrollY: number;
}
interface IClientPointData {
    clientX: number;
    clientY: number;
}
interface IPoint extends IPointData {
    set(x?: number | IPointData, y?: number): IPoint;
    get(): IPointData;
    clone(): IPoint;
    move(x: number, y: number): IPoint;
    scale(scaleX: number, scaleY?: number): IPoint;
    scaleOf(origin: IPointData, scaleX: number, scaleY?: number): IPoint;
    rotate(rotation: number, origin?: IPointData): IPoint;
    rotateOf(origin: IPointData, rotation: number): IPoint;
    getRotation(origin: IPointData, to: IPointData, toOrigin?: IPointData): number;
    toInnerOf(matrix: IMatrixData, to?: IPointData): IPoint;
    toOuterOf(matrix: IMatrixData, to?: IPointData): IPoint;
    getCenter(to: IPointData): IPoint;
    getDistance(to: IPointData): number;
    getDistancePoint(to: IPointData, distance: number, changeTo?: boolean): IPoint;
    getAngle(to: IPointData): number;
    getAtan2(to: IPointData): number;
    reset(): IPoint;
}
interface IRadiusPointData extends IPointData {
    radiusX: number;
    radiusY: number;
}
interface ISizeData {
    width: number;
    height: number;
}
interface ISize extends ISizeData {
}
interface IScreenSizeData extends ISizeData {
    pixelRatio?: number;
}
interface IBoundsData extends IPointData, ISizeData {
}
interface IOffsetBoundsData extends IBoundsData {
    offsetX: number;
    offsetY: number;
}
interface IBoundsDataFn {
    (target: any): IBoundsData;
}
interface IBounds extends IBoundsData, ITwoPointBoundsData {
    set(x?: number | IBoundsData, y?: number, width?: number, height?: number): IBounds;
    get(): IBoundsData;
    clone(): IBounds;
    move(x: number, y: number): IBounds;
    scale(scaleX: number, scaleY?: number): IBounds;
    scaleOf(origin: IPointData, scaleX: number, scaleY?: number): IBounds;
    toOuterOf(matrix: IMatrixData, to?: IBoundsData): IBounds;
    toInnerOf(matrix: IMatrixData, to?: IBoundsData): IBounds;
    getFitMatrix(put: IBoundsData, baseScale?: number): IMatrix;
    spread(fourNumber: IFourNumber, side?: ISide): IBounds;
    shrink(fourNumber: IFourNumber, side?: ISide): IBounds;
    ceil(): IBounds;
    unsign(): IBounds;
    float(maxLength?: number): IBounds;
    add(bounds: IBoundsData): IBounds;
    addList(boundsList: IBoundsData[]): IBounds;
    setList(boundsList: IBoundsData[]): IBounds;
    addListWithFn(list: IObject[], boundsDataHandle: IBoundsDataFn): IBounds;
    setListWithFn(list: IObject[], boundsDataHandle: IBoundsDataFn): IBounds;
    setPoint(point: IPointData): IBounds;
    setPoints(points: IPointData[]): IBounds;
    addPoint(point: IPointData): IBounds;
    getPoints(): IPointData[];
    hitPoint(point: IPointData, pointMatrix?: IMatrixData): boolean;
    hitRadiusPoint(point: IRadiusPointData, pointMatrix?: IMatrixWithLayoutData): boolean;
    hit(bounds: IBoundsData, boundsMatrix?: IMatrixData): boolean;
    includes(bounds: IBoundsData, boundsMatrix?: IMatrixData): boolean;
    intersect(bounds: IBoundsData, boundsMatrix?: IMatrixData): IBounds;
    getIntersect(bounds: IBoundsData, boundsMatrix?: IMatrixData): IBounds;
    isSame(bounds: IBoundsData): boolean;
    isEmpty(): boolean;
    reset(): void;
}
interface ITwoPointBoundsData {
    minX: number;
    minY: number;
    maxX: number;
    maxY: number;
}
interface IAutoBoxData {
    top?: number;
    right?: number;
    bottom?: number;
    left?: number;
}
interface IAutoBoundsData extends IAutoBoxData {
    width?: number;
    height?: number;
}
interface IAutoBounds extends IAutoBoundsData {
    set(top?: number, right?: number, bottom?: number, left?: number, width?: number, height?: number): void;
    copy(auto: IAutoBoundsData): void;
    getBoundsFrom(parent: ISizeData): IBounds;
}
interface IMatrixData {
    a: number;
    b: number;
    c: number;
    d: number;
    e: number;
    f: number;
}
interface IScaleData {
    scaleX: number;
    scaleY: number;
}
interface IScaleRotationData extends IScaleData {
    rotation: number;
}
interface ISkewData {
    skewX: number;
    skewY: number;
}
interface ILayoutData extends IScaleRotationData, ISkewData, IPointData {
}
type ILayoutAttr = 'x' | 'y' | 'scaleX' | 'scaleY' | 'rotation' | 'skewX' | 'skewY';
interface ILayoutBoundsData extends ILayoutData, IBoundsData {
}
interface IMatrix extends IMatrixWithScaleData {
    set(a: number | IMatrixData, b: number, c: number, d: number, e: number, f: number): IMatrix;
    setWith(dataWithScale: IMatrixWithScaleData): IMatrix;
    get(): IMatrixData;
    clone(): IMatrix;
    translate(x: number, y: number): IMatrix;
    translateInner(x: number, y: number): IMatrix;
    scale(x: number, y?: number): IMatrix;
    scaleWith(x: number, y?: number): IMatrix;
    scaleOfOuter(origin: IPointData, x: number, y?: number): IMatrix;
    scaleOfInner(origin: IPointData, x: number, y?: number): IMatrix;
    rotate(angle: number): IMatrix;
    rotateOfOuter(origin: IPointData, angle: number): IMatrix;
    rotateOfInner(origin: IPointData, angle: number): IMatrix;
    skew(x: number, y?: number): IMatrix;
    skewOfOuter(origin: IPointData, x: number, y?: number): IMatrix;
    skewOfInner(origin: IPointData, x: number, y?: number): IMatrix;
    multiply(child: IMatrixData): IMatrix;
    multiplyParent(parent: IMatrixData): IMatrix;
    divide(child: IMatrixData): IMatrix;
    divideParent(parent: IMatrixData): IMatrix;
    invert(): IMatrix;
    invertWith(): IMatrix;
    toOuterPoint(inner: IPointData, to?: IPointData, distance?: boolean): void;
    toInnerPoint(outer: IPointData, to?: IPointData, distance?: boolean): void;
    setLayout(data: ILayoutData, origin?: IPointData, around?: IPointData): IMatrix;
    getLayout(origin?: IPointData, around?: IPointData, firstSkewY?: boolean): ILayoutData;
    withScale(scaleX?: number, scaleY?: number): IMatrixWithScaleData;
    reset(): void;
}
interface IMatrixWithBoundsData extends IMatrixData, IBoundsData {
}
interface IMatrixWithScaleData extends IMatrixData, IScaleData {
}
interface IMatrixWithOptionScaleData extends IMatrixData {
    scaleX?: number;
    scaleY?: number;
}
interface IMatrixWithBoundsScaleData extends IMatrixData, IBoundsData, IScaleData {
}
interface IMatrixWithLayoutData extends IMatrixData, ILayoutBoundsData {
}

interface IFunction {
    (...arg: any): any;
}
interface INumberFunction {
    (...arg: any): number;
}
interface IStringFunction {
    (...arg: any): string;
}
interface IObjectFunction {
    (...arg: any): IObject;
}
interface IPointDataFunction {
    (...arg: any): IPointData;
}
interface IAttrDecorator {
    (...arg: any): IAttrDecoratorInner;
}
interface IAttrDecoratorInner {
    (target: any, key: string): any;
}

type INumber = number;
type IBoolean = boolean;
type IString = string;
type IValue = INumber | IBoolean | IString | IObject;
type ITimer = any;
type IPathString = string;
type IFourNumber = number | number[];
interface IObject {
    [name: string]: any;
}
interface IBooleanMap {
    [name: string]: boolean;
}
interface INumberMap {
    [name: string]: number;
}
interface IStringMap {
    [name: string]: string;
}
interface IFunctionMap {
    [name: string]: IFunction;
}
interface IPointDataMap {
    [name: string]: IPointData;
}
interface IDataTypeHandle {
    (target: any): void;
}

interface ILeafMap {
    [name: string]: ILeaf;
}
interface ILeafArrayMap {
    [name: string]: ILeaf[];
}
type ILeafListItemCallback = (item: ILeaf, index?: number) => void;
interface ILeafList {
    list: ILeaf[];
    keys: INumberMap;
    readonly length: number;
    has(leaf: ILeaf): boolean;
    indexAt(index: number): ILeaf;
    indexOf(leaf: ILeaf): number;
    add(leaf: ILeaf): void;
    addAt(leaf: ILeaf, index: number): void;
    addList(list: ILeaf[]): void;
    remove(leaf: ILeaf): void;
    forEach(itemCallback: ILeafListItemCallback): void;
    sort(reverse?: boolean): void;
    clone(): ILeafList;
    update(): void;
    reset(): void;
    destroy(): void;
}
interface ILeafLevelList {
    levelMap: ILeafArrayMap;
    keys: INumberMap;
    levels: number[];
    readonly length: number;
    has(leaf: ILeaf): boolean;
    without(leaf: ILeaf): boolean;
    sort(reverse?: boolean): void;
    addList(list: ILeaf[]): void;
    add(leaf: ILeaf): void;
    forEach(itemCallback: ILeafListItemCallback): void;
    reset(): void;
    destroy(): void;
}

interface IControl {
    start(): void;
    stop(): void;
    destroy(): void;
}

interface IWatchEventData {
    updatedList: ILeafList;
}
interface IWatcherConfig {
}
interface IWatcher extends IControl {
    target: ILeaf;
    totalTimes: number;
    disabled: boolean;
    running: boolean;
    changed: boolean;
    hasVisible: boolean;
    hasAdd: boolean;
    hasRemove: boolean;
    readonly childrenChanged: boolean;
    config: IWatcherConfig;
    updatedList: ILeafList;
    disable(): void;
    update(): void;
}

interface ILayoutChangedData {
    matrixList: ILeaf[];
    boundsList: ILeaf[];
    surfaceList: ILeaf[];
}
interface ILayoutBlockData {
    updatedList: ILeafList;
    updatedBounds: IBounds;
    beforeBounds: IBounds;
    afterBounds: IBounds;
    setBefore?(): void;
    setAfter?(): void;
    merge?(data: ILayoutBlockData): void;
    destroy(): void;
}
interface IPartLayoutConfig {
    maxBlocks?: number;
    maxTimes?: number;
}
interface ILayouterConfig {
    partLayout?: IPartLayoutConfig;
}
interface ILayouter extends IControl {
    target: ILeaf;
    layoutedBlocks: ILayoutBlockData[];
    extraBlock: ILayoutBlockData;
    totalTimes: number;
    times: number;
    disabled: boolean;
    running: boolean;
    layouting: boolean;
    waitAgain: boolean;
    config: ILayouterConfig;
    disable(): void;
    layout(): void;
    layoutAgain(): void;
    layoutOnce(): void;
    partLayout(): void;
    fullLayout(): void;
    addExtra(leaf: ILeaf): void;
    createBlock(data: ILeafList | ILeaf[]): ILayoutBlockData;
    getBlocks(list: ILeafList): ILayoutBlockData[];
    addBlocks(current: ILayoutBlockData[]): void;
}

interface IEvent {
    origin?: IObject;
    type?: string;
    target?: IEventTarget;
    current?: IEventTarget;
    bubbles?: boolean;
    phase?: number;
    isStopDefault?: boolean;
    isStop?: boolean;
    isStopNow?: boolean;
    stopDefault?(): void;
    stopNow?(): void;
    stop?(): void;
}
interface IEventTarget extends IEventer {
}
interface ILeaferEvent {
}
interface IRenderEvent {
}
interface IAnimateEvent {
}
interface IChildEvent extends IEvent {
    parent?: ILeaf;
    child?: ILeaf;
}
interface IResizeEvent extends IEvent {
    readonly width: number;
    readonly height: number;
    readonly pixelRatio: number;
    readonly bigger: boolean;
    readonly smaller: boolean;
    readonly samePixelRatio: boolean;
    readonly old: IScreenSizeData;
}
interface IResizeEventListener {
    (event: IResizeEvent): void;
}
interface IUpdateEvent extends IEvent {
}
interface IPropertyEvent extends IEvent {
    readonly attrName: string;
    readonly oldValue: unknown;
    readonly newValue: unknown;
}
interface ILayoutEvent extends IEvent {
    readonly data: ILayoutBlockData[];
    readonly times: number;
}
interface IWatchEvent extends IEvent {
    readonly data: IWatchEventData;
}
interface IMultiTouchData {
    move: IPointData;
    scale: number;
    angle: number;
    center: IPointData;
}
interface IKeepTouchData {
    from: IPointData;
    to: IPointData;
}

type ILeafEventerModule = ILeafEventer & ThisType<ILeaf>;
interface ILeafEventer {
    on?(type: string | string[] | IEventMap, listener?: IEventListener, options?: IEventListenerOptions | boolean): void;
    off?(type?: string | string[], listener?: IEventListener, options?: IEventListenerOptions | boolean): void;
    on_?(type: string | string[], listener: IEventListener, bind?: IObject, options?: IEventListenerOptions | boolean): IEventListenerId;
    off_?(id: IEventListenerId | IEventListenerId[]): void;
    once?(type: string | string[], listener: IEventListener, capture?: boolean): void;
    emit?(type: string, event?: IEvent | IObject, capture?: boolean): void;
    emitEvent?(event?: IEvent, capture?: boolean): void;
    hasEvent?(type: string, capture?: boolean): boolean;
    destroyEventer?(): void;
}

type IEventListener = IFunction;
interface IEventListenerOptions {
    capture?: boolean;
    once?: boolean;
}
type IEventOption = IEventListenerOptions | boolean | 'once';
interface IEventListenerItem extends IEventListenerOptions {
    listener: IEventListener;
}
interface IEventListenerMap {
    [name: string]: IEventListenerItem[];
}
interface IEventMap {
    [name: string]: IEventListener | [IEventListener, IEventOption];
}
interface IEventListenerId {
    type: string | string[];
    current: ILeaf;
    listener: IEventListener;
    options?: IEventOption;
}
type InnerId = number;
interface IEventer extends ILeafEventer {
    readonly innerId: InnerId;
    __captureMap?: IEventListenerMap;
    __bubbleMap?: IEventListenerMap;
    syncEventer?: IEventer;
    event?: IEventMap;
    on(type: string | string[] | IEventMap, listener?: IEventListener, options?: IEventOption): void;
    off(type?: string | string[], listener?: IEventListener, options?: IEventOption): void;
    on_(type: string | string[], listener: IEventListener, bind?: IObject, options?: IEventOption): IEventListenerId;
    off_(id: IEventListenerId | IEventListenerId[]): void;
    once(type: string | string[], listener: IEventListener): void;
    emit(type: string, event?: IEvent | IObject, capture?: boolean): void;
    emitEvent(event?: IEvent, capture?: boolean): void;
    hasEvent(type: string, capture?: boolean): boolean;
    destroy(): void;
}

type GlobalCompositeOperation = 'color' | 'color-burn' | 'color-dodge' | 'copy' | 'darken' | 'destination-atop' | 'destination-in' | 'destination-out' | 'destination-over' | 'difference' | 'exclusion' | 'hard-light' | 'hue' | 'lighten' | 'lighter' | 'luminosity' | 'multiply' | 'overlay' | 'saturation' | 'screen' | 'soft-light' | 'source-atop' | 'source-in' | 'source-out' | 'source-over' | 'xor';
type CanvasDirection = 'inherit' | 'ltr' | 'rtl';
type IWindingRule = 'evenodd' | 'nonzero';
type CanvasLineCap = 'butt' | 'round' | 'square';
type CanvasLineJoin = 'bevel' | 'miter' | 'round';
type CanvasTextAlign = 'center' | 'end' | 'left' | 'right' | 'start';
type CanvasTextBaseline = 'alphabetic' | 'bottom' | 'hanging' | 'ideographic' | 'middle' | 'top';
interface IPath2D extends CanvasPath {
    addPath(path: IPath2D, transform?: DOMMatrix2DInit): void;
}
interface CanvasCompositing {
    globalAlpha: number;
    globalCompositeOperation: GlobalCompositeOperation;
}
type CanvasImageSource$1 = any;
interface CanvasDrawImage {
    drawImage(image: CanvasImageSource$1, dx: number, dy: number): void;
    drawImage(image: CanvasImageSource$1, dx: number, dy: number, dw: number, dh: number): void;
    drawImage(image: CanvasImageSource$1, sx: number, sy: number, sw: number, sh: number, dx: number, dy: number, dw: number, dh: number): void;
}
interface CanvasDrawPath {
    beginPath(): void;
    clip(fillRule?: IWindingRule): void;
    clip(path: IPath2D, fillRule?: IWindingRule): void;
    fill(fillRule?: IWindingRule): void;
    fill(path: IPath2D, fillRule?: IWindingRule): void;
    isPointInPath(x: number, y: number, fillRule?: IWindingRule): boolean;
    isPointInPath(path: IPath2D, x: number, y: number, fillRule?: IWindingRule): boolean;
    isPointInStroke(x: number, y: number): boolean;
    isPointInStroke(path: IPath2D, x: number, y: number): boolean;
    stroke(): void;
    stroke(path: IPath2D): void;
}
interface CanvasFillStrokeStyles {
    fillStyle: string | CanvasGradient | CanvasPattern;
    strokeStyle: string | CanvasGradient | CanvasPattern;
    createConicGradient(startAngle: number, x: number, y: number): CanvasGradient;
    createLinearGradient(x0: number, y0: number, x1: number, y1: number): CanvasGradient;
    createPattern(image: CanvasImageSource$1, repetition: string | null): CanvasPattern | null;
    createRadialGradient(x0: number, y0: number, r0: number, x1: number, y1: number, r1: number): CanvasGradient;
}
interface CanvasFilters {
    filter: string;
}
interface CanvasGradient {
    addColorStop(offset: number, color: string): void;
}
interface ImageDataSettings {
    colorSpace?: PredefinedColorSpace;
}
interface CanvasImageData {
    createImageData(sw: number, sh: number, settings?: ImageDataSettings): ImageData;
    createImageData(imagedata: ImageData): ImageData;
    getImageData(sx: number, sy: number, sw: number, sh: number, settings?: ImageDataSettings): ImageData;
    putImageData(imagedata: ImageData, dx: number, dy: number): void;
    putImageData(imagedata: ImageData, dx: number, dy: number, dirtyX: number, dirtyY: number, dirtyWidth: number, dirtyHeight: number): void;
}
interface CanvasImageSmoothing {
    imageSmoothingEnabled: boolean;
    imageSmoothingQuality: ImageSmoothingQuality;
}
interface CanvasPath {
    arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, anticlockwise?: boolean): void;
    arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): void;
    bezierCurveTo(cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number): void;
    closePath(): void;
    ellipse(x: number, y: number, radiusX: number, radiusY: number, rotation: number, startAngle: number, endAngle: number, anticlockwise?: boolean): void;
    lineTo(x: number, y: number): void;
    moveTo(x: number, y: number): void;
    quadraticCurveTo(cpx: number, cpy: number, x: number, y: number): void;
    rect(x: number, y: number, w: number, h: number): void;
    roundRect(x: number, y: number, width: number, height: number, radius?: number | number[]): void;
}
interface CanvasPathDrawingStyles {
    lineCap: CanvasLineCap;
    lineDashOffset: number;
    lineJoin: CanvasLineJoin;
    lineWidth: number;
    miterLimit: number;
    getLineDash(): number[];
    setLineDash(segments: number[]): void;
}
interface CanvasPattern {
    setTransform(transform?: DOMMatrix2DInit): void;
}
type ICanvasPattern = CanvasPattern;
interface CanvasRect {
    clearRect(x: number, y: number, w: number, h: number): void;
    fillRect(x: number, y: number, w: number, h: number): void;
    strokeRect(x: number, y: number, w: number, h: number): void;
}
type PredefinedColorSpace = 'display-p3' | 'srgb';
interface ICanvasRenderingContext2DSettings {
    alpha?: boolean;
    colorSpace?: PredefinedColorSpace;
    desynchronized?: boolean;
    willReadFrequently?: boolean;
}
type ICanvasContext2DSettings = ICanvasRenderingContext2DSettings;
interface ICanvasContext2D extends CanvasCompositing, CanvasDrawImage, CanvasDrawPath, CanvasFillStrokeStyles, CanvasFilters, CanvasImageData, CanvasImageSmoothing, CanvasPath, CanvasPathDrawingStyles, CanvasRect, CanvasShadowStyles, CanvasState, CanvasText, CanvasTextDrawingStyles, CanvasTransform, CanvasUserInterface {
    readonly canvas: HTMLCanvasElement;
    getContextAttributes(): ICanvasRenderingContext2DSettings;
}
interface CanvasShadowStyles {
    shadowBlur: number;
    shadowColor: string;
    shadowOffsetX: number;
    shadowOffsetY: number;
}
interface CanvasState {
    restore(): void;
    save(): void;
}
interface CanvasUserInterface {
    drawFocusIfNeeded(element: any): void;
    drawFocusIfNeeded(path: IPath2D, element: any): void;
}
interface ITextMetrics {
    readonly actualBoundingBoxAscent: number;
    readonly actualBoundingBoxDescent: number;
    readonly actualBoundingBoxLeft: number;
    readonly actualBoundingBoxRight: number;
    readonly fontBoundingBoxAscent: number;
    readonly fontBoundingBoxDescent: number;
    readonly width: number;
}
interface CanvasText {
    fillText(text: string, x: number, y: number, maxWidth?: number): void;
    measureText(text: string): ITextMetrics;
    strokeText(text: string, x: number, y: number, maxWidth?: number): void;
}
interface CanvasTextDrawingStyles {
    direction: CanvasDirection;
    font: string;
    textAlign: CanvasTextAlign;
    textBaseline: CanvasTextBaseline;
}
interface CanvasTransform {
    getTransform(): DOMMatrix;
    resetTransform(): void;
    rotate(angle: number): void;
    scale(x: number, y: number): void;
    setTransform(a: number, b: number, c: number, d: number, e: number, f: number): void;
    setTransform(transform?: DOMMatrix2DInit): void;
    transform(a: number, b: number, c: number, d: number, e: number, f: number): void;
    translate(x: number, y: number): void;
}
interface DOMMatrix2DInit {
    a?: number;
    b?: number;
    c?: number;
    d?: number;
    e?: number;
    f?: number;
    m11?: number;
    m12?: number;
    m21?: number;
    m22?: number;
    m41?: number;
    m42?: number;
}
interface DOMMatrixInit extends DOMMatrix2DInit {
    is2D?: boolean;
    m13?: number;
    m14?: number;
    m23?: number;
    m24?: number;
    m31?: number;
    m32?: number;
    m33?: number;
    m34?: number;
    m43?: number;
    m44?: number;
}
interface DOMMatrixReadOnly {
    readonly a: number;
    readonly b: number;
    readonly c: number;
    readonly d: number;
    readonly e: number;
    readonly f: number;
    readonly is2D: boolean;
    readonly isIdentity: boolean;
    readonly m11: number;
    readonly m12: number;
    readonly m13: number;
    readonly m14: number;
    readonly m21: number;
    readonly m22: number;
    readonly m23: number;
    readonly m24: number;
    readonly m31: number;
    readonly m32: number;
    readonly m33: number;
    readonly m34: number;
    readonly m41: number;
    readonly m42: number;
    readonly m43: number;
    readonly m44: number;
    flipX(): DOMMatrix;
    flipY(): DOMMatrix;
    inverse(): DOMMatrix;
    multiply(other?: DOMMatrixInit): DOMMatrix;
    rotate(rotX?: number, rotY?: number, rotZ?: number): DOMMatrix;
    rotateAxisAngle(x?: number, y?: number, z?: number, angle?: number): DOMMatrix;
    rotateFromVector(x?: number, y?: number): DOMMatrix;
    scale(scaleX?: number, scaleY?: number, scaleZ?: number, originX?: number, originY?: number, originZ?: number): DOMMatrix;
    scale3d(scale?: number, originX?: number, originY?: number, originZ?: number): DOMMatrix;
    scaleNonUniform(scaleX?: number, scaleY?: number): DOMMatrix;
    skewX(sx?: number): DOMMatrix;
    skewY(sy?: number): DOMMatrix;
    toFloat32Array(): Float32Array;
    toFloat64Array(): Float64Array;
    toJSON(): any;
    transformPoint(point?: DOMPointInit): DOMPoint;
    translate(tx?: number, ty?: number, tz?: number): DOMMatrix;
    toString(): string;
}
declare var DOMMatrixReadOnly: {
    prototype: DOMMatrixReadOnly;
    new (init?: string | number[]): DOMMatrixReadOnly;
    fromFloat32Array(array32: Float32Array): DOMMatrixReadOnly;
    fromFloat64Array(array64: Float64Array): DOMMatrixReadOnly;
    fromMatrix(other?: DOMMatrixInit): DOMMatrixReadOnly;
    toString(): string;
};
interface DOMMatrix extends DOMMatrixReadOnly {
    a: number;
    b: number;
    c: number;
    d: number;
    e: number;
    f: number;
    m11: number;
    m12: number;
    m13: number;
    m14: number;
    m21: number;
    m22: number;
    m23: number;
    m24: number;
    m31: number;
    m32: number;
    m33: number;
    m34: number;
    m41: number;
    m42: number;
    m43: number;
    m44: number;
    invertSelf(): DOMMatrix;
    multiplySelf(other?: DOMMatrixInit): DOMMatrix;
    preMultiplySelf(other?: DOMMatrixInit): DOMMatrix;
    rotateAxisAngleSelf(x?: number, y?: number, z?: number, angle?: number): DOMMatrix;
    rotateFromVectorSelf(x?: number, y?: number): DOMMatrix;
    rotateSelf(rotX?: number, rotY?: number, rotZ?: number): DOMMatrix;
    scale3dSelf(scale?: number, originX?: number, originY?: number, originZ?: number): DOMMatrix;
    scaleSelf(scaleX?: number, scaleY?: number, scaleZ?: number, originX?: number, originY?: number, originZ?: number): DOMMatrix;
    setMatrixValue(transformList: string): DOMMatrix;
    skewXSelf(sx?: number): DOMMatrix;
    skewYSelf(sy?: number): DOMMatrix;
    translateSelf(tx?: number, ty?: number, tz?: number): DOMMatrix;
}
declare var DOMMatrix: {
    prototype: DOMMatrix;
    new (init?: string | number[]): DOMMatrix;
    fromFloat32Array(array32: Float32Array): DOMMatrix;
    fromFloat64Array(array64: Float64Array): DOMMatrix;
    fromMatrix(other?: DOMMatrixInit): DOMMatrix;
};

type Command = number;
type x = number;
type y = number;
type x1 = number;
type y1 = number;
type x2 = number;
type y2 = number;
type radiusX = number;
type radiusY = number;
type xAxisRotation = number;
type largeArcFlag = number;
type sweepFlag = number;
type MCommandData = [Command, x, y];
type HCommandData = [Command, x];
type VCommandData = [Command, y];
type LCommandData = MCommandData;
type CCommandData = [Command, x1, y1, x2, y2, x, y];
type SCommandData = [Command, x2, y2, x, y];
type QCommandData = [Command, x1, y1, x, y];
type TCommandData = [Command, x, y];
type ZCommandData = [Command];
type ACommandData = [Command, radiusX, radiusY, xAxisRotation, largeArcFlag, sweepFlag, x, y];
type width = number;
type height = number;
type rotation = number;
type startAngle = number;
type endAngle = number;
type anticlockwise = boolean;
type cornerRadius = number | number[];
type radius = number;
type RectCommandData = [Command, x, y, width, height];
type RoundRectCommandData = [Command, x, y, width, height, cornerRadius];
type EllipseCommandData = [Command, x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise];
type ArcCommandData = [Command, x, y, radius, startAngle, endAngle, anticlockwise];
type ArcToCommandData = [Command, x1, y1, x2, y2, radius];
type CanvasPathCommand = 1 | 2 | 5 | 7 | 11;
type IPathCommandData = number[];
interface MoveToCommandObject {
    name: 'M';
    x: number;
    y: number;
}
interface LineToCommandObject {
    name: 'L';
    x: number;
    y: number;
}
interface BezierCurveToCommandObject {
    name: 'C';
    x1: number;
    y1: number;
    x2: number;
    y2: number;
    x: number;
    y: number;
}
interface QuadraticCurveToCommandObject {
    name: 'Q';
    x1: number;
    y1: number;
    x: number;
    y: number;
}
interface ClosePathCommandObject {
    name: 'Z';
}
type IPathCommandObject = MoveToCommandObject | LineToCommandObject | BezierCurveToCommandObject | QuadraticCurveToCommandObject | ClosePathCommandObject;

interface IPathDrawer {
    beginPath?(): void;
    moveTo(x: number, y: number): void;
    lineTo(x: number, y: number): void;
    bezierCurveTo(x1: number, y1: number, x2: number, y2: number, x: number, y: number): void;
    quadraticCurveTo(x1: number, y1: number, x: number, y: number): void;
    closePath(): void;
    arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, anticlockwise?: boolean): void;
    arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): void;
    ellipse(x: number, y: number, radiusX: number, radiusY: number, rotation: number, startAngle: number, endAngle: number, anticlockwise?: boolean): void;
    rect(x: number, y: number, width: number, height: number): void;
    roundRect(x: number, y: number, width: number, height: number, radius?: number | number[]): void;
}
interface IPathCreator extends IPathDrawer {
    path: IPathCommandData;
    __path: IPathCommandData;
    beginPath(): IPathCreator;
    moveTo(x: number, y: number): IPathCreator;
    lineTo(x: number, y: number): IPathCreator;
    bezierCurveTo(x1: number, y1: number, x2: number, y2: number, x: number, y: number): IPathCreator;
    quadraticCurveTo(x1: number, y1: number, x: number, y: number): IPathCreator;
    closePath(): IPathCreator;
    arc(x: number, y: number, radius: number, startAngle?: number, endAngle?: number, anticlockwise?: boolean): IPathCreator;
    arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): IPathCreator;
    ellipse(x: number, y: number, radiusX: number, radiusY: number, rotation?: number, startAngle?: number, endAngle?: number, anticlockwise?: boolean): IPathCreator;
    rect(x: number, y: number, width: number, height: number): IPathCreator;
    roundRect(x: number, y: number, width: number, height: number, radius?: number | number[]): IPathCreator;
    drawEllipse(x: number, y: number, radiusX: number, radiusY: number, rotation?: number, startAngle?: number, endAngle?: number, anticlockwise?: boolean): IPathCreator;
    drawArc(x: number, y: number, radius: number, startAngle?: number, endAngle?: number, anticlockwise?: boolean): IPathCreator;
    drawPoints(points: number[], curve?: boolean | number, close?: boolean): IPathCreator;
    clearPath(): IPathCreator;
}

interface ICanvasManager {
    add(canvas: ILeaferCanvas$1): void;
    get(size: IScreenSizeData$1): ILeaferCanvas$1;
    recycle(old: ILeaferCanvas$1): void;
    clearRecycled(): void;
    clear(): void;
    destroy(): void;
}

type IExportImageType = 'jpg' | 'png' | 'webp';
type IExportFileType = IExportImageType | 'svg' | 'pdf' | 'json';

type ILocationType = 'world' | 'page' | 'local' | 'inner';
type IBoundsType = 'content' | 'box' | 'stroke' | 'render';
interface ILeafLayout {
    leaf: ILeaf;
    proxyZoom: boolean;
    contentBounds: IBoundsData;
    boxBounds: IBoundsData;
    strokeBounds: IBoundsData;
    renderBounds: IBoundsData;
    localContentBounds: IBoundsData;
    localStrokeBounds: IBoundsData;
    localRenderBounds: IBoundsData;
    worldContentBounds: IBoundsData;
    worldBoxBounds: IBoundsData;
    worldStrokeBounds: IBoundsData;
    resized: boolean;
    waitAutoLayout: boolean;
    matrixChanged: boolean;
    scaleChanged: boolean;
    rotationChanged: boolean;
    boundsChanged: boolean;
    boxChanged: boolean;
    strokeChanged: boolean;
    renderChanged: boolean;
    localBoxChanged: boolean;
    surfaceChanged: boolean;
    opacityChanged: boolean;
    hitCanvasChanged: boolean;
    childrenSortChanged?: boolean;
    stateStyleChanged?: boolean;
    affectScaleOrRotation: boolean;
    affectRotation: boolean;
    affectChildrenSort?: boolean;
    strokeSpread: number;
    strokeBoxSpread: number;
    renderSpread: number;
    renderShapeSpread: number;
    a: number;
    b: number;
    c: number;
    d: number;
    e: number;
    f: number;
    x: number;
    y: number;
    width: number;
    height: number;
    createLocal(): void;
    update(): void;
    getTransform(relative?: ILocationType | ILeaf): IMatrixData;
    getBounds(type?: IBoundsType, relative?: ILocationType | ILeaf): IBoundsData;
    getLayoutBounds(type?: IBoundsType, relative?: ILocationType | ILeaf, unscale?: boolean): ILayoutBoundsData;
    getLayoutPoints(type?: IBoundsType, relative?: ILocationType | ILeaf): IPointData[];
    shrinkContent(): void;
    spreadStroke(): void;
    spreadRender(): void;
    shrinkContentCancel(): void;
    spreadStrokeCancel(): void;
    spreadRenderCancel(): void;
    boxChange(): void;
    localBoxChange(): void;
    strokeChange(): void;
    renderChange(): void;
    scaleChange(): void;
    rotationChange(): void;
    matrixChange(): void;
    surfaceChange(): void;
    opacityChange(): void;
    childrenSortChange(): void;
    destroy(): void;
}

interface IExportOptions {
    quality?: number;
    blob?: boolean;
    scale?: number | IPointData;
    size?: number | ISizeData;
    smooth?: boolean;
    pixelRatio?: number;
    slice?: boolean;
    trim?: boolean;
    fill?: string;
    screenshot?: IBoundsData | boolean;
    relative?: ILocationType | ILeaf;
    json?: IJSONOptions;
    contextSettings?: ICanvasContext2DSettings;
    onCanvas?: IExportOnCanvasFunction;
}
interface IJSONOptions {
    matrix?: boolean;
}
interface IExportResult {
    data: ILeaferCanvas | IBlob | string | boolean;
    width?: number;
    height?: number;
    renderBounds?: IBoundsData;
    trimBounds?: IBoundsData;
}
interface IExportResultFunction {
    (data: IExportResult): void;
}
interface IExportOnCanvasFunction {
    (data: ILeaferCanvas): void;
}

interface ILeaferCanvasConfig extends IAutoBoundsData {
    view?: string | IObject;
    canvas?: string | IObject;
    fill?: string;
    pixelRatio?: number;
    smooth?: boolean;
    hittable?: boolean;
    webgl?: boolean;
    contextSettings?: ICanvasContext2DSettings;
}
type IHitCanvasConfig = ILeaferCanvasConfig;
interface ICanvasStrokeOptions {
    strokeWidth?: number;
    strokeAlign?: string;
    strokeCap?: string;
    strokeJoin?: string;
    dashPattern?: number[];
    dashOffset?: number;
    miterLimit?: number;
}
interface ICanvasCacheOptions extends ICanvasStrokeOptions {
    fillStyle?: string | object;
    strokeStyle?: string | object;
}
interface ICanvasAttr extends ICanvasStrokeOptions, IObject {
    smooth: boolean;
    smoothLevel: string;
    opacity: number;
    blendMode: string;
    fillStyle: string | object;
    strokeStyle: string | object;
    strokeWidth: number;
    shadowBlur: number;
    shadowColor: string;
    shadowOffsetX: number;
    shadowOffsetY: number;
    filter: string;
    font: string;
    fontKerning: string;
    fontStretch: string;
    fontVariantCaps: string;
    textAlign: string;
    textBaseline: string;
    textRendering: string;
    wordSpacing: string;
    letterSpacing: string;
    direction: string;
}
interface ICanvasMethod {
    save(): void;
    restore(): void;
    fill(path?: IPath2D | IWindingRule, rule?: IWindingRule): void;
    stroke(path?: IPath2D): void;
    clip(path?: IPath2D | IWindingRule, rule?: IWindingRule): void;
    fillRect(x: number, y: number, width: number, height: number): void;
    strokeRect(x: number, y: number, width: number, height: number): void;
    clearRect(x: number, y: number, width: number, height: number): void;
    transform(a: number | IMatrixData, b?: number, c?: number, d?: number, e?: number, f?: number): void;
    translate(x: number, y: number): void;
    scale(x: number, y: number): void;
    rotate(angle: number): void;
    drawImage(image: CanvasImageSource, dx: number, dy: number): void;
    drawImage(image: CanvasImageSource, dx: number, dy: number, dw: number, dh: number): void;
    drawImage(image: CanvasImageSource, sx: number, sy: number, sw: number, sh: number, dx: number, dy: number, dw: number, dh: number): void;
    setTransform(a: number | IMatrixData, b?: number, c?: number, d?: number, e?: number, f?: number): void;
    getTransform(): IMatrixData;
    resetTransform(): void;
    createConicGradient(startAngle: number, x: number, y: number): CanvasGradient;
    createLinearGradient(x0: number, y0: number, x1: number, y1: number): CanvasGradient;
    createPattern(image: CanvasImageSource, repetition: string | null): CanvasPattern | null;
    createRadialGradient(x0: number, y0: number, r0: number, x1: number, y1: number, r1: number): CanvasGradient;
    fillText(text: string, x: number, y: number, maxWidth?: number): void;
    measureText(text: string): ITextMetrics;
    strokeText(text: string, x: number, y: number, maxWidth?: number): void;
    saveBlendMode(blendMode?: string): void;
    restoreBlendMode(): void;
    hitFill(point: IPointData, fillRule?: string): boolean;
    hitStroke(point: IPointData, strokeWidth?: number): boolean;
    hitPixel(radiusPoint: IRadiusPointData, offset?: IPointData, scale?: number): boolean;
    setStroke(strokeStyle: string | object, strokeWidth: number, options?: ICanvasStrokeOptions): void;
    setStrokeOptions(options: ICanvasStrokeOptions): void;
    setWorld(matrix: IMatrixData, parentMatrix?: IMatrixData): void;
    useWorldTransform(worldTransform?: IMatrixData): void;
    setWorldShadow(x: number, y: number, blur: number, color?: string): void;
    setWorldBlur(blur: number): void;
    copyWorld(canvas: ILeaferCanvas, fromBounds?: IBoundsData, toBounds?: IBoundsData, blendMode?: string): void;
    copyWorldByReset(canvas: ILeaferCanvas, from?: IBoundsData, to?: IBoundsData, blendMode?: string, onlyResetTransform?: boolean): void;
    copyWorldToInner(canvas: ILeaferCanvas, fromWorld: IMatrixWithBoundsData, toInnerBounds: IBoundsData, blendMode?: string): void;
    useMask(maskCanvas: ILeaferCanvas, fromBounds?: IBoundsData, toBounds?: IBoundsData): void;
    useEraser(eraserCanvas: ILeaferCanvas, fromBounds?: IBoundsData, toBounds?: IBoundsData): void;
    fillWorld(bounds: IBoundsData, color: string | object, blendMode?: string): void;
    strokeWorld(bounds: IBoundsData, color: string | object, blendMode?: string): void;
    clipWorld(bounds: IBoundsData, ceilPixel?: boolean): void;
    clearWorld(bounds: IBoundsData, ceilPixel?: boolean): void;
    clear(): void;
}
type ILeaferCanvasView = any;
interface ILeaferCanvas extends ICanvasAttr, ICanvasMethod, IPathDrawer {
    readonly innerId: InnerId;
    name: string;
    manager: ICanvasManager;
    width: number;
    height: number;
    pixelRatio: number;
    readonly pixelWidth: number;
    readonly pixelHeight: number;
    readonly allowBackgroundColor?: boolean;
    backgroundColor?: string;
    hittable?: boolean;
    zIndex?: number;
    childIndex?: number;
    bounds: IBounds;
    clientBounds: IBoundsData;
    config: ILeaferCanvasConfig;
    autoLayout: boolean;
    view: ILeaferCanvasView;
    parentView: any;
    unreal?: boolean;
    context: ICanvasContext2D;
    recycled?: boolean;
    worldTransform: IMatrixData;
    init(): void;
    export(filename: IExportFileType | string, options?: IExportOptions | number | boolean): string | Promise<any>;
    toBlob(type?: string, quality?: number): Promise<IBlob>;
    toDataURL(type?: string, quality?: number): string | Promise<string>;
    saveAs(filename: string, quality?: number): Promise<boolean>;
    startAutoLayout(autoBounds: IAutoBounds, listener: IResizeEventListener): void;
    stopAutoLayout(): void;
    resize(size: IScreenSizeData): void;
    updateViewSize(): void;
    updateClientBounds(): void;
    getClientBounds(update?: boolean): IBoundsData;
    isSameSize(options: ILeaferCanvasConfig): boolean;
    getSameCanvas(useSameWorldTransform?: boolean, useSameSmooth?: boolean): ILeaferCanvas;
    recycle(clearBounds?: IBoundsData): void;
    updateRender(bounds: IBoundsData): void;
    unrealCanvas(): void;
    destroy(): void;
}
interface IHitCanvas extends ILeaferCanvas {
    hitScale?: number;
}
interface IBlobFunction {
    (blob: IBlob | null): void;
}
type IBlob = any;

interface IRenderOptions {
    includes?: boolean;
    bounds?: IBounds;
    hideBounds?: IBounds;
    matrix?: IMatrixWithScaleData;
    inCamera?: boolean;
}
interface IRendererConfig {
    usePartRender?: boolean;
    maxFPS?: number;
    fill?: string;
}
interface IRenderer extends IControl {
    target: ILeaf;
    canvas: ILeaferCanvas;
    updateBlocks: IBounds[];
    FPS: number;
    totalTimes: number;
    times: number;
    running: boolean;
    rendering: boolean;
    waitAgain: boolean;
    changed: boolean;
    ignore: boolean;
    config: IRendererConfig;
    update(): void;
    requestLayout(): void;
    render(callback?: IFunction): void;
    renderAgain(): void;
    renderOnce(callback?: IFunction): void;
    partRender(): void;
    clipRender(bounds: IBounds): void;
    fullRender(): void;
    renderHitView(options: IRenderOptions): void;
    renderBoundsView(options: IRenderOptions): void;
    addBlock(block: IBounds): void;
    mergeBlocks(): void;
}

type ILeafDataProxyModule = ILeafDataProxy & ThisType<ILeaf>;
interface ILeafDataProxy {
    __setAttr?(name: string, newValue: IValue): boolean;
    __getAttr?(name: string): IValue;
    __realSetAttr?(name: string, newValue: IValue): void;
    setProxyAttr?(name: string, newValue: IValue): void;
    getProxyAttr?(name: string): IValue;
}

type ILeafMatrixModule = ILeafMatrix & ThisType<ILeaf>;
interface ILeafMatrix {
    __updateWorldMatrix?(): void;
    __updateLocalMatrix?(): void;
}

type ILeafBoundsModule = ILeafBounds & ThisType<ILeaf>;
interface ILeafBounds {
    __updateWorldBounds?(): void;
    __updateLocalBounds?(): void;
    __updateLocalBoxBounds?(): void;
    __updateLocalStrokeBounds?(): void;
    __updateLocalRenderBounds?(): void;
    __updateBoxBounds?(secondLayout?: boolean): void;
    __updateStrokeBounds?(): void;
    __updateRenderBounds?(): void;
    __updateAutoLayout?(): void;
    __updateFlowLayout?(): void;
    __updateNaturalSize?(): void;
    __updateStrokeSpread?(): number;
    __updateRenderSpread?(): number;
    __onUpdateSize?(): void;
}

type ILeafHitModule = ILeafHit & ThisType<ILeaf>;
interface ILeafHit {
    __hitWorld?(point: IRadiusPointData): boolean;
    __hit?(inner: IRadiusPointData): boolean;
    __hitFill?(inner: IRadiusPointData): boolean;
    __hitStroke?(inner: IRadiusPointData, strokeWidth: number): boolean;
    __hitPixel(inner: IRadiusPointData): boolean;
    __drawHitPath?(canvas: ILeaferCanvas): void;
    __updateHitCanvas?(): void;
}

type ILeafRenderModule = ILeafRender & ThisType<ILeaf>;
interface ILeafRender {
    __render?(canvas: ILeaferCanvas, options: IRenderOptions): void;
    __draw?(canvas: ILeaferCanvas, options: IRenderOptions): void;
    __drawFast?(canvas: ILeaferCanvas, options: IRenderOptions): void;
    __clip?(_canvas: ILeaferCanvas, _options: IRenderOptions): void;
    __renderShape?(canvas: ILeaferCanvas, options: IRenderOptions, ignoreFill?: boolean, ignoreStroke?: boolean): void;
    __updateWorldOpacity?(): void;
    __updateChange?(): void;
}

interface IDataProcessor {
    __leaf: ILeaf;
    __input: IObject;
    __middle: IObject;
    __get(name: string): any;
    __getData(): IObject;
    __setInput(name: string, value: any): void;
    __getInput(name: string): any;
    __removeInput(name: string): void;
    __getInputData(names?: string[] | IObject, options?: IJSONOptions): IObject;
    __setMiddle(name: string, value: any): void;
    __getMiddle(name: string): any;
    destroy(): void;
}
interface ILeafDataOptions {
    attrs?: 'all' | string[];
    children?: boolean;
}
interface ILeafData extends IDataProcessor, ILeafComputedData {
    __single?: boolean;
    __checkSingle(): void;
    __removeNaturalSize(): void;
}

interface IBranch extends ILeaf {
    children: ILeaf[];
    __renderBranch?(canvas: ILeaferCanvas, options: IRenderOptions): void;
    addMany(...children: ILeaf[] | ILeafInputData[]): void;
    removeAll(destroy?: boolean): void;
    clear(): void;
}

interface IPickResult {
    target: ILeaf;
    path: ILeafList;
    throughPath?: ILeafList;
}
interface IPickOptions {
    name?: string;
    hitRadius?: number;
    through?: boolean;
    target?: IBranch;
    findList?: ILeaf[];
    bottomList?: IPickBottom[];
    exclude?: ILeafList;
    ignoreHittable?: boolean;
}
interface IPickBottom {
    target: ILeaf;
    proxy?: ILeaf;
}
interface ISelectorConfig {
}
type IAnswer = 0 | 1 | 2 | 3;
interface IFindCondition {
    id?: number | string;
    className?: string;
    tag?: string | string[];
}
interface IFindMethod {
    (leaf: ILeaf, options?: any): IAnswer;
}
interface ISelectorProxy {
    list: ILeaf[];
    dragHoverExclude: ILeaf[];
}
interface ISelector {
    target?: ILeaf;
    proxy?: ISelectorProxy;
    config: ISelectorConfig;
    getByPoint(hitPoint: IPointData, hitRadius: number, options?: IPickOptions): IPickResult;
    getBy(condition: number | string | IFindMethod, branch?: ILeaf, one?: boolean, options?: any): ILeaf | ILeaf[];
    getByInnerId(innerId: number, branch?: ILeaf): ILeaf;
    getById(id: string, branch?: ILeaf): ILeaf;
    getByClassName(className: string, branch?: ILeaf): ILeaf[];
    getByTag(tag: string, branch?: ILeaf): ILeaf[];
    getByMethod(method: IFindMethod, branch?: ILeaf, one?: boolean, options?: any): ILeaf | ILeaf[];
    destroy(): void;
}

interface IMotionPathData {
    total: number;
    segments: number[];
    data: IPathCommandData;
}

interface ICachedLeaf {
    canvas: ILeaferCanvas;
    matrix?: IMatrix;
    bounds: IBoundsData;
}
type ISide = 'width' | 'height';
type IAxis = 'x' | 'y';
type IAxisReverse = 'x-reverse' | 'y-reverse';
type IFlowType = boolean | IAxis | IAxisReverse;
type IFlowBoxType = 'box' | 'stroke';
type IGap = INumber | 'auto' | 'fit';
interface IPointGap {
    x?: IGap;
    y?: IGap;
}
type IAxisAlign = 'from' | 'center' | 'to';
interface IFlowAxisAlign {
    content?: IFlowAlign;
    x?: IAxisAlign;
    y?: IAxisAlign;
}
type IFlowWrap = boolean | 'reverse';
type IAutoSize = IBoolean | INumber | IPercentData;
interface IRangeSize {
    min?: number;
    max?: number;
}
interface IUnitData {
    type: 'percent' | 'px';
    value: number;
}
interface IPercentData extends IUnitData {
    type: 'percent';
}
interface IConstraint {
    x: IConstraintType;
    y: IConstraintType;
}
type IConstraintType = 'from' | 'center' | 'to' | 'from-to' | 'scale';
type IHitType = 'path' | 'pixel' | 'all' | 'none';
type IMaskType = 'path' | 'pixel' | 'clipping';
type IEraserType = 'path' | 'pixel';
type IBlendMode = 'pass-through' | 'normal' | 'multiply' | 'screen' | 'overlay' | 'darken' | 'lighten' | 'color-dodge' | 'color-burn' | 'hard-light' | 'soft-light' | 'difference' | 'exclusion' | 'hue' | 'saturation' | 'color' | 'luminosity' | 'source-over' | 'source-in' | 'source-out' | 'source-atop' | 'destination-over' | 'destination-in' | 'destination-out' | 'destination-atop' | 'xor';
type IEditSize = 'size' | 'font-size' | 'scale';
interface IImageCursor {
    url: string;
    x?: number;
    y?: number;
    rotation?: number;
}
type IDirection = 'top-left' | 'top' | 'top-right' | 'right' | 'bottom-right' | 'bottom' | 'bottom-left' | 'left' | 'center';
type IDirection4 = 'top' | 'right' | 'bottom' | 'left';
type IAlign = IDirection;
type IBaseLineAlign = 'baseline-left' | 'baseline-center' | 'baseline-right';
type IFlowAlign = IAlign | IBaseLineAlign;
type IAround = IAlign | IUnitPointData;
type ICursorType = IImageCursor | '' | 'auto' | 'default' | 'none' | 'context-menu' | 'help' | 'pointer' | 'progress' | 'wait' | 'cell' | 'crosshair' | 'text' | 'vertical-text' | 'alias' | 'copy' | 'move' | 'no-drop' | 'not-allowed' | 'grab' | 'grabbing' | 'e-resize' | 'n-resize' | 'ne-resize' | 'nw-resize' | 's-resize' | 'se-resize' | 'sw-resize' | 'w-resize' | 'ew-resize' | 'ns-resize' | 'nesw-resize' | 'nwse-resize' | 'col-resize' | 'row-resize' | 'all-scroll' | 'zoom-in' | 'zoom-out';
type IStateStyleType = 'hoverStyle' | 'pressStyle' | 'focusStyle' | 'selectedStyle' | 'disabledStyle';
interface ILeafAttrData {
    id?: IString;
    name?: IString;
    className?: IString;
    blendMode?: IBlendMode;
    opacity?: INumber;
    visible?: IBoolean | 0;
    selected?: IBoolean;
    disabled?: IBoolean;
    locked?: IBoolean;
    zIndex?: INumber;
    mask?: IBoolean | IMaskType;
    eraser?: IBoolean | IEraserType;
    x?: INumber;
    y?: INumber;
    width?: INumber;
    height?: INumber;
    scaleX?: INumber;
    scaleY?: INumber;
    rotation?: INumber;
    skewX?: INumber;
    skewY?: INumber;
    scale?: INumber | IPointData;
    offsetX?: INumber;
    offsetY?: INumber;
    scrollX?: INumber;
    scrollY?: INumber;
    origin?: IAlign | IUnitPointData;
    around?: IAlign | IUnitPointData;
    lazy?: IBoolean;
    pixelRatio?: INumber;
    path?: IPathCommandData | IPathCommandObject[] | IPathString;
    windingRule?: IWindingRule;
    closed?: IBoolean;
    flow?: IFlowType;
    padding?: IFourNumber;
    gap?: IGap | IPointGap;
    flowAlign?: IFlowAlign | IFlowAxisAlign;
    flowWrap?: IFlowWrap;
    itemBox?: IFlowBoxType;
    inFlow?: IBoolean;
    autoWidth?: IAutoSize;
    autoHeight?: IAutoSize;
    lockRatio?: IBoolean;
    autoBox?: IAutoBoxData | IConstraint;
    widthRange?: IRangeSize;
    heightRange?: IRangeSize;
    draggable?: IBoolean | IAxis;
    dragBounds?: IBoundsData | 'parent';
    editable?: IBoolean;
    hittable?: IBoolean;
    hitFill?: IHitType;
    hitStroke?: IHitType;
    hitBox?: IBoolean;
    hitChildren?: IBoolean;
    hitSelf?: IBoolean;
    hitRadius?: INumber;
    button?: IBoolean;
    cursor?: ICursorType | ICursorType[];
    motionPath?: IBoolean;
    motion?: INumber | IUnitData;
    motionRotation?: INumber | IBoolean;
    normalStyle?: IObject;
    event?: IEventMap;
    data?: IObject;
}
interface ILeafInputData extends ILeafAttrData {
    tag?: string;
    children?: ILeafInputData[];
    noBounds?: boolean;
}
interface ILeafComputedData {
    id?: string;
    name?: string;
    className?: string;
    blendMode?: IBlendMode;
    opacity?: number;
    visible?: boolean | 0;
    selected?: boolean;
    disabled?: boolean;
    locked?: boolean;
    zIndex?: number;
    mask?: boolean | IMaskType;
    eraser?: boolean | IEraserType;
    x?: number;
    y?: number;
    width?: number;
    height?: number;
    scaleX?: number;
    scaleY?: number;
    rotation?: number;
    skewX?: number;
    skewY?: number;
    offsetX?: number;
    offsetY?: number;
    scrollX?: number;
    scrollY?: number;
    origin?: IAlign | IUnitPointData;
    around?: IAlign | IUnitPointData;
    lazy?: boolean;
    pixelRatio?: number;
    path?: IPathCommandData;
    windingRule?: IWindingRule;
    closed?: boolean;
    flow?: IFlowType;
    padding?: IFourNumber;
    gap?: IGap | IPointGap;
    flowAlign?: IFlowAlign | IFlowAxisAlign;
    flowWrap?: IFlowWrap;
    itemBox?: IFlowBoxType;
    inFlow?: boolean;
    autoWidth?: IAutoSize;
    autoHeight?: IAutoSize;
    lockRatio?: boolean;
    autoBox?: IAutoBoxData | IConstraint;
    widthRange?: IRangeSize;
    heightRange?: IRangeSize;
    draggable?: boolean | IAxis;
    dragBounds?: IBoundsData | 'parent';
    editable?: boolean;
    hittable?: boolean;
    hitFill?: IHitType;
    hitStroke?: IHitType;
    hitBox?: boolean;
    hitChildren?: boolean;
    hitSelf?: boolean;
    hitRadius?: number;
    button?: boolean;
    cursor?: ICursorType | ICursorType[];
    motionPath?: boolean;
    motion?: number | IUnitData;
    motionRotation?: number | boolean;
    normalStyle?: IObject;
    data?: IObject;
    __childBranchNumber?: number;
    __complex?: boolean;
    __naturalWidth?: number;
    __naturalHeight?: number;
    readonly __autoWidth?: boolean;
    readonly __autoHeight?: boolean;
    readonly __autoSide?: boolean;
    readonly __autoSize?: boolean;
    readonly __useNaturalRatio: boolean;
    readonly __isLinePath: boolean;
    readonly __blendMode: string;
    __useArrow?: boolean;
    __useEffect?: boolean;
    __pathInputed?: number;
    __pathForRender?: IPathCommandData;
    __path2DForRender?: IPath2D;
    __pathForMotion?: IMotionPathData;
}
interface ILeaf extends ILeafRender, ILeafHit, ILeafBounds, ILeafMatrix, ILeafDataProxy, ILeafInputData, IEventer {
    tag: string;
    readonly __tag: string;
    readonly innerName: string;
    readonly __DataProcessor: IObject;
    readonly __LayoutProcessor: IObject;
    readonly app?: ILeaferBase;
    leafer?: ILeaferBase;
    parent?: ILeaf;
    zoomLayer?: ILeaf;
    readonly leaferIsCreated: boolean;
    readonly leaferIsReady: boolean;
    readonly isApp?: boolean;
    readonly isLeafer?: boolean;
    readonly isBranch?: boolean;
    readonly isBranchLeaf?: boolean;
    readonly isOutside?: boolean;
    __: ILeafData;
    proxyData?: ILeafInputData;
    __proxyData?: ILeafInputData;
    syncEventer?: ILeaf;
    lockNormalStyle?: boolean;
    __layout: ILeafLayout;
    __world: IMatrixWithBoundsScaleData;
    __local?: IMatrixWithBoundsData;
    __nowWorld?: IMatrixWithBoundsScaleData;
    __cameraWorld?: IMatrixWithBoundsScaleData;
    readonly __localMatrix: IMatrixData;
    readonly __localBoxBounds: IBoundsData;
    __worldOpacity: number;
    readonly worldTransform: IMatrixWithScaleData;
    readonly localTransform: IMatrixData;
    readonly boxBounds: IBoundsData;
    readonly renderBounds: IBoundsData;
    readonly worldBoxBounds: IBoundsData;
    readonly worldStrokeBounds: IBoundsData;
    readonly worldRenderBounds: IBoundsData;
    readonly worldOpacity: number;
    __level: number;
    __tempNumber?: number;
    readonly __worldFlipped: boolean;
    animation?: IObject;
    animationOut?: IObject;
    __hasAutoLayout?: boolean;
    __hasMotionPath?: boolean;
    __hasMask?: boolean;
    __hasEraser?: boolean;
    __hitCanvas?: IHitCanvas;
    __flowBounds?: IBoundsData;
    __widthGrow?: number;
    __heightGrow?: number;
    __hasGrow?: boolean;
    readonly __onlyHitMask: boolean;
    readonly __ignoreHitWorld: boolean;
    readonly __inLazyBounds: boolean;
    readonly pathInputed: boolean;
    destroyed: boolean;
    reset(data?: ILeafInputData): void;
    resetCustom(): void;
    waitParent(item: IFunction, bind?: IObject): void;
    waitLeafer(item: IFunction, bind?: IObject): void;
    nextRender(item: IFunction, bind?: IObject, off?: 'off'): void;
    removeNextRender(item: IFunction): void;
    __bindLeafer(leafer: ILeaferBase | null): void;
    set(data: IObject, isTemp?: boolean): void;
    get(name?: string | string[] | IObject): ILeafInputData | IValue;
    setAttr(name: string, value: any): void;
    getAttr(name: string): any;
    getComputedAttr(name: string): any;
    toJSON(options?: IJSONOptions): IObject;
    toString(options?: IJSONOptions): string;
    toSVG(): string;
    __SVG(data: IObject): void;
    toHTML(): string;
    __setAttr(attrName: string, newValue: IValue, checkFiniteNumber?: boolean): boolean;
    __getAttr(attrName: string): IValue;
    setProxyAttr(name: string, newValue: IValue): void;
    getProxyAttr(name: string): IValue;
    find(condition: number | string | IFindMethod, options?: any): ILeaf[];
    findTag(tag: string | string[]): ILeaf[];
    findOne(condition: number | string | IFindMethod, options?: any): ILeaf | undefined;
    findId(id: number | string): ILeaf | undefined;
    focus(value?: boolean): void;
    updateState(): void;
    updateLayout(): void;
    forceUpdate(attrName?: string): void;
    forceRender(_bounds?: IBoundsData): void;
    __updateWorldMatrix(): void;
    __updateLocalMatrix(): void;
    __updateWorldBounds(): void;
    __updateLocalBounds(): void;
    __updateLocalBoxBounds(): void;
    __updateLocalStrokeBounds(): void;
    __updateLocalRenderBounds(): void;
    __updateContentBounds(): void;
    __updateBoxBounds(secondLayout?: boolean): void;
    __updateStrokeBounds(): void;
    __updateRenderBounds(): void;
    __updateAutoLayout(): void;
    __updateFlowLayout(): void;
    __updateNaturalSize(): void;
    __updateStrokeSpread(): number;
    __updateRenderSpread(): number;
    __onUpdateSize(): void;
    __updateEraser(value?: boolean): void;
    __updateMask(value?: boolean): void;
    __renderMask(canvas: ILeaferCanvas, options: IRenderOptions): void;
    __renderEraser(canvas: ILeaferCanvas, options: IRenderOptions): void;
    __getNowWorld(options: IRenderOptions): IMatrixWithBoundsScaleData;
    getTransform(relative?: ILocationType | ILeaf): IMatrixData;
    getBounds(type?: IBoundsType, relative?: ILocationType | ILeaf): IBoundsData;
    getLayoutBounds(type?: IBoundsType, relative?: ILocationType | ILeaf, unscale?: boolean): ILayoutBoundsData;
    getLayoutPoints(type?: IBoundsType, relative?: ILocationType | ILeaf): IPointData[];
    getWorldBounds(inner: IBoundsData, relative?: ILeaf, change?: boolean): IBoundsData;
    worldToLocal(world: IPointData, to?: IPointData, distance?: boolean, relative?: ILeaf): void;
    localToWorld(local: IPointData, to?: IPointData, distance?: boolean, relative?: ILeaf): void;
    worldToInner(world: IPointData, to?: IPointData, distance?: boolean, relative?: ILeaf): void;
    innerToWorld(inner: IPointData, to?: IPointData, distance?: boolean, relative?: ILeaf): void;
    getBoxPoint(world: IPointData, relative?: ILeaf, distance?: boolean, change?: boolean): IPointData;
    getBoxPointByInner(inner: IPointData, relative?: ILeaf, distance?: boolean, change?: boolean): IPointData;
    getInnerPoint(world: IPointData, relative?: ILeaf, distance?: boolean, change?: boolean): IPointData;
    getInnerPointByBox(box: IPointData, relative?: ILeaf, distance?: boolean, change?: boolean): IPointData;
    getInnerPointByLocal(local: IPointData, relative?: ILeaf, distance?: boolean, change?: boolean): IPointData;
    getLocalPoint(world: IPointData, relative?: ILeaf, distance?: boolean, change?: boolean): IPointData;
    getLocalPointByInner(inner: IPointData, relative?: ILeaf, distance?: boolean, change?: boolean): IPointData;
    getPagePoint(world: IPointData, relative?: ILeaf, distance?: boolean, change?: boolean): IPointData;
    getWorldPoint(inner: IPointData, relative?: ILeaf, distance?: boolean, change?: boolean): IPointData;
    getWorldPointByBox(box: IPointData, relative?: ILeaf, distance?: boolean, change?: boolean): IPointData;
    getWorldPointByLocal(local: IPointData, relative?: ILeaf, distance?: boolean, change?: boolean): IPointData;
    getWorldPointByPage(page: IPointData, relative?: ILeaf, distance?: boolean, change?: boolean): IPointData;
    setTransform(transform?: IMatrixData, resize?: boolean): void;
    transform(transform?: IMatrixData, resize?: boolean): void;
    move(x: number | IPointData, y?: number): void;
    moveInner(x: number | IPointData, y?: number): void;
    scaleOf(origin: IPointData | IAlign, scaleX: number, scaleY?: number, resize?: boolean): void;
    rotateOf(origin: IPointData | IAlign, rotation: number): void;
    skewOf(origin: IPointData | IAlign, skewX: number, skewY?: number, resize?: boolean): void;
    transformWorld(worldTransform?: IMatrixData, resize?: boolean): void;
    moveWorld(x: number | IPointData, y?: number): void;
    scaleOfWorld(worldOrigin: IPointData, scaleX: number, scaleY?: number, resize?: boolean): void;
    rotateOfWorld(worldOrigin: IPointData, rotation: number): void;
    skewOfWorld(worldOrigin: IPointData, skewX: number, skewY?: number, resize?: boolean): void;
    flip(axis: IAxis): void;
    scaleResize(scaleX: number, scaleY: number, noResize?: boolean): void;
    __scaleResize(scaleX: number, scaleY: number): void;
    resizeWidth(width: number): void;
    resizeHeight(height: number): void;
    __hitWorld(point: IRadiusPointData): boolean;
    __hit(local: IRadiusPointData): boolean;
    __hitFill(inner: IRadiusPointData): boolean;
    __hitStroke(inner: IRadiusPointData, strokeWidth: number): boolean;
    __hitPixel(inner: IRadiusPointData): boolean;
    __drawHitPath(canvas: ILeaferCanvas): void;
    __updateHitCanvas(): void;
    __render(canvas: ILeaferCanvas, options: IRenderOptions): void;
    __drawFast(canvas: ILeaferCanvas, options: IRenderOptions): void;
    __draw(canvas: ILeaferCanvas, options: IRenderOptions): void;
    __clip(canvas: ILeaferCanvas, options: IRenderOptions): void;
    __renderShape(canvas: ILeaferCanvas, options: IRenderOptions, ignoreFill?: boolean, ignoreStroke?: boolean): void;
    __updateWorldOpacity(): void;
    __updateChange(): void;
    __drawPath(canvas: ILeaferCanvas): void;
    __drawRenderPath(canvas: ILeaferCanvas): void;
    __updatePath(): void;
    __updateRenderPath(): void;
    getMotionPathData(): IMotionPathData;
    getMotionPoint(motionDistance: number | IUnitData): IRotationPointData;
    getMotionTotal(): number;
    __updateMotionPath(): void;
    __runAnimation(type: 'in' | 'out', complete?: IFunction): void;
    __emitLifeEvent(type: string): void;
    children?: ILeaf[];
    __updateSortChildren(): void;
    add(child: ILeaf | ILeaf[] | ILeafInputData | ILeafInputData[], index?: number): void;
    remove(child?: ILeaf | number | string | IFindMethod, destroy?: boolean): void;
    dropTo(parent: ILeaf, index?: number, resize?: boolean): void;
}
type ILeafAttrDescriptor = IObject & ThisType<ILeaf>;
interface ILeafAttrDescriptorFn {
    (key: string): ILeafAttrDescriptor;
}

interface ILeaferImageConfig {
    url: string;
    thumb?: string;
    format?: IExportFileType;
}
interface ILeaferImageOnLoaded {
    (image?: ILeaferImage): any;
}
interface ILeaferImageOnError {
    (error?: string | IObject, image?: ILeaferImage): any;
}
interface ILeaferImageCacheCanvas {
    data: IObject;
    params: IArguments;
}
interface ILeaferImagePatternPaint {
    transform: IMatrixData;
}
interface ILeaferImage {
    readonly innerId: InnerId;
    readonly url: string;
    view: unknown;
    width: number;
    height: number;
    isSVG: boolean;
    hasOpacityPixel: boolean;
    readonly completed: boolean;
    ready: boolean;
    error: IObject;
    loading: boolean;
    use: number;
    config: ILeaferImageConfig;
    load(onSuccess?: ILeaferImageOnLoaded, onError?: ILeaferImageOnError): number;
    unload(index: number, stopEvent?: boolean): void;
    getCanvas(width: number, height: number, opacity?: number, _filters?: IObject): unknown;
    getPattern(canvas: any, repeat: string | null, transform?: IMatrixData, paint?: IObject): ICanvasPattern;
    destroy(): void;
}

interface IUIEvent extends IEvent {
    x: number;
    y: number;
    altKey?: boolean;
    ctrlKey?: boolean;
    shiftKey?: boolean;
    metaKey?: boolean;
    readonly spaceKey?: boolean;
    readonly left?: boolean;
    readonly right?: boolean;
    readonly middle?: boolean;
    buttons?: number;
    path?: ILeafList;
    throughPath?: ILeafList;
    getBoxPoint?(relative?: ILeaf): IPointData;
    getInnerPoint?(relative?: ILeaf): IPointData;
    getLocalPoint?(relative?: ILeaf): IPointData;
    getPagePoint?(): IPointData;
    getInner?(relative?: ILeaf): IPointData;
    getLocal?(relative?: ILeaf): IPointData;
    getPage?(): IPointData;
}
interface IPointerEvent extends IUIEvent {
    width?: number;
    height?: number;
    pointerType?: PointerType;
    multiTouch?: boolean;
    pressure?: number;
    tangentialPressure?: number;
    tiltX?: number;
    tiltY?: number;
    twist?: number;
    isCancel?: boolean;
}
type PointerType = 'mouse' | 'pen' | 'touch';
interface IDragEvent extends IPointerEvent {
    moveX: number;
    moveY: number;
    totalX?: number;
    totalY?: number;
    getPageMove?(total?: boolean): IPointData;
    getInnerMove?(relative?: ILeaf): IPointData;
    getLocalMove?(relative?: ILeaf): IPointData;
    getPageTotal?(): IPointData;
    getInnerTotal?(relative?: ILeaf): IPointData;
    getLocalTotal?(relative?: ILeaf): IPointData;
    getPageBounds?(): IBoundsData;
}
interface IDropEvent extends IPointerEvent {
    list: ILeafList;
    data?: IObject;
}
interface IRotateEvent extends IUIEvent {
    rotation: number;
}
interface IZoomEvent extends IUIEvent {
    scale: number;
}
interface IMoveEvent extends IDragEvent {
    moveType?: 'drag' | 'move';
}
interface ISwipeEvent extends IDragEvent {
}
interface IKeyEvent extends IUIEvent {
    code?: string;
    key?: string;
}
interface IImageEvent extends IEvent {
    image?: ILeaferImage;
    attrName?: string;
    attrValue?: IObject;
    error?: string | IObject;
}

interface IInteraction extends IControl {
    target: ILeaf;
    canvas: IInteractionCanvas;
    selector: ISelector;
    running: boolean;
    readonly dragging: boolean;
    readonly transforming: boolean;
    readonly moveMode: boolean;
    readonly canHover: boolean;
    readonly isDragEmpty: boolean;
    readonly isMobileDragEmpty: boolean;
    readonly isHoldMiddleKey: boolean;
    readonly isHoldRightKey: boolean;
    readonly isHoldSpaceKey: boolean;
    config: IInteractionConfig;
    cursor: ICursorType | ICursorType[];
    readonly hitRadius: number;
    bottomList?: IPickBottom[];
    shrinkCanvasBounds: IBounds;
    downData: IPointerEvent;
    hoverData: IPointerEvent;
    downTime: number;
    focusData: ILeaf;
    receive(event: any): void;
    pointerDown(data?: IPointerEvent, defaultPath?: boolean): void;
    pointerMove(data?: IPointerEvent): void;
    pointerMoveReal(data: IPointerEvent): void;
    pointerUp(data?: IPointerEvent): void;
    pointerCancel(): void;
    multiTouch(data: IUIEvent, list: IKeepTouchData[]): void;
    menu(data: IPointerEvent): void;
    menuTap(data: IPointerEvent): void;
    move(data: IMoveEvent): void;
    zoom(data: IZoomEvent): void;
    rotate(data: IRotateEvent): void;
    keyDown(data: IKeyEvent): void;
    keyUp(data: IKeyEvent): void;
    findPath(data: IPointerEvent, options?: IPickOptions): ILeafList;
    isRootPath(data: IPointerEvent): boolean;
    isTreePath(data: IPointerEvent): boolean;
    canMove(data: IPointerEvent): boolean;
    isDrag(leaf: ILeaf): boolean;
    isPress(leaf: ILeaf): boolean;
    isHover(leaf: ILeaf): boolean;
    isFocus(leaf: ILeaf): boolean;
    cancelHover(): void;
    updateDownData(data?: IPointerEvent, options?: IPickOptions, merge?: boolean): void;
    updateHoverData(data: IPointerEvent): void;
    updateCursor(hoverData?: IPointerEvent): void;
    setCursor(cursor: ICursorType | ICursorType[]): void;
    getLocal(clientPoint: IClientPointData, updateClient?: boolean): IPointData;
    emit(type: string, data: IUIEvent, path?: ILeafList, excludePath?: ILeafList): void;
}
interface IInteractionCanvas extends ILeaferCanvas {
}
interface IInteractionConfig {
    wheel?: IWheelConfig;
    pointer?: IPointerConfig;
    touch?: ITouchConfig;
    multiTouch?: IMultiTouchConfig;
    zoom?: IZoomConfig;
    move?: IMoveConfig;
    eventer?: IObject;
    cursor?: boolean;
    keyEvent?: boolean;
}
interface IZoomConfig {
    disabled?: boolean;
    min?: number;
    max?: number;
}
interface IMoveConfig {
    disabled?: boolean;
    holdSpaceKey?: boolean;
    holdMiddleKey?: boolean;
    holdRightKey?: boolean;
    scroll?: boolean | 'limit';
    drag?: boolean | 'auto';
    dragAnimate?: boolean;
    dragEmpty?: boolean;
    dragOut?: boolean;
    autoDistance?: number;
}
interface IWheelConfig {
    disabled?: boolean;
    zoomMode?: boolean | 'mouse';
    zoomSpeed?: number;
    moveSpeed?: number;
    rotateSpeed?: number;
    delta?: IPointData;
    getScale?: INumberFunction;
    getMove?: IPointDataFunction;
    preventDefault?: boolean;
}
interface IPointerConfig {
    hitRadius?: number;
    through?: boolean;
    tapMore?: boolean;
    tapTime?: number;
    longPressTime?: number;
    transformTime?: number;
    hover?: boolean;
    touch?: boolean;
    dragHover?: boolean;
    dragDistance?: number;
    swipeDistance?: number;
    ignoreMove?: boolean;
    preventDefault?: boolean;
    preventDefaultMenu?: boolean;
}
interface ITouchConfig {
    preventDefault?: boolean | 'auto';
}
interface IMultiTouchConfig {
    disabled?: boolean;
}
interface ICursorConfig {
    stop?: boolean;
}

interface IHitCanvasManager extends ICanvasManager {
    maxTotal: number;
    getPathType(leaf: ILeaf): IHitCanvas;
    getPixelType(leaf: ILeaf, config?: ILeaferCanvasConfig): IHitCanvas;
}

interface IZoomView extends IBranch {
}

type ILeaferType = 'draw' | 'block' | 'editor' | 'design' | 'board' | 'document' | 'app' | 'website' | 'game' | 'player' | 'chart' | 'custom';
interface ILeaferConfig extends IRendererConfig, ILeaferCanvasConfig, IInteractionConfig, ILayouterConfig {
    start?: boolean;
    type?: ILeaferType;
    mobile?: boolean;
    realCanvas?: boolean;
    lazySpeard?: IFourNumber;
}
interface ILeaferAttrData {
    running: boolean;
    created: boolean;
    ready: boolean;
    viewReady: boolean;
    imageReady: boolean;
    viewCompleted: boolean;
    layoutLocked: boolean;
    transforming: boolean;
    view: unknown;
    canvas: ILeaferCanvas;
    renderer: IRenderer;
    watcher: IWatcher;
    layouter: ILayouter;
    selector?: ISelector;
    interaction?: IInteraction;
    canvasManager: ICanvasManager;
    hitCanvasManager?: IHitCanvasManager;
    autoLayout?: IAutoBounds;
    lazyBounds: IBounds;
    config: ILeaferConfig;
    readonly cursorPoint: IPointData;
    readonly clientBounds: IBoundsData;
    leafs: number;
    __eventIds: IEventListenerId[];
    __nextRenderWait: IFunction[];
    init(userConfig?: ILeaferConfig, parentApp?: IAppBase): void;
    start(): void;
    stop(): void;
    unlockLayout(): void;
    lockLayout(): void;
    updateCursor(cursor?: ICursorType): void;
    resize(size: IScreenSizeData): void;
    waitReady(item: IFunction, bind?: IObject): void;
    waitViewReady(item: IFunction, bind?: IObject): void;
    waitViewCompleted(item: IFunction, bind?: IObject): void;
    zoom(zoomType: IZoomType, padding?: IFourNumber, fixedScale?: boolean): IBoundsData;
    getValidMove(moveX: number, moveY: number): IPointData;
    getValidScale(changeScale: number): number;
    getWorldPointByClient(clientPoint: IClientPointData, updateClient?: boolean): IPointData;
    getPagePointByClient(clientPoint: IClientPointData, updateClient?: boolean): IPointData;
    updateClientBounds(): void;
    receiveEvent(event: any): void;
}
type IZoomType = 'in' | 'out' | 'fit' | 'fit-width' | 'fit-height' | number | ILeaf | ILeaf[] | IBoundsData;
interface ILeaferBase extends IZoomView, IControl, ILeaferAttrData {
    readonly isApp: boolean;
    readonly app: ILeaferBase;
    parent?: IAppBase;
}
interface ILeaferTypeCreator {
    list: ILeaferTypeList;
    register(name: string, fn: ILeaferTypeFunction): void;
    run(name: string, leafer: ILeaferBase): void;
}
interface ILeaferTypeFunction {
    (leafer: ILeaferBase): void;
}
interface ILeaferTypeList {
    [key: string]: ILeaferTypeFunction;
}
interface ICreator {
    image?(options?: ILeaferImageConfig): ILeaferImage;
    canvas?(options?: ILeaferCanvasConfig, manager?: ICanvasManager): ILeaferCanvas;
    hitCanvas?(options?: IHitCanvasConfig, manager?: ICanvasManager): IHitCanvas;
    hitCanvasManager?(): IHitCanvasManager;
    watcher?(target: ILeaf, options?: IWatcherConfig): IWatcher;
    layouter?(target: ILeaf, options?: ILayouterConfig): ILayouter;
    renderer?(target: ILeaf, canvas: ILeaferCanvas, options?: IRendererConfig): IRenderer;
    selector?(target?: ILeaf, options?: ISelectorConfig): ISelector;
    interaction?(target: ILeaf, canvas: IInteractionCanvas, selector: ISelector, options?: IInteractionConfig): IInteraction;
    editor?(options?: IObject): ILeaf;
}
interface IUICreator {
    register(UI: IObject): void;
    get(tag: string, data: IObject): IObject;
}

interface IAppBase extends ILeaferBase {
    children: ILeaferBase[];
    realCanvas: boolean;
}

type IBranchRenderModule = IBranchRender & ThisType<IBranch>;
interface IBranchRender extends ILeafRender {
    __renderBranch?(canvas: ILeaferCanvas, options: IRenderOptions): void;
}

interface ITaskProcessorConfig {
    onComplete?: IFunction;
    onTask?: IFunction;
    onError?: IFunction;
    parallel?: number;
}
interface ITaskProcessor {
    config: ITaskProcessorConfig;
    running: boolean;
    isComplete: boolean;
    percent: number;
    total: number;
    index: number;
    finishedIndex: number;
    remain: number;
    start(): void;
    pause(): void;
    resume(): void;
    skip(): void;
    stop(): void;
    add(taskCallback: IFunction, options?: ITaskOptions | number): ITaskItem;
    destroy(): void;
}
interface ITaskItem {
    parent: ITaskProcessor;
    parallel: boolean;
    isComplete: boolean;
    isCancel: boolean;
    time: number;
    run(): Promise<void>;
    complete(): void;
    cancel(): void;
}
interface ITaskOptions {
    start?: boolean;
    time?: number;
    parallel?: boolean;
    delay?: number;
}

interface ILeaferImageMap {
    [name: string]: ILeaferImage;
}
interface IImageManager {
    map: ILeaferImageMap;
    recycledList: ILeaferImage[];
    tasker: ITaskProcessor;
    patternTasker: ITaskProcessor;
    patternLocked?: boolean;
    readonly isComplete: boolean;
    get(config: ILeaferImageConfig): ILeaferImage;
    recycle(image: ILeaferImage): void;
    clearRecycled(): void;
    hasOpacityPixel(config: ILeaferImageConfig): boolean;
    isFormat(format: IExportFileType, config: ILeaferImageConfig): boolean;
    destroy(): void;
}

type ICanvasType = 'skia' | 'napi' | 'canvas' | 'miniapp';
interface ISkiaCanvas {
    toBuffer(format: IExportFileType, config: ISkiaCanvasExportConfig): Promise<any>;
    toBufferSync(format: IExportFileType, config: ISkiaCanvasExportConfig): any;
    toDataURL(format: IExportImageType, config: ISkiaCanvasExportConfig): Promise<string>;
    toDataURLSync(format: IExportImageType, config: ISkiaCanvasExportConfig): string;
    saveAs(filename: string, config: ISkiaCanvasExportConfig): Promise<void>;
    saveAsSync(filename: string, config: ISkiaCanvasExportConfig): void;
}
interface ISkiaCanvasExportConfig {
    page?: number;
    matte?: string;
    density?: number;
    quality?: number;
    outline?: boolean;
}
interface ISkiaNAPICanvas {
    encodeSync(format: 'webp' | 'jpeg', quality?: number): any;
    encodeSync(format: 'png'): any;
    encode(format: 'webp' | 'jpeg' | string, quality?: number): Promise<any>;
    encode(format: 'png'): Promise<any>;
    toBuffer(mime: 'image/png'): any;
    toBuffer(mime: 'image/jpeg' | 'image/webp' | string, quality?: number): any;
    toDataURL(mime?: 'image/png'): string;
    toDataURL(mime: 'image/jpeg' | 'image/webp' | string, quality?: number): string;
    toDataURLAsync(mime?: 'image/png'): Promise<string>;
    toDataURLAsync(mime: 'image/jpeg' | 'image/webp' | string, quality?: number): Promise<string>;
}

interface IPlatform {
    name?: 'web' | 'node' | 'miniapp';
    os?: 'Mac' | 'Windows' | 'Linux';
    toURL(text: string, fileType?: 'text' | 'svg'): string;
    requestRender?(render: IFunction): void;
    canvas?: ILeaferCanvas;
    renderCanvas?: ILeaferCanvas;
    canvasType?: ICanvasType;
    isWorker?: boolean;
    isMobile?: boolean;
    readonly devicePixelRatio?: number;
    intWheelDeltaY?: boolean;
    conicGradientSupport?: boolean;
    conicGradientRotate90?: boolean;
    fullImageShadow?: boolean;
    syncDomFont?: boolean;
    selector?: ISelector;
    layout?(target: ILeaf): void;
    origin?: {
        createCanvas(width: number, height: number, format?: 'svg' | 'pdf'): any;
        canvasToDataURL(canvas: any, type?: IExportImageType, quality?: number): string | Promise<string>;
        canvasToBolb(canvas: any, type?: IExportFileType, quality?: number): Promise<any>;
        canvasSaveAs(canvas: any, filename: string, quality?: number): Promise<void>;
        download(url: string, filename: string): Promise<void>;
        loadImage(url: string): Promise<any>;
        noRepeat?: string;
    };
    roundRectPatch?: boolean;
    ellipseToCurve?: boolean;
    event?: {
        stopDefault(origin: IObject): void;
        stopNow(origin: IObject): void;
        stop(origin: IObject): void;
    };
    miniapp?: IMiniapp;
    image: {
        hitCanvasSize: number;
        maxCacheSize: number;
        maxPatternSize: number;
        prefix?: string;
        suffix?: string;
        crossOrigin: string | false;
        getRealURL: IStringFunction;
    };
}
interface IMiniappSelect extends IObject {
}
interface IMiniappSizeView extends ISizeData {
    view: any;
}
interface IMiniapp {
    select(name: string): IMiniappSelect;
    getBounds(select: IMiniappSelect): Promise<IBoundsData>;
    getSizeView(select: IMiniappSelect): Promise<IMiniappSizeView>;
    onWindowResize(fun: IFunction): void;
    offWindowResize(fun: IFunction): void;
    saveToAlbum(path: string): Promise<any>;
}

interface IPlugin extends IObject {
    name?: string;
    importVersion: string;
    import: string[];
    run(LeaferUI: IObject, config: IObject): void;
    onLeafer?(leafer: ILeaferBase): void;
}

interface ICursorTypeMap {
    [name: string]: ICursorType | ICursorType[];
}
interface ICursorRotate {
    rotation?: number;
    data?: string;
}
interface ICursorRotateMap {
    [name: string]: ICursorRotate;
}

export type { ACommandData, ArcCommandData, ArcToCommandData, BezierCurveToCommandObject, CCommandData, CanvasPathCommand, EllipseCommandData, HCommandData, IAlign, IAnimateEvent, IAnswer, IAppBase, IAround, IAttrDecorator, IAutoBounds, IAutoBoundsData, IAutoBoxData, IAutoSize, IAxis, IAxisAlign, IAxisReverse, IBaseLineAlign, IBlendMode, IBlob, IBlobFunction, IBoolean, IBooleanMap, IBounds, IBoundsData, IBoundsDataFn, IBoundsType, IBranch, IBranchRender, IBranchRenderModule, ICachedLeaf, ICanvasAttr, ICanvasCacheOptions, ICanvasContext2D, ICanvasContext2DSettings, ICanvasManager, ICanvasPattern, ICanvasStrokeOptions, ICanvasType, IChildEvent, IClientPointData, IConstraint, IConstraintType, IControl, ICreator, ICursorConfig, ICursorRotate, ICursorRotateMap, ICursorType, ICursorTypeMap, IDataProcessor, IDataTypeHandle, IDirection, IDirection4, IDragEvent, IDropEvent, IEditSize, IEraserType, IEvent, IEventListener, IEventListenerId, IEventListenerItem, IEventListenerMap, IEventListenerOptions, IEventMap, IEventOption, IEventTarget, IEventer, IExportFileType, IExportImageType, IExportOnCanvasFunction, IExportOptions, IExportResult, IExportResultFunction, IFindCondition, IFindMethod, IFlowAlign, IFlowAxisAlign, IFlowBoxType, IFlowType, IFlowWrap, IFourNumber, IFromToData, IFunction, IFunctionMap, IGap, IHitCanvas, IHitCanvasConfig, IHitCanvasManager, IHitType, IImageCursor, IImageEvent, IImageManager, IInteraction, IInteractionCanvas, IInteractionConfig, IJSONOptions, IKeepTouchData, IKeyEvent, ILayoutAttr, ILayoutBlockData, ILayoutBoundsData, ILayoutChangedData, ILayoutData, ILayoutEvent, ILayouter, ILayouterConfig, ILeaf, ILeafArrayMap, ILeafAttrData, ILeafAttrDescriptor, ILeafAttrDescriptorFn, ILeafBounds, ILeafBoundsModule, ILeafComputedData, ILeafData, ILeafDataOptions, ILeafDataProxy, ILeafDataProxyModule, ILeafEventer, ILeafEventerModule, ILeafHit, ILeafHitModule, ILeafInputData, ILeafLayout, ILeafLevelList, ILeafList, ILeafListItemCallback, ILeafMap, ILeafMatrix, ILeafMatrixModule, ILeafRender, ILeafRenderModule, ILeaferAttrData, ILeaferBase, ILeaferCanvas, ILeaferCanvasConfig, ILeaferCanvasView, ILeaferConfig, ILeaferEvent, ILeaferImage, ILeaferImageCacheCanvas, ILeaferImageConfig, ILeaferImageOnError, ILeaferImageOnLoaded, ILeaferImagePatternPaint, ILeaferType, ILeaferTypeCreator, ILeaferTypeFunction, ILeaferTypeList, ILocationType, IMaskType, IMatrix, IMatrixData, IMatrixWithBoundsData, IMatrixWithBoundsScaleData, IMatrixWithLayoutData, IMatrixWithOptionScaleData, IMatrixWithScaleData, IMiniapp, IMiniappSelect, IMiniappSizeView, IMotionPathData, IMoveConfig, IMoveEvent, IMultiTouchConfig, IMultiTouchData, INumber, INumberFunction, INumberMap, IObject, IObjectFunction, IOffsetBoundsData, IPartLayoutConfig, IPath2D, IPathCommandData, IPathCommandObject, IPathCreator, IPathDrawer, IPathString, IPercentData, IPickBottom, IPickOptions, IPickResult, IPlatform, IPlugin, IPoint, IPointData, IPointDataFunction, IPointDataMap, IPointGap, IPointerConfig, IPointerEvent, IPropertyEvent, IRadiusPointData, IRangeSize, IRenderEvent, IRenderOptions, IRenderer, IRendererConfig, IResizeEvent, IResizeEventListener, IRotateEvent, IRotationPointData, IScaleData, IScaleRotationData, IScreenSizeData, IScrollPointData, ISelector, ISelectorConfig, ISelectorProxy, ISide, ISize, ISizeData, ISkewData, ISkiaCanvas, ISkiaCanvasExportConfig, ISkiaNAPICanvas, IStateStyleType, IString, IStringFunction, IStringMap, ISwipeEvent, ITaskItem, ITaskOptions, ITaskProcessor, ITaskProcessorConfig, ITextMetrics, ITimer, ITouchConfig, ITwoPointBoundsData, IUICreator, IUIEvent, IUnitData, IUnitPointData, IUpdateEvent, IValue, IWatchEvent, IWatchEventData, IWatcher, IWatcherConfig, IWheelConfig, IWindingRule, IZoomConfig, IZoomEvent, IZoomType, IZoomView, InnerId, LCommandData, LineToCommandObject, MCommandData, MoveToCommandObject, PointerType, QCommandData, QuadraticCurveToCommandObject, RectCommandData, RoundRectCommandData, SCommandData, TCommandData, VCommandData, ZCommandData };
