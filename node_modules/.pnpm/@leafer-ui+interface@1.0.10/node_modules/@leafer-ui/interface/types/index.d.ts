import { IBlendMode, IAlign, IUnitPointData, IExportFileType, IFourNumber, IPointData, ISizeData, IPathCommandData, IWindingRule, IObject, IMatrixData, ILeaferImage, ITaskItem, IBoolean, INumber, IString, IUnitData, IEventer, IEventMap, IPercentData, IBoundsData as IBoundsData$1, IPathCreator, ILeaferCanvas, ICanvasContext2D, ICanvasContext2DSettings, IRenderOptions, IPickOptions, IPickResult, ILeaf as ILeaf$1, IFindCondition, IJSONOptions, IValue, IPathString, IPathDrawer, IExportOptions, IExportResult, IAnswer, ILeafData, ILeafComputedData, ILeafInputData, ILeaferAttrData, IControl, ILeaferConfig, ILeaferType, ILeafRender, ILeafBounds, ILeafHit, ICachedLeaf, IBooleanMap, IAround } from '@leafer/interface';
export * from '@leafer/interface';
import { IGroup as IGroup$1, ISelectorProxy, IUI as IUI$1, ILeafList, IObject as IObject$1, ILeaf, IEditSize, IDragEvent, IZoomEvent, IRotateEvent, IGroupInputData as IGroupInputData$1, IStroke as IStroke$1, IFill as IFill$1, IBoxInputData as IBoxInputData$1, IRectInputData as IRectInputData$1, IColorString as IColorString$1, IDirection4, ICursorType, IImageCursor, IAlign as IAlign$1, IUnitPointData as IUnitPointData$1, IUIInputData as IUIInputData$1, IBox as IBox$1, IRect as IRect$1, IBoundsData, IKeyEvent, IStateName as IStateName$1, IString as IString$1, IBoolean as IBoolean$1, IStateStyle as IStateStyle$1 } from '@leafer-ui/interface';

type IPercent = string;
type IColorString = string;
type ICornerRadiusString = string;
type IStrokeWidthString = string;
type IDashPatternString = string;
type IPaintString = ISolidPaintString | IGradientPaintString | IImagePaintString;
type ISolidPaintString = string;
type IGradientPaintString = string;
type IImagePaintString = string;
type IShadowString = string;

type IPaint = ISolidPaint | IGradientPaint | IImagePaint;
type IFill = IPaint | IPaint[] | IPaintString;
type IStroke = IPaint | IPaint[] | IPaintString;
type IPaintAttr = 'fill' | 'stroke';
interface IPaintBase {
    type: IPaintType;
    blendMode?: IBlendMode;
    visible?: boolean;
    opacity?: number;
}
type IPaintType = 'image' | 'solid' | IGradientType;
type IGradientType = 'linear' | 'radial' | 'angular';
interface ISolidPaint extends IPaintBase {
    type: 'solid';
    color: IColor;
}
type IColor = IColorString | IRGB | IRGBA;
interface IRGB {
    r: number;
    g: number;
    b: number;
    a?: number;
}
interface IRGBA extends IRGB {
    a: number;
}
interface IGradientPaint extends IPaintBase {
    type: IGradientType;
    from?: IAlign | IUnitPointData;
    to?: IAlign | IUnitPointData;
    stretch?: number;
    stops: IColorStop[] | IColorString[];
}
interface IColorStop {
    offset: number;
    color: IColor;
}
interface IImagePaint extends IPaintBase {
    type: "image";
    url: string;
    mode?: IImagePaintMode;
    format?: IExportFileType;
    filters?: IImageFilters;
    padding?: IFourNumber;
    align?: IAlign;
    offset?: IPointData;
    size?: number | ISizeData;
    scale?: number | IPointData;
    rotation?: number;
    repeat?: IRepeat;
    sync?: boolean;
}
interface IImageFilters {
    exposure?: number;
    contrast?: number;
    saturation?: number;
    temperature?: number;
    tint?: number;
    highlights?: number;
    shadows?: number;
}
type IImagePaintMode = 'normal' | 'cover' | 'fit' | 'stretch' | 'clip' | 'repeat';
type IRepeat = boolean | 'x' | 'y';
type IStrokeAlign = 'inside' | 'outside' | 'center';
type IStrokeCap = 'none' | 'round' | 'square';
type IStrokeJoin = 'bevel' | 'round' | 'miter';
type IArrowType = IPathDataArrow | 'none' | 'angle' | 'angle-side' | 'arrow' | 'triangle' | 'triangle-flip' | 'circle' | 'circle-line' | 'square' | 'square-line' | 'diamond' | 'diamond-line' | 'mark';
interface IPathDataArrowMap {
    [name: string]: IPathDataArrow;
}
interface IPathDataArrow {
    connect?: IPathDataArrowOffset;
    offset?: IPathDataArrowOffset;
    path: IPathCommandData;
}
interface IPathDataArrowOffset {
    x?: number;
    bevelJoin?: number;
    roundJoin?: number;
}
type ITextAlign = 'left' | 'center' | 'right' | 'justify';
type IVerticalAlign = 'top' | 'middle' | 'bottom';
type ITextCase = 'upper' | 'lower' | 'title' | 'none' | 'small-caps';
type IFontWeight = IFontWeightNumer | IFontWeightString;
type IFontWeightNumer = 100 | 200 | 300 | 400 | 500 | 600 | 700 | 800 | 900;
type IFontWeightString = 'thin' | 'extra-light' | 'light' | 'normal' | 'medium' | 'semi-bold' | 'bold' | 'extra-bold' | 'black';
type ITextDecoration = 'none' | 'under' | 'delete';
type ITextWrap = 'normal' | 'none' | 'break';
interface IVectorPath {
    rule?: IWindingRule;
    data: string | IPathCommandData;
}
interface IShadowEffect {
    x: number;
    y: number;
    blur: number;
    spread?: number;
    color: IColorString | IColor;
    blendMode?: IBlendMode;
    visible?: boolean;
    box?: boolean;
}
interface IBlurEffect {
    blur: number;
    visible?: boolean;
}
interface IGrayscaleEffect {
    grayscale: number;
    visible?: boolean;
}
type IEffect = IObject;
type IOverflow = 'show' | 'hide';

type ILeafPaintColor = IColorString | CanvasGradient | CanvasPattern;
interface ILeafPaint {
    type?: IPaintType;
    style?: ILeafPaintColor;
    transform?: IMatrixData;
    blendMode?: IBlendMode;
    opacity?: number;
    image?: ILeaferImage;
    loadId?: number;
    patternId?: string;
    patternTask?: ITaskItem;
    sync?: boolean;
    data?: ILeafPaintPatternData;
}
interface ILeafPaintPatternData {
    width?: number;
    height?: number;
    scaleX?: number;
    scaleY?: number;
    opacity?: number;
    transform?: IMatrixData;
    mode?: IImagePaintMode;
    repeat?: 'repeat' | 'repeat-x' | 'repeat-y';
}
type ILeafFill = ILeafPaint;
interface ILeafStrokePaint extends ILeafPaint {
    strokeAlign?: IStrokeAlign;
    strokeWidth?: number;
    strokeCap?: IStrokeCap;
    strokeJoin?: IStrokeJoin;
    dashPattern?: number[];
    miterLimit?: number;
}
interface ILeafShadowEffect {
    x: number;
    y: number;
    blur: number;
    spread?: number;
    color: IColorString;
    blendMode?: IBlendMode;
    box?: boolean;
}

interface ICornerRadiusAttrData {
    cornerRadius?: IFourNumber | ICornerRadiusString;
    cornerSmoothing?: INumber;
}
interface ICornerRadiusInputData {
    cornerRadius?: IFourNumber | ICornerRadiusString;
    cornerSmoothing?: INumber;
}
interface ICornerRadiusComputedData {
    cornerRadius?: number;
    cornerSmoothing?: number;
}
interface IFillAttrData {
    fill?: IFill;
}
interface IFillInputData {
    fill?: IFill;
}
interface IFillComputedData {
    fill?: IColorString | ILeafPaint[];
}
interface IBorderComputedData {
    borderWidth?: number | number[];
    borderRadius?: number | number[];
}
interface IStrokeAttrData {
    stroke?: IStroke;
    strokeAlign?: IStrokeAlign;
    strokeWidth?: IFourNumber | IStrokeWidthString;
    strokeWidthFixed?: IBoolean;
    strokeCap?: IStrokeCap;
    strokeJoin?: IStrokeJoin;
    dashPattern?: INumber[] | IDashPatternString;
    dashOffset?: INumber;
    miterLimit?: INumber;
    startArrow?: IArrowType;
    endArrow?: IArrowType;
}
interface IStrokeInputData {
    stroke?: IStroke;
    strokeAlign?: IStrokeAlign;
    strokeWidth?: IFourNumber | IStrokeWidthString;
    strokeWidthFixed?: IBoolean;
    strokeCap?: IStrokeCap;
    strokeJoin?: IStrokeJoin;
    dashPattern?: INumber[] | IDashPatternString;
    dashOffset?: INumber;
    miterLimit?: INumber;
    startArrow?: IArrowType;
    endArrow?: IArrowType;
}
interface IStrokeComputedData {
    stroke?: IColorString | ILeafStrokePaint[];
    strokeAlign?: IStrokeAlign;
    strokeWidth?: number;
    strokeWidths?: number[];
    strokeWidthFixed?: boolean;
    strokeCap?: IStrokeCap;
    strokeJoin?: IStrokeJoin;
    dashPattern?: number[];
    dashOffset?: number;
    miterLimit?: number;
    startArrow?: IArrowType;
    endArrow?: IArrowType;
}
interface ITextStyleAttrData {
    fontFamily?: IString;
    fontSize?: INumber;
    fontWeight?: IFontWeight;
    italic?: IBoolean;
    textCase?: ITextCase;
    textDecoration?: ITextDecoration;
    letterSpacing?: INumber | IUnitData;
    lineHeight?: INumber | IUnitData;
    paraIndent?: INumber;
    paraSpacing?: INumber;
    textAlign?: ITextAlign;
    verticalAlign?: IVerticalAlign;
    autoSizeAlign?: IBoolean;
    textWrap?: ITextWrap;
    textOverflow?: IOverflow | string;
}
interface ITextStyleInputData {
    fontFamily?: IString;
    fontSize?: INumber;
    fontWeight?: IFontWeight;
    italic?: IBoolean;
    textCase?: ITextCase;
    textDecoration?: ITextDecoration;
    letterSpacing?: INumber | IUnitData;
    lineHeight?: INumber | IUnitData;
    paraIndent?: INumber;
    paraSpacing?: INumber;
    textAlign?: ITextAlign;
    verticalAlign?: IVerticalAlign;
    autoSizeAlign?: IBoolean;
    textWrap?: ITextWrap;
    textOverflow?: IOverflow | string;
}
interface ITextStyleComputedData {
    fontFamily?: string;
    fontSize?: number;
    fontWeight?: IFontWeight;
    italic?: boolean;
    textCase?: ITextCase;
    textDecoration?: ITextDecoration;
    letterSpacing?: number;
    lineHeight?: number;
    paraIndent?: number;
    paraSpacing?: number;
    textAlign?: ITextAlign;
    verticalAlign?: IVerticalAlign;
    autoSizeAlign?: boolean;
    textWrap?: ITextWrap;
    textOverflow?: IOverflow | string;
}
interface IEffectAttrData {
    shadow?: IShadowEffect | IShadowEffect[] | IShadowString;
    innerShadow?: IShadowEffect | IShadowEffect[] | IShadowString;
    blur?: INumber | IBlurEffect;
    backgroundBlur?: INumber | IBlurEffect;
    grayscale?: INumber | IGrayscaleEffect;
}
interface IEffectInputData {
    shadow?: IShadowEffect | IShadowEffect[] | IShadowString;
    innerShadow?: IShadowEffect | IShadowEffect[] | IShadowString;
    blur?: INumber | IBlurEffect;
    backgroundBlur?: INumber | IBlurEffect;
    grayscale?: INumber | IGrayscaleEffect;
}
interface IEffectComputedData {
    shadow?: ILeafShadowEffect[];
    innerShadow?: ILeafShadowEffect[];
    blur?: number;
    backgroundBlur?: number;
    grayscale?: number;
}

type IAnimation = IStyleAnimation | IKeyframesAnimation;
type ITransition = IAnimateOptions | IAnimateEasingName | number | boolean;
type IAnimateType = 'all' | 'animation' | 'transition' | 'animate';
interface IStyleAnimation extends IAnimateOptions {
    style: IUIInputData;
}
interface IKeyframesAnimation extends IAnimateOptions {
    keyframes: IKeyframe[];
}
interface IAnimateOptions {
    easing?: IAnimateEasing;
    delay?: number;
    duration?: number;
    ending?: IAnimateEnding;
    reverse?: boolean;
    swing?: boolean;
    loop?: boolean | number;
    loopDelay?: number;
    speed?: number;
    join?: boolean;
    autoplay?: boolean;
    attrs?: string[];
    event?: IAnimateEvents;
}
type IKeyframe = IUIInputData | IAnimateKeyframe;
type IKeyframeId = number;
interface IAnimateKeyframe {
    style: IUIInputData;
    easing?: IAnimateEasing;
    delay?: number;
    duration?: number;
    autoDelay?: number;
    autoDuration?: number;
}
interface IComputedKeyframe {
    style: IUIInputData;
    beforeStyle: IUIInputData;
    betweenStyle?: IUIInputData;
    easingFn?: IAnimateEasingFunction;
    delay?: number;
    duration?: number;
    autoDelay?: number;
    autoDuration?: number;
    totalTime?: number;
}
interface IAnimateEasingFunction {
    (t: number): number;
}
interface ICustomEasingFunction {
    (...arg: any): IAnimateEasingFunction;
}
type IAnimateEasing = IAnimateEasingName | ICubicBezierEasing | IStepsEasing | IObject;
interface ICubicBezierEasing {
    name: 'cubic-bezier';
    value: [number, number, number, number];
}
interface IStepsEasing {
    name: 'steps';
    value: number | [number, 'floor' | 'round' | 'ceil'];
}
type IAnimateEasingName = 'linear' | 'ease' | 'ease-in' | 'ease-out' | 'ease-in-out' | 'sine-in' | 'sine-out' | 'sine-in-out' | 'quad-in' | 'quad-out' | 'quad-in-out' | 'cubic-in' | 'cubic-out' | 'cubic-in-out' | 'quart-in' | 'quart-out' | 'quart-in-out' | 'quint-in' | 'quint-out' | 'quint-in-out' | 'expo-in' | 'expo-out' | 'expo-in-out' | 'circ-in' | 'circ-out' | 'circ-in-out' | 'back-in' | 'back-out' | 'back-in-out' | 'elastic-in' | 'elastic-out' | 'elastic-in-out' | 'bounce-in' | 'bounce-out' | 'bounce-in-out';
type IAnimateEnding = 'auto' | 'from' | 'to';
interface IAnimateEvents {
    created?: IAnimateEventFunction;
    play?: IAnimateEventFunction;
    pause?: IAnimateEventFunction;
    stop?: IAnimateEventFunction;
    seek?: IAnimateEventFunction;
    update?: IAnimateEventFunction;
    completed?: IAnimateEventFunction;
}
interface IAnimateEventFunction {
    (animate?: IAnimate): any;
}
interface IAnimate extends IAnimateOptions, IEventer {
    target: IUI;
    keyframes: IKeyframe[];
    config?: IAnimateOptions;
    event?: IEventMap;
    readonly frames: IComputedKeyframe[];
    readonly fromStyle: IUIInputData;
    readonly toStyle: IUIInputData;
    readonly endingStyle: IUIInputData;
    readonly started: boolean;
    readonly running: boolean;
    readonly completed: boolean;
    readonly destroyed: boolean;
    readonly time: number;
    readonly looped: number;
    readonly realEnding: IAnimateEnding;
    init(target: IUI, keyframe: IUIInputData | IKeyframe[], options?: ITransition, isTemp?: boolean): void;
    play(): void;
    pause(): void;
    stop(): void;
    seek(time: number | IPercentData): void;
    kill(): void;
    destroy(complete?: boolean): void;
}

interface IEditorBase extends IGroup$1, ISelectorProxy {
    config: IEditorConfig;
    readonly mergeConfig: IEditorConfig;
    hoverTarget?: IUI$1;
    target?: IUI$1 | IUI$1[];
    readonly list: IUI$1[];
    leafList: ILeafList;
    openedGroupList: ILeafList;
    readonly editing: boolean;
    innerEditing: boolean;
    readonly groupOpening: boolean;
    resizeDirection?: number;
    readonly multiple: boolean;
    readonly single: boolean;
    readonly dragging: boolean;
    readonly moving: boolean;
    element?: IUI$1;
    buttons: IGroup$1;
    selector: IGroup$1;
    editBox: IEditBoxBase;
    editTool?: IObject$1;
    innerEditor?: IObject$1;
    select(target: IUI$1 | IUI$1[]): void;
    cancel(): void;
    hasItem(item: IUI$1): boolean;
    shiftItem(item: IUI$1): void;
    addItem(item: IUI$1): void;
    removeItem(item: IUI$1): void;
    update(): void;
    updateEditBox(): void;
    updateEditTool(): void;
    getEditSize(ui: ILeaf): IEditSize;
    onMove(e: IDragEvent): void;
    onScale(e: IDragEvent | IZoomEvent): void;
    onRotate(e: IDragEvent | IRotateEvent): void;
    onSkew(e: IDragEvent): void;
    group(group?: IGroup$1 | IGroupInputData$1): IGroup$1;
    ungroup(): IUI$1[];
    openGroup(group: IGroup$1): void;
    closeGroup(group: IGroup$1): void;
    openInnerEditor(target?: IUI$1, select?: boolean): void;
    closeInnerEditor(): void;
    lock(): void;
    unlock(): void;
    toTop(): void;
    toBottom(): void;
}
interface IEditorConfig {
    editSize?: IEditSize;
    dualEvent?: boolean;
    keyEvent?: boolean;
    stroke?: IStroke$1;
    strokeWidth?: number;
    pointFill?: IFill$1;
    pointSize?: number;
    pointRadius?: number;
    point?: IEditPointInputData | IEditPointInputData[];
    middlePoint?: IEditPointInputData | IEditPointInputData[];
    rect?: IBoxInputData$1;
    area?: IRectInputData$1;
    mask?: boolean | IColorString$1;
    circle?: IEditPointInputData;
    circleDirection?: IDirection4;
    circleMargin?: number;
    rotatePoint?: IEditPointInputData;
    buttonsDirection?: IDirection4;
    buttonsFixed?: boolean | 'AABB' | 'OBB';
    buttonsMargin?: number;
    hideOnMove?: boolean;
    hideOnSmall?: boolean | number;
    moveCursor?: ICursorType;
    resizeCursor?: IImageCursor;
    rotateCursor?: IImageCursor;
    skewCursor?: IImageCursor;
    around?: IAlign$1 | IUnitPointData$1;
    lockRatio?: boolean | 'corner';
    rotateGap?: number;
    selector?: boolean;
    hover?: boolean;
    hoverStyle?: IUIInputData$1;
    select?: 'press' | 'tap';
    boxSelect?: boolean;
    continuousSelect?: boolean;
    openInner?: 'double' | 'long';
    moveable?: boolean | 'move';
    resizeable?: boolean | 'zoom';
    flipable?: boolean;
    rotateable?: boolean | 'rotate';
    skewable?: boolean;
}
interface IEditPointInputData extends IBoxInputData$1 {
    direction?: number;
    pointType?: IEditPointType;
}
interface IEditPoint extends IBox$1 {
    direction: number;
    pointType: IEditPointType;
}
type IEditPointType = 'rotate' | 'resize' | 'button';
interface IEditBoxBase extends IGroup$1 {
    editor: IEditorBase;
    dragging: boolean;
    moving: boolean;
    view: IGroup$1;
    circle: IEditPoint;
    rect: IRect$1;
    buttons: IGroup$1;
    resizePoints: IEditPoint[];
    rotatePoints: IEditPoint[];
    resizeLines: IEditPoint[];
    readonly flipped: boolean;
    readonly flippedX: boolean;
    readonly flippedY: boolean;
    readonly flippedOne: boolean;
    enterPoint: IEditPoint;
    getPointStyle(userStyle?: IBoxInputData$1): IBoxInputData$1;
    getPointsStyle(): IBoxInputData$1[];
    getMiddlePointsStyle(): IBoxInputData$1[];
    load(): void;
    update(bounds: IBoundsData): void;
    unload(): void;
    onArrow(e: IKeyEvent): void;
}
interface IEditorConfigFunction {
    (ui: any): IEditorConfig;
}
interface IEditToolFunction {
    (ui: any): string;
}

interface ILine extends ILineAttrData, IUI {
    __: ILineData;
}
interface ILineAttrData {
    toPoint?: IPointData;
    points?: number[] | IPointData[];
    curve?: boolean | number;
}
interface ILineData extends ILineAttrData, IUIData {
}
interface ILineInputData extends ILineAttrData, IUIBaseInputData {
}
interface IArrow extends ILine {
    __: IArrowData;
}
interface IArrowAttrData {
}
interface IArrowData extends IArrowAttrData, ILineData {
}
interface IArrowInputData extends IArrowAttrData, ILineInputData {
}
interface IFlow extends IBox {
    __: IFlowData;
}
interface IFlowAttrData {
}
interface IFlowData extends IFlowAttrData, IBoxData {
}
interface IFlowInputData extends IFlowAttrData, IBoxInputData {
}
interface IVideo extends IPlayerMethods, IRect {
    __: IVideoData;
}
interface IPlayerMethods {
    play(): void;
    pause(): void;
    stop(): void;
}
interface IVideoAttrData {
    url?: string;
}
interface IVideoData extends IVideoAttrData, IRectData {
}
interface IVideoInputData extends IVideoAttrData, IRectInputData {
}
interface IGIF extends IPlayerMethods, IRect {
    __: IGIFData;
}
interface IGIFAttrData {
    url?: string;
}
interface IGIFData extends IGIFAttrData, IRectData {
}
interface IGIFInputData extends IGIFAttrData, IRectInputData {
}
interface IRobot extends IRobotAttrData, IPlayerMethods, IRect {
    __: IRobotData;
    readonly running: boolean;
    readonly nowFrame?: IRobotComputedKeyframe;
    readonly robotFrames?: IRobotComputedKeyframe[];
    __updateRobot(): void;
    __updateAction(): void;
}
interface IRobotAttrData {
    robot?: IRobotKeyframe | IRobotKeyframe[];
    actions?: IRobotActions;
    action?: IRobotActionName;
    now?: number;
    FPS?: number;
    loop?: boolean;
}
interface IRobotActions {
    [name: string]: IKeyframeId | IKeyframeId[] | IRobotAnimation;
}
interface IRobotAnimation {
    keys: IKeyframeId[];
    loop?: boolean | number;
    speed?: number;
}
type IRobotActionName = string;
interface IRobotKeyframe {
    mode?: 'normal' | 'clip';
    url: string;
    offset?: IPointData;
    size?: number | ISizeData;
    total?: number;
}
interface IRobotComputedKeyframe extends IBoundsData$1 {
    view: any;
}
interface IRobotData extends IRobotAttrData, IRectData {
}
interface IRobotInputData extends IRobotAttrData, IRectInputData {
}
interface IRect extends IUI {
    __: IRectData;
}
interface IRectData extends IUIData {
}
interface IRectInputData extends IUIBaseInputData {
}
interface IEllipse extends IUI, IEllipseAttrData {
    __: IEllipseData;
}
interface IEllipseAttrData {
    startAngle?: number;
    endAngle?: number;
    innerRadius?: number;
}
interface IEllipseData extends IEllipseAttrData, IUIData {
}
interface IEllipseInputData extends IEllipseAttrData, IUIBaseInputData {
}
interface IPolygon extends IPolygonAttrData, IUI {
    __: IPolygonData;
}
interface IPolygonAttrData {
    sides?: number;
    points?: number[] | IPointData[];
    curve?: boolean | number;
}
interface IPolygonData extends IPolygonAttrData, IUIData {
}
interface IPolygonInputData extends IPolygonAttrData, IUIBaseInputData {
}
interface IStar extends IStarAttrData, IUI {
    __: IStarData;
}
interface IStarAttrData {
    corners?: number;
    innerRadius?: number;
}
interface IStarData extends IStarAttrData, IUIData {
}
interface IStarInputData extends IStarAttrData, IUIBaseInputData {
}
interface IPath extends IUI {
    __: IPathData;
}
interface IPathData extends IUIData {
}
interface IPathInputData extends IUIBaseInputData {
}
interface IPen extends IGroup, IPathCreator {
    __: IPenData;
    pathElement: IPath;
    pathStyle: IPathInputData;
    path: IPathCommandData;
    paint(): void;
}
interface IPenData extends IGroupData {
}
interface IPenInputData extends IGroupInputData {
}
interface IText extends ITextAttrData, ITextStyleAttrData, IUI {
    __: ITextData;
}
interface ITextAttrData {
    text?: string;
    padding?: IFourNumber;
    resizeFontSize?: boolean;
}
interface ITextData extends ITextAttrData, ITextStyleComputedData, IUIData {
    __baseLine?: number;
    __lineHeight?: number;
    __letterSpacing?: number;
    __padding?: number[];
    __clipText?: boolean;
    __textBoxBounds?: IBoundsData$1;
}
interface ITextInputData extends ITextAttrData, ITextStyleInputData, IUIBaseInputData {
}
interface ITextRowData {
    x?: number;
    y?: number;
    width?: number;
    height?: number;
    text?: string;
    data?: ITextCharData[];
    words?: ITextWordData[];
    startCharSize?: number;
    endCharSize?: number;
    paraStart?: boolean;
    paraEnd?: boolean;
    isOverflow?: boolean;
    textMode?: boolean;
}
interface ITextWordData {
    x?: number;
    y?: number;
    width?: number;
    height?: number;
    data?: ITextCharData[];
}
interface ITextCharData {
    x?: number;
    y?: number;
    width?: number;
    height?: number;
    char?: string;
}
interface ITextDrawData {
    bounds: IBoundsData$1;
    rows: ITextRowData[];
    paraNumber: number;
    font: string;
    maxWidth?: number;
    decorationY?: number;
    decorationHeight?: number;
    overflow?: number;
}
interface IImage extends IImageAttrData, IRect {
    __: IImageData;
    ready: boolean;
    image?: ILeaferImage;
}
interface IImageAttrData {
    url?: string;
}
interface IImageData extends IImageAttrData, IRectData {
    __setImageFill(value: string): void;
}
interface IImageInputData extends IImageAttrData, IUIBaseInputData {
}
interface ICanvas extends ICanvasAttrData, IRect {
    __: ICanvasData;
    canvas?: ILeaferCanvas;
    context?: ICanvasContext2D;
    __updateSize(): void;
}
interface ICanvasAttrData {
    smooth?: boolean;
    contextSettings?: ICanvasContext2DSettings;
    url?: string;
}
interface ICanvasData extends ICanvasAttrData, IRectData {
}
interface ICanvasInputData extends ICanvasAttrData, IUIBaseInputData {
}
interface ILeaferData extends IGroupData {
}
interface ILeaferInputData extends IGroupInputData {
}
interface IAppData extends ILeaferData {
}
interface IAppInputData extends ILeaferInputData {
}
interface IFrame extends IBox {
    __: IFrameData;
}
interface IFrameData extends IBoxData {
}
interface IFrameInputData extends IBoxInputData {
}
interface IBox extends IBoxAttrData, IGroup {
    __: IBoxData;
    __updateRectRenderBounds(): void;
    __renderGroup(canvas: ILeaferCanvas, options: IRenderOptions): void;
}
interface IBoxAttrData {
    overflow?: IOverflow;
    resizeChildren?: IBoolean;
    textBox?: IBoolean;
}
interface IBoxData extends IBoxAttrData, IGroupData {
}
interface IBoxInputData extends IBoxAttrData, IGroupInputData {
}
interface IGroup extends IUI {
    __: IGroupData;
    children: IUI[];
    pick(hitPoint: IPointData, options?: IPickOptions): IPickResult;
    add(child: IUI | IUI[] | IUIInputData | IUIInputData[], index?: number): void;
    addAt(child: IUI | IUI[] | IUIInputData | IUIInputData[], index: number): void;
    addAfter(child: IUI | IUI[] | IUIInputData | IUIInputData[], after: IUI): void;
    addBefore(child: IUI | IUI[] | IUIInputData | IUIInputData[], before: IUI): void;
    addMany(...children: ILeaf$1[] | IUIInputData[]): void;
    remove(child?: IUI | number | string | IFindCondition | IFindUIMethod): void;
    removeAll(): void;
    clear(): void;
}
interface IGroupData extends IUIData {
}
interface IGroupInputData extends IUIBaseInputData {
}
interface IUI extends IUIAttrData, IFillAttrData, IStrokeAttrData, ICornerRadiusAttrData, IEffectAttrData, ILeaf$1 {
    __: IUIData;
    readonly app: ILeafer;
    leafer?: ILeafer;
    parent?: IGroup;
    zoomLayer?: IGroup;
    readonly isFrame?: boolean;
    isOverflow?: boolean;
    proxyData?: IUIInputData;
    __proxyData?: IUIInputData;
    animation?: IAnimation;
    animationOut?: IAnimation;
    editConfig?: IEditorConfig;
    editOuter: string;
    editInner: string;
    children?: IUI[];
    __animate?: IAnimate;
    readonly pen: IPathCreator;
    reset(data?: IUIInputData): void;
    set(data: IUIInputData, isTemp?: boolean): void;
    toJSON(options?: IJSONOptions): IUIJSONData;
    get(name?: string | string[] | IUIInputData): IUIInputData | IValue;
    createProxyData(): IUIInputData;
    find(condition: number | string | IFindCondition | IFindUIMethod, options?: any): IUI[];
    findTag(tag: string | string[]): IUI[];
    findOne(condition: number | string | IFindCondition | IFindUIMethod, options?: any): IUI | undefined;
    findId(id: number | string): IUI | undefined;
    getPath(curve?: boolean, pathForRender?: boolean): IPathCommandData;
    getPathString(curve?: boolean, pathForRender?: boolean): IPathString;
    load(): void;
    __drawPathByData(drawer: IPathDrawer, data: IPathCommandData): void;
    __drawPathByBox(drawer: IPathDrawer): void;
    __drawAfterFill?(canvas: ILeaferCanvas, options: IRenderOptions): void;
    __drawContent?(canvas: ILeaferCanvas, options: IRenderOptions): void;
    animate(keyframe?: IUIInputData | IKeyframe[] | IAnimation, options?: ITransition, type?: IAnimateType, isTemp?: boolean): IAnimate;
    killAnimate(type?: IAnimateType): void;
    export(filename: string, options?: IExportOptions | number | boolean): Promise<IExportResult>;
    clone(data?: IUIInputData): IUI;
}
interface IStateStyle extends IUIInputData {
}
interface IStates {
    [name: string]: IStateStyle;
}
type IStateName = string;
interface IUIAttrData {
    animation?: IAnimation;
    animationOut?: IAnimation;
    transition?: ITransition;
    transitionOut?: ITransition;
    states?: IStates;
    state?: IStateName;
    hoverStyle?: IStateStyle;
    pressStyle?: IStateStyle;
    focusStyle?: IStateStyle;
    selectedStyle?: IStateStyle;
    disabledStyle?: IStateStyle;
}
interface IFindUIMethod {
    (leaf: IUI, options?: any): IAnswer;
}
interface IUIData extends IUIAttrData, IUIComputedData, ILeafData {
    readonly scale: number | IPointData;
    __isFills?: boolean;
    __isStrokes?: boolean;
    readonly __strokeWidth: number;
    readonly __hasStroke: boolean;
    __pixelFill?: boolean;
    __pixelStroke?: boolean;
    __isHitPixel?: boolean;
    __isCanvas?: boolean;
    __opacityFill?: boolean;
    __opacityStroke?: boolean;
    __drawAfterFill?: boolean;
    readonly __clipAfterFill?: boolean;
    __isOverflow?: boolean;
    __blendLayer?: boolean;
    __boxStroke?: boolean;
    __font?: string;
    __textDrawData?: ITextDrawData;
    __needComputePaint?: boolean;
    __computePaint(): void;
}
interface IUIComputedData extends IUIAttrData, IFillComputedData, IBorderComputedData, IStrokeComputedData, ITextStyleComputedData, ICornerRadiusComputedData, IEffectComputedData, ILeafComputedData {
}
interface IUIBaseInputData extends IUIAttrData, IFillInputData, IStrokeInputData, ITextStyleInputData, ICornerRadiusInputData, IEffectInputData, ILeafInputData {
    children?: IUIInputData[];
}
type IUITag = 'App' | 'Leafer' | 'Rect' | 'Ellipse' | 'Polygon' | 'Star' | 'Line' | 'Path' | 'Pen' | 'Text' | 'Image' | 'Canvas' | 'Group' | 'Frame' | 'Box' | 'Arrow' | 'Robot' | 'GIF' | 'Video';
interface IUIInputData extends IRectInputData, IEllipseInputData, IPolygonInputData, IStarInputData, ILineInputData, IPathInputData, ITextInputData, IImageInputData, IGroupInputData, IFrameInputData, IArrowInputData, IGIFInputData, IVideoInputData, IRobotInputData, IUIBaseInputData, IObject {
    children?: IUIInputData[];
}
interface IUIJSONData extends IUIInputData {
    matrix?: IMatrixData;
}

interface ILeafer extends IGroup, ILeaferAttrData, IControl {
    readonly isApp: boolean;
    readonly app: ILeafer;
    parent?: IApp;
    zoomLayer: IGroup;
    editor: IEditorBase;
    ground?: ILeafer;
    tree?: ILeafer;
    sky?: ILeafer;
    userConfig?: ILeaferConfig;
    onInit(): void;
    initType(type: ILeaferType): void;
    destroy(sync?: boolean): void;
}

interface IApp extends ILeafer {
    children: ILeafer[];
    realCanvas: boolean;
}
interface IAppConfig extends ILeaferConfig {
    ground?: ILeaferConfig;
    tree?: ILeaferConfig;
    sky?: ILeaferConfig;
    editor?: IEditorConfig;
}

type IUIRenderModule = IUIRender & ThisType<IUI>;
interface IUIRender extends ILeafRender {
    __drawAfterFill?(canvas: ILeaferCanvas, options: IRenderOptions): void;
    __drawContent?(canvas: ILeaferCanvas, options: IRenderOptions): void;
}
type IRectRenderModule = IRectRender & ThisType<IRect>;
interface IRectRender extends IUIRender {
}
type IImageRenderModule = IImageRender & ThisType<IImage>;
interface IImageRender extends IUIRender {
}
type ITextRenderModule = ITextRender & ThisType<IText>;
interface ITextRender extends IUIRender {
}
type IGroupRenderModule = IGroupRender & ThisType<IGroup>;
interface IGroupRender extends IUIRender {
}
type IFrameRenderModule = IFrameRender & ThisType<IFrame>;
interface IFrameRender extends IGroupRender {
}

type IUIBoundsModule = IUIBounds & ThisType<IUI>;
interface IUIBounds extends ILeafBounds {
}

type IUIHitModule = ILeafHit & ThisType<IUI>;

interface IPathArrowModule {
    list: IPathDataArrowMap;
    addArrows(ui: IUI, changeRenderPath?: boolean): void;
}

interface ITransitionModule {
    list: ITransitionMap;
    register(attrName: string, fn: ITransitionFunction): void;
    get(attrName: string): ITransitionFunction;
    value(from: any, to: any, t: number, target?: IObject): any;
    number(from: number, to: number, t: number, roundValue?: number): number;
    color(from: IColor, to: IColor, t: number): string;
    gradient(from: IGradientPaint, to: IGradientPaint, t: number, target: IObject): IGradientPaint;
}
interface ITransitionMap {
    [name: string]: ITransitionFunction;
}
interface ITransitionFunction {
    (from: any, to: any, t: number, target?: any): any;
}

interface ITextConvertModule {
    getDrawData(content: string, style: ITextData): ITextDrawData;
}

interface IColorConvertModule {
    string(color: IColor, opacity?: number): string;
    object(color: IColor, opacity?: number): IRGBA;
}

interface IExportModule {
    running?: boolean;
    export(leaf: ILeaf$1, filename: IExportFileType | string, options?: IExportOptions | number | boolean): Promise<IExportResult>;
}

interface IStateModule {
    canAnimate: boolean;
    animateExcludes: IObject$1;
    isState(state: IStateName$1, leaf: ILeaf, button?: ILeaf | boolean): boolean;
    isSelected(leaf: ILeaf, button?: ILeaf | boolean): boolean;
    isDisabled(leaf: ILeaf, button?: ILeaf | boolean): boolean;
    isFocus(leaf: ILeaf, button?: ILeaf | boolean): boolean;
    isHover(leaf: ILeaf, button?: ILeaf | boolean): boolean;
    isPress(leaf: ILeaf, button?: ILeaf | boolean): boolean;
    isDrag(leaf: ILeaf, button?: boolean | ILeaf): boolean;
    setStyleName(leaf: ILeaf, styleName: IString$1, value: IBoolean$1): void;
    set(leaf: ILeaf, stateName: IString$1): void;
    getStyle(leaf: ILeaf): IStateStyle$1;
    updateStyle(leaf: ILeaf, style?: IStateStyle$1, type?: 'in' | 'out'): void;
    updateEventStyle(leaf: ILeaf, eventType: string): void;
}

interface ICachedShape extends ICachedLeaf {
    worldCanvas?: ILeaferCanvas;
    shapeBounds: IBoundsData$1;
    scaleX: number;
    scaleY: number;
}

interface IPaintModule {
    compute(attrName: IPaintAttr, ui: IUI): void;
    fill(fill: string, ui: IUI, canvas: ILeaferCanvas): void;
    fills(fills: ILeafPaint[], ui: IUI, canvas: ILeaferCanvas): void;
    fillText(ui: IUI, canvas: ILeaferCanvas): void;
    stroke(stroke: string, ui: IUI, canvas: ILeaferCanvas): void;
    strokes(strokes: ILeafPaint[], ui: IUI, canvas: ILeaferCanvas): void;
    strokeText(stroke: string | ILeafPaint[], ui: IUI, canvas: ILeaferCanvas): void;
    drawTextStroke(ui: IUI, canvas: ILeaferCanvas): void;
    shape(ui: IUI, current: ILeaferCanvas, renderOptions: IRenderOptions): ICachedShape;
}
interface IPaintImageModule {
    image(ui: IUI, attrName: string, paint: IImagePaint, boxBounds: IBoundsData$1, firstUse: boolean): ILeafPaint;
    checkImage(ui: IUI, canvas: ILeaferCanvas, paint: ILeafPaint, allowPaint?: boolean): boolean;
    createPattern(ui: IUI, paint: ILeafPaint, pixelRatio: number): boolean;
    recycleImage(attrName: IPaintAttr, data: IUIData): IBooleanMap;
    createData(leafPaint: ILeafPaint, image: ILeaferImage, paint: IImagePaint, box: IBoundsData$1): void;
    getPatternData(paint: IImagePaint, box: IBoundsData$1, image: ILeaferImage): ILeafPaintPatternData;
    fillOrFitMode(data: ILeafPaintPatternData, box: IBoundsData$1, x: number, y: number, scaleX: number, scaleY: number, rotation: number): void;
    clipMode(data: ILeafPaintPatternData, box: IBoundsData$1, x: number, y: number, scaleX: number, scaleY: number, rotation: number): void;
    repeatMode(data: ILeafPaintPatternData, box: IBoundsData$1, width: number, height: number, x: number, y: number, scaleX: number, scaleY: number, rotation: number, around: IAround): void;
}
interface IPaintGradientModule {
    linearGradient(paint: IGradientPaint, box: IBoundsData$1): ILeafPaint;
    radialGradient(paint: IGradientPaint, box: IBoundsData$1): ILeafPaint;
    conicGradient(paint: IGradientPaint, box: IBoundsData$1): ILeafPaint;
    getTransform(box: IBoundsData$1, from: IPointData, to: IPointData, stretch: number, rotate90: boolean): IMatrixData;
}

interface IEffectModule {
    shadow(ui: IUI, current: ILeaferCanvas, shape: ICachedShape): void;
    innerShadow(ui: IUI, current: ILeaferCanvas, shape: ICachedShape): void;
    blur(ui: IUI, current: ILeaferCanvas, origin: ILeaferCanvas): void;
    backgroundBlur(ui: IUI, current: ILeaferCanvas, shape: ICachedShape): void;
}

export type { IAnimate, IAnimateEasing, IAnimateEasingFunction, IAnimateEasingName, IAnimateEnding, IAnimateEventFunction, IAnimateEvents, IAnimateKeyframe, IAnimateOptions, IAnimateType, IAnimation, IApp, IAppConfig, IAppData, IAppInputData, IArrow, IArrowData, IArrowInputData, IArrowType, IBlurEffect, IBox, IBoxData, IBoxInputData, ICachedShape, ICanvas, ICanvasData, ICanvasInputData, IColor, IColorConvertModule, IColorStop, IColorString, IComputedKeyframe, ICornerRadiusString, ICubicBezierEasing, ICustomEasingFunction, IDashPatternString, IEditBoxBase, IEditPoint, IEditPointInputData, IEditPointType, IEditToolFunction, IEditorBase, IEditorConfig, IEditorConfigFunction, IEffect, IEffectAttrData, IEffectComputedData, IEffectInputData, IEffectModule, IEllipse, IEllipseData, IEllipseInputData, IExportModule, IFill, IFindUIMethod, IFlow, IFlowData, IFlowInputData, IFontWeight, IFontWeightNumer, IFontWeightString, IFrame, IFrameData, IFrameInputData, IFrameRenderModule, IGIF, IGIFData, IGIFInputData, IGradientPaint, IGradientType, IGrayscaleEffect, IGroup, IGroupData, IGroupInputData, IGroupRenderModule, IImage, IImageData, IImageFilters, IImageInputData, IImagePaint, IImagePaintMode, IImageRenderModule, IKeyframe, IKeyframeId, IKeyframesAnimation, ILeafFill, ILeafPaint, ILeafPaintColor, ILeafPaintPatternData, ILeafShadowEffect, ILeafStrokePaint, ILeafer, ILeaferData, ILeaferInputData, ILine, ILineData, ILineInputData, IOverflow, IPaint, IPaintAttr, IPaintBase, IPaintGradientModule, IPaintImageModule, IPaintModule, IPaintString, IPaintType, IPath, IPathArrowModule, IPathData, IPathDataArrow, IPathDataArrowMap, IPathDataArrowOffset, IPathInputData, IPen, IPenData, IPenInputData, IPercent, IPolygon, IPolygonData, IPolygonInputData, IRGB, IRGBA, IRect, IRectData, IRectInputData, IRectRenderModule, IRepeat, IRobot, IRobotActionName, IRobotActions, IRobotAnimation, IRobotComputedKeyframe, IRobotData, IRobotInputData, IRobotKeyframe, IShadowEffect, IShadowString, ISolidPaint, IStar, IStarData, IStarInputData, IStateModule, IStateName, IStateStyle, IStates, IStepsEasing, IStroke, IStrokeAlign, IStrokeAttrData, IStrokeCap, IStrokeComputedData, IStrokeInputData, IStrokeJoin, IStrokeWidthString, IStyleAnimation, IText, ITextAlign, ITextCase, ITextCharData, ITextConvertModule, ITextData, ITextDecoration, ITextDrawData, ITextInputData, ITextRenderModule, ITextRowData, ITextStyleAttrData, ITextStyleComputedData, ITextStyleInputData, ITextWordData, ITextWrap, ITransition, ITransitionFunction, ITransitionMap, ITransitionModule, IUI, IUIBaseInputData, IUIBoundsModule, IUIData, IUIHitModule, IUIInputData, IUIJSONData, IUIRenderModule, IUITag, IVectorPath, IVerticalAlign, IVideo, IVideoData, IVideoInputData };
