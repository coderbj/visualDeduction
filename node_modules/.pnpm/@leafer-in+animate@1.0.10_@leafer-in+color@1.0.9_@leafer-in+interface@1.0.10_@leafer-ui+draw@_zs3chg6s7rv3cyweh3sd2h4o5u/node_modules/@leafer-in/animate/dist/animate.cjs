'use strict';

var draw = require('@leafer-ui/draw');

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol */


function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

const { cos, sin, pow, sqrt, abs, ceil, floor, round: round$2, PI } = Math;
const PIx5 = PI * 5;
const n1$1 = 1.70158;
const n2$1 = 1.70158 * 1.525;
const n3$1 = 7.5625;
const n4$1 = 2.75;
function powIn(count) {
    return (t) => pow(t, count);
}
function powOut(count) {
    return (t) => 1 - pow(1 - t, count);
}
function powInOut(count) {
    return (t) => t < 0.5 ? pow(t * 2, count) * 0.5 : 1 - pow(2 - t * 2, count) * 0.5;
}
function bounceOut(t) {
    if (t < 1 / n4$1)
        return n3$1 * t * t;
    else if (t < 2 / n4$1)
        return n3$1 * (t -= 1.5 / n4$1) * t + 0.75;
    else if (t < 2.5 / n4$1)
        return n3$1 * (t -= 2.25 / n4$1) * t + 0.9375;
    else
        return n3$1 * (t -= 2.625 / n4$1) * t + 0.984375;
}
function cubicBezier(x1, y1, x2, y2) {
    const cache = {};
    return (t) => {
        const key = ~~(t * 10000), c = cache[key];
        if (c)
            return c;
        let o, dx, x, v = t;
        for (let i = 0; i < 8; i++) {
            o = 1 - v;
            x = bezier(v, x1, x2) - t;
            dx = 3 * o * o * x1 + 6 * o * v * (x2 - x1) + 3 * v * v * (1 - x2);
            if (abs(dx) < 1e-6)
                break;
            v -= x / dx;
        }
        return cache[key] = bezier(v, y1, y2);
    };
}
function bezier(t, v1, v2) {
    const o = 1 - t;
    return 3 * o * o * t * v1 + 3 * o * t * t * v2 + t * t * t;
}
function steps(steps, intStep = 'floor') {
    return (t) => (intStep === 'floor' ? floor(t * steps) : (intStep === 'ceil' ? ceil(t * steps) : round$2(t * steps))) / steps;
}
const AnimateEasing = {
    get(easing) {
        const { list } = AnimateEasing;
        if (typeof easing === 'string')
            return list[easing || 'ease'];
        else if (typeof easing === 'object')
            return list[easing.name].apply(list, easing.value instanceof Array ? easing.value : [easing.value]);
        else
            return list['ease'];
    },
    register(name, value) {
        AnimateEasing.list[name] = value;
    },
    list: {
        'linear': (t) => t,
        'ease': cubicBezier(0.25, 0.1, 0.25, 1),
        'ease-in': cubicBezier(0.42, 0, 1, 1),
        'ease-out': cubicBezier(0, 0, 0.58, 1),
        'ease-in-out': cubicBezier(0.42, 0, 0.58, 1),
        'sine-in': (t) => 1 - cos((t * PI) * 0.5),
        'sine-out': (t) => sin((t * PI) * 0.5),
        'sine-in-out': (t) => (1 - cos(t * PI)) * 0.5,
        'quad-in': powIn(2),
        'quad-out': powOut(2),
        'quad-in-out': powInOut(2),
        'cubic-in': powIn(3),
        'cubic-out': powOut(3),
        'cubic-in-out': powInOut(3),
        'quart-in': powIn(4),
        'quart-out': powOut(4),
        'quart-in-out': powInOut(4),
        'quint-in': powIn(5),
        'quint-out': powOut(5),
        'quint-in-out': powInOut(5),
        'expo-in': (t) => t ? pow(2, t * 10 - 10) : 0,
        'expo-out': (t) => t === 1 ? 1 : 1 - pow(2, -t * 10),
        'expo-in-out': (t) => (t === 0 || t === 1) ? t : (t < 0.5 ? pow(2, t * 2 * 10 - 10) * 0.5 : (2 - pow(2, 10 - t * 2 * 10)) * 0.5),
        'circ-in': (t) => 1 - sqrt(1 - pow(t, 2)),
        'circ-out': (t) => sqrt(1 - pow(t - 1, 2)),
        'circ-in-out': (t) => t < 0.5 ? (1 - sqrt(1 - pow(t * 2, 2))) * 0.5 : (sqrt(1 - pow(2 - t * 2, 2)) + 1) * 0.5,
        'back-in': (t) => ((n1$1 + 1) * t - n1$1) * t * t,
        'back-out': (t) => (t -= 1) * t * ((n1$1 + 1) * t + n1$1) + 1,
        'back-in-out': (t) => t < 0.5 ? ((t *= 2) * t * ((n2$1 + 1) * t - n2$1)) * 0.5 : ((t = t * 2 - 2) * t * ((n2$1 + 1) * t + n2$1) + 2) * 0.5,
        'elastic-in': (t) => (t === 0 || t === 1) ? t : -pow(2, (t - 1) * 10) * sin((t - 1.1) * PIx5),
        'elastic-out': (t) => (t === 0 || t === 1) ? t : pow(2, -10 * t) * sin((t - 0.1) * PIx5) + 1,
        'elastic-in-out': (t) => (t === 0 || t === 1) ? t : (t < 0.5 ? -pow(2, ((t *= 2) - 1) * 10) * sin((t - 1.1) * PIx5) * 0.5 : pow(2, (1 - (t *= 2)) * 10) * sin((t - 1.1) * PIx5) * 0.5 + 1),
        'bounce-in': (t) => 1 - bounceOut(1 - t),
        'bounce-out': bounceOut,
        'bounce-in-out': (t) => t < 0.5 ? (1 - bounceOut(1 - t * 2)) * 0.5 : (1 + bounceOut(t * 2 - 1)) * 0.5,
        'cubic-bezier': cubicBezier,
        steps
    }
};

function animationType(defaultValue) {
    return draw.decorateLeafAttr(defaultValue, (key) => draw.attr({
        set(value) {
            this.__setAttr(key, value);
            if (this.leafer)
                value ? this.animate(value, undefined, 'animation') : this.killAnimate('animation');
        }
    }));
}
function animateAttr(defaultValue) {
    return (target, key) => {
        Object.defineProperty(target, key, {
            get() {
                const value = this.config && this.config[key];
                return value === undefined ? defaultValue : value;
            },
            set(value) {
                if (!this.config)
                    this.config = {};
                this.config[key] = value;
            }
        });
    };
}

class AnimateEvent {
}
AnimateEvent.CREATED = 'created';
AnimateEvent.PLAY = 'play';
AnimateEvent.PAUSE = 'pause';
AnimateEvent.STOP = 'stop';
AnimateEvent.SEEK = 'seek';
AnimateEvent.UPDATE = 'update';
AnimateEvent.COMPLETED = 'completed';

const frameDuration = 0.2;
exports.Animate = class Animate extends draw.Eventer {
    get endingStyle() { return this.realEnding === 'from' ? this.fromStyle : this.toStyle; }
    get started() { return !!this.requestAnimateTime; }
    get completed() { return this.time >= this.duration && !this.started; }
    get frame() { return this.frames[this.nowIndex]; }
    get frameTotalTime() { return this.frame.totalTime || this.frame.duration || 0; }
    get realEnding() {
        let count;
        const { ending, reverse, loop } = this;
        if (ending === 'from')
            count = 0;
        else if (ending === 'to')
            count = 1;
        else {
            count = reverse ? 0 : 1;
            if (loop && typeof loop === 'number')
                count += loop - 1;
        }
        return count % 2 ? 'to' : 'from';
    }
    constructor(target, keyframe, options, isTemp) {
        super();
        this.init(target, keyframe, options, isTemp);
    }
    init(target, keyframe, options, isTemp) {
        this.target = target;
        if (isTemp || this.isTemp)
            this.isTemp = isTemp;
        switch (typeof options) {
            case 'number':
                this.config = { duration: options };
                break;
            case 'string':
                this.config = { easing: options };
                break;
            case 'object': this.config = options, options.event && (this.event = options.event);
        }
        if (!keyframe)
            return;
        this.keyframes = keyframe instanceof Array ? keyframe : [keyframe];
        const { easing, attrs } = this;
        this.easingFn = AnimateEasing.get(easing);
        if (attrs || this.attrsMap)
            this.attrsMap = attrs ? attrs.reduce((map, value) => { map[value] = true; return map; }, {}) : undefined;
        this.frames = [];
        this.create();
        if (this.autoplay)
            this.timer = setTimeout(() => {
                this.timer = 0;
                this.play();
            }, 0);
    }
    play() {
        if (this.destroyed)
            return;
        this.running = true;
        if (!this.started)
            this.clearTimer(), this.start();
        else if (!this.timer)
            this.requestAnimate();
        this.emit(AnimateEvent.PLAY, this);
    }
    pause() {
        if (this.destroyed)
            return;
        this.running = false;
        this.clearTimer();
        this.emit(AnimateEvent.PAUSE, this);
    }
    stop() {
        if (this.destroyed)
            return;
        this.end();
        this.complete();
        this.emit(AnimateEvent.STOP, this);
    }
    seek(time) {
        if (this.destroyed)
            return;
        if (typeof time === 'object')
            time = draw.UnitConvert.number(time, this.duration);
        if (time)
            time /= this.speed;
        if (!this.started || time < this.time)
            this.start(true);
        this.time = time;
        this.animate(0, true);
        this.clearTimer(() => this.requestAnimate());
        this.emit(AnimateEvent.SEEK, this);
    }
    kill() {
        this.destroy(true);
    }
    create() {
        const { target, frames, keyframes, config } = this, { length } = keyframes, joinBefore = length > 1 ? this.join : true;
        let addedDuration = 0, totalAutoDuration = 0, before, keyframe, item, style;
        if (length > 1)
            this.fromStyle = {}, this.toStyle = {};
        for (let i = 0; i < length; i++) {
            keyframe = keyframes[i];
            style = keyframe.style || keyframe;
            if (!before)
                before = joinBefore ? target : style;
            item = { style, beforeStyle: {} };
            if (keyframe.style) {
                const { duration, autoDuration, delay, autoDelay, easing } = keyframe;
                if (duration) {
                    item.duration = duration, addedDuration += duration;
                    if (delay)
                        item.totalTime = duration + delay;
                }
                else {
                    if (autoDuration)
                        item.autoDuration = autoDuration, totalAutoDuration += autoDuration;
                }
                if (delay)
                    item.delay = delay, addedDuration += delay;
                else if (autoDelay)
                    item.autoDelay = autoDelay, totalAutoDuration += autoDelay;
                if (easing)
                    item.easingFn = AnimateEasing.get(easing);
            }
            if (!item.autoDuration && item.duration === undefined) {
                if (length > 1)
                    (i > 0 || joinBefore) ? totalAutoDuration++ : item.duration = 0;
                else
                    item.duration = this.duration;
            }
            if (length > 1) {
                this.setBefore(item, style, before);
            }
            else {
                for (let key in style) {
                    item.beforeStyle[key] = target[key];
                }
                this.fromStyle = item.beforeStyle, this.toStyle = item.style;
            }
            before = style;
            frames.push(item);
        }
        if (totalAutoDuration) {
            if (this.duration <= addedDuration || !(config && config.duration))
                this.changeDuration(addedDuration + frameDuration * totalAutoDuration);
            this.allocateTime((this.duration - addedDuration) / totalAutoDuration);
        }
        else {
            if (addedDuration)
                this.changeDuration(addedDuration);
        }
        this.emit(AnimateEvent.CREATED, this);
    }
    changeDuration(duration) {
        const { config } = this;
        this.config = config ? Object.assign(Object.assign({}, config), { duration }) : { duration };
    }
    setBefore(item, data, before) {
        const { fromStyle, toStyle, target } = this;
        for (let key in data) {
            if (fromStyle[key] === undefined)
                fromStyle[key] = toStyle[key] = (data === before) ? before[key] : target[key];
            item.beforeStyle[key] = before[key] === undefined ? toStyle[key] : before[key];
            toStyle[key] = data[key];
        }
    }
    allocateTime(partTime) {
        let { frames } = this, { length } = frames, frame;
        for (let i = 0; i < length; i++) {
            frame = frames[i];
            if (frame.duration === undefined)
                frame.duration = frame.autoDuration ? partTime * frame.autoDuration : partTime;
            if (!frame.totalTime) {
                if (frame.autoDelay)
                    frame.delay = frame.autoDelay * partTime;
                if (frame.delay)
                    frame.totalTime = frame.duration, frame.totalTime += frame.delay;
            }
        }
    }
    requestAnimate() {
        this.requestAnimateTime = Date.now();
        draw.Platform.requestRender(this.animate.bind(this));
    }
    animate(_runtime, seek) {
        if (!seek) {
            if (!this.running)
                return;
            this.time += (Date.now() - this.requestAnimateTime) / 1000;
        }
        const { duration } = this, realTime = this.time * this.speed;
        if (realTime < duration) {
            while (realTime - this.playedTotalTime > this.frameTotalTime) {
                this.transition(1);
                this.nowReverse ? this.reverseNextFrame() : this.nextFrame();
            }
            const itemDelay = this.nowReverse ? 0 : (this.frame.delay || 0);
            const itemPlayedTime = realTime - this.playedTotalTime - itemDelay;
            const frameDuration = this.frame.duration;
            if (itemPlayedTime > frameDuration) {
                this.transition(1);
            }
            else if (itemPlayedTime >= 0) {
                const t = frameDuration ? itemPlayedTime / frameDuration : 1;
                this.transition(this.frame.easingFn ? this.frame.easingFn(t) : this.easingFn(t));
            }
        }
        else {
            this.end();
        }
        if (!seek) {
            if (realTime < duration) {
                this.requestAnimate();
            }
            else {
                const { loop, loopDelay, swing } = this;
                if (loop !== false || swing) {
                    this.looped ? this.looped++ : this.looped = 1;
                    if (!(typeof loop === 'number' && (!loop || this.looped >= loop))) {
                        if (swing)
                            this.nowReverse = !this.nowReverse;
                        if (loopDelay)
                            this.timer = setTimeout(() => { this.timer = 0, this.begin(); }, loopDelay / this.speed * 1000);
                        else
                            this.begin();
                        return;
                    }
                }
                this.complete();
            }
        }
    }
    start(seek) {
        this.requestAnimateTime = 1;
        const { reverse } = this;
        if (reverse || this.nowReverse)
            this.nowReverse = reverse;
        if (this.looped)
            this.looped = 0;
        if (seek)
            this.begin(true);
        else {
            const { delay } = this;
            if (delay)
                this.timer = setTimeout(() => {
                    this.timer = 0;
                    this.begin();
                }, delay / this.speed * 1000);
            else
                this.begin();
        }
    }
    begin(seek) {
        this.playedTotalTime = this.time = 0;
        this.nowReverse ? this.setTo() : this.setFrom();
        if (!seek)
            this.requestAnimate();
    }
    end() {
        this.nowReverse ? this.setFrom() : this.setTo();
    }
    complete() {
        this.requestAnimateTime = 0;
        this.running = false;
        const { realEnding } = this;
        if (realEnding === 'from')
            this.setFrom();
        else if (realEnding === 'to')
            this.setTo();
        this.clearTimer();
        this.emit(AnimateEvent.COMPLETED, this);
    }
    setFrom() {
        this.nowIndex = 0;
        this.setStyle(this.fromStyle);
    }
    setTo() {
        this.nowIndex = this.frames.length - 1;
        this.setStyle(this.toStyle);
    }
    nextFrame() {
        if (this.nowIndex + 1 >= this.frames.length)
            return;
        this.playedTotalTime += this.frameTotalTime;
        this.nowIndex++;
    }
    reverseNextFrame() {
        if (this.nowIndex - 1 < 0)
            return;
        this.playedTotalTime += this.frameTotalTime;
        this.nowIndex--;
    }
    transition(t) {
        const { style, beforeStyle } = this.frame;
        const fromStyle = this.nowReverse ? style : beforeStyle;
        const toStyle = this.nowReverse ? beforeStyle : style;
        if (t === 0) {
            this.setStyle(fromStyle);
        }
        else if (t === 1) {
            this.setStyle(toStyle);
        }
        else {
            const { attrsMap, target } = this;
            let from, to, transitionAttr, { betweenStyle } = this.frame;
            if (!betweenStyle)
                betweenStyle = this.frame.betweenStyle = {};
            for (let key in style) {
                if (attrsMap && !attrsMap[key])
                    continue;
                from = fromStyle[key], to = toStyle[key], transitionAttr = draw.Transition.list[key] || draw.Transition.value;
                if (from !== to)
                    betweenStyle[key] = transitionAttr(from, to, t, target);
            }
            this.setStyle(betweenStyle);
        }
        this.emit(AnimateEvent.UPDATE, this);
    }
    setStyle(style) {
        this.target.set(style, this.isTemp);
    }
    clearTimer(fn) {
        if (this.timer) {
            clearTimeout(this.timer), this.timer = 0;
            if (fn)
                fn();
        }
    }
    destroy(complete) {
        if (!this.destroyed) {
            super.destroy();
            if (complete && !this.completed)
                this.stop();
            else
                this.pause();
            this.target = this.config = this.frames = null;
            this.destroyed = true;
        }
    }
};
__decorate([
    animateAttr('ease')
], exports.Animate.prototype, "easing", void 0);
__decorate([
    animateAttr(0)
], exports.Animate.prototype, "delay", void 0);
__decorate([
    animateAttr(frameDuration)
], exports.Animate.prototype, "duration", void 0);
__decorate([
    animateAttr('auto')
], exports.Animate.prototype, "ending", void 0);
__decorate([
    animateAttr(false)
], exports.Animate.prototype, "reverse", void 0);
__decorate([
    animateAttr(false)
], exports.Animate.prototype, "swing", void 0);
__decorate([
    animateAttr(false)
], exports.Animate.prototype, "loop", void 0);
__decorate([
    animateAttr(0)
], exports.Animate.prototype, "loopDelay", void 0);
__decorate([
    animateAttr(1)
], exports.Animate.prototype, "speed", void 0);
__decorate([
    animateAttr(true)
], exports.Animate.prototype, "autoplay", void 0);
__decorate([
    animateAttr()
], exports.Animate.prototype, "join", void 0);
__decorate([
    animateAttr()
], exports.Animate.prototype, "attrs", void 0);
exports.Animate = __decorate([
    draw.useModule(draw.LeafEventer)
], exports.Animate);

const colorNames = {
    transparent: 'FFF0',
    aliceblue: 'F0F8FF',
    antiquewhite: 'FAEBD7',
    aqua: '0FF',
    aquamarine: '7FFFD4',
    azure: 'F0FFFF',
    beige: 'F5F5DC',
    bisque: 'FFE4C4',
    black: '0',
    blanchedalmond: 'FFEBCD',
    blue: '00F',
    blueviolet: '8A2BE2',
    brown: 'A52A2A',
    burlywood: 'DEB887',
    cadetblue: '5F9EA0',
    chartreuse: '7FFF00',
    chocolate: 'D2691E',
    coral: 'FF7F50',
    cornflowerblue: '6495ED',
    cornsilk: 'FFF8DC',
    crimson: 'DC143C',
    cyan: '0FF',
    darkblue: '00008B',
    darkcyan: '008B8B',
    darkgoldenrod: 'B8860B',
    darkgray: 'A9',
    darkgreen: '006400',
    darkgrey: 'A9',
    darkkhaki: 'BDB76B',
    darkmagenta: '8B008B',
    darkolivegreen: '556B2F',
    darkorange: 'FF8C00',
    darkorchid: '9932CC',
    darkred: '8B0000',
    darksalmon: 'E9967A',
    darkseagreen: '8FBC8F',
    darkslateblue: '483D8B',
    darkslategray: '2F4F4F',
    darkslategrey: '2F4F4F',
    darkturquoise: '00CED1',
    darkviolet: '9400D3',
    deeppink: 'FF1493',
    deepskyblue: '00BFFF',
    dimgray: '69',
    dimgrey: '69',
    dodgerblue: '1E90FF',
    firebrick: 'B22222',
    floralwhite: 'FFFAF0',
    forestgreen: '228B22',
    fuchsia: 'F0F',
    gainsboro: 'DC',
    ghostwhite: 'F8F8FF',
    gold: 'FFD700',
    goldenrod: 'DAA520',
    gray: '80',
    green: '008000',
    greenyellow: 'ADFF2F',
    grey: '80',
    honeydew: 'F0FFF0',
    hotpink: 'FF69B4',
    indianred: 'CD5C5C',
    indigo: '4B0082',
    ivory: 'FFFFF0',
    khaki: 'F0E68C',
    lavender: 'E6E6FA',
    lavenderblush: 'FFF0F5',
    lawngreen: '7CFC00',
    lemonchiffon: 'FFFACD',
    lightblue: 'ADD8E6',
    lightcoral: 'F08080',
    lightcyan: 'E0FFFF',
    lightgoldenrodyellow: 'FAFAD2',
    lightgray: 'D3',
    lightgreen: '90EE90',
    lightgrey: 'D3',
    lightpink: 'FFB6C1',
    lightsalmon: 'FFA07A',
    lightseagreen: '20B2AA',
    lightskyblue: '87CEFA',
    lightslategray: '789',
    lightslategrey: '789',
    lightsteelblue: 'B0C4DE',
    lightyellow: 'FFFFE0',
    lime: '00FF00',
    limegreen: '32CD32',
    linen: 'FAF0E6',
    magenta: 'FF00FF',
    maroon: '800000',
    mediumaquamarine: '66CDAA',
    mediumblue: '0000CD',
    mediumorchid: 'BA55D3',
    mediumpurple: '9370DB',
    mediumseagreen: '3CB371',
    mediumslateblue: '7B68EE',
    mediumspringgreen: '00FA9A',
    mediumturquoise: '48D1CC',
    mediumvioletred: 'C71585',
    midnightblue: '191970',
    mintcream: 'F5FFFA',
    mistyrose: 'FFE4E1',
    moccasin: 'FFE4B5',
    navajowhite: 'FFDEAD',
    navy: '000080',
    oldlace: 'FDF5E6',
    olive: '808000',
    olivedrab: '6B8E23',
    orange: 'FFA500',
    orangered: 'FF4500',
    orchid: 'DA70D6',
    palegoldenrod: 'EEE8AA',
    palegreen: '98FB98',
    paleturquoise: 'AFEEEE',
    palevioletred: 'D87093',
    papayawhip: 'FFEFD5',
    peachpuff: 'FFDAB9',
    peru: 'CD853F',
    pink: 'FFC0CB',
    plum: 'DDA0DD',
    powderblue: 'B0E0E6',
    purple: '800080',
    rebeccapurple: '639',
    red: 'F00',
    rosybrown: 'BC8F8F',
    royalblue: '4169E1',
    saddlebrown: '8B4513',
    salmon: 'FA8072',
    sandybrown: 'F4A460',
    seagreen: '2E8B57',
    seashell: 'FFF5EE',
    sienna: 'A0522D',
    silver: 'C0',
    skyblue: '87CEEB',
    slateblue: '6A5ACD',
    slategray: '708090',
    slategrey: '708090',
    snow: 'FFFAFA',
    springgreen: '00FF7F',
    steelblue: '4682B4',
    tan: 'D2B48C',
    teal: '008080',
    thistle: 'D8BFD8',
    tomato: 'FF6347',
    turquoise: '40E0D0',
    violet: 'EE82EE',
    wheat: 'F5DEB3',
    white: 'F',
    whitesmoke: 'F5',
    yellow: 'FF0',
    yellowgreen: '9ACD32'
};

const rgbMatch = /^rgb\((\d+),\s*(\d+),\s*(\d+)/i;
const rgbaMatch = /^rgba\((\d+),\s*(\d+),\s*(\d+),\s*(\d*\.?\d+)/i;
const hslMatch = /^hsl\((\d+),\s*(\d+)%\s*,\s*(\d+)%/i;
const hslaMatch = /^hsla\((\d+),\s*(\d+)%\s*,\s*(\d+)%\s*,\s*(\d*\.?\d+)/i;
const int = parseInt, float = parseFloat, { round: round$1 } = Math;
let cache = {}, totalCache = 0;
function colorToRGBA(color, opacity) {
    let RGBA;
    let useOpacity = opacity !== undefined && opacity !== 1;
    if (typeof color === 'string') {
        const cacheColor = cache[color];
        if (cacheColor) {
            RGBA = Object.assign({}, cacheColor);
        }
        else {
            switch (color[0]) {
                case '#':
                    RGBA = hexToRGBA(color);
                    break;
                case 'R':
                case 'r':
                    if (color[4] === '(' && rgbaMatch.test(color))
                        RGBA = rgbaToRGBA(color);
                    else if (color[3] === '(' && rgbMatch.test(color))
                        RGBA = rgbToRGBA(color);
                    break;
                case 'H':
                case 'h':
                    if (color[4] === '(' && hslaMatch.test(color))
                        RGBA = hslaToRGBA(color);
                    else if (color[3] === '(' && hslMatch.test(color))
                        RGBA = hslToRGBA(color);
                    break;
            }
            if (!RGBA) {
                const value = colorNames[color.toLowerCase()];
                if (value)
                    RGBA = hexToRGBA('#' + value);
            }
            if (RGBA) {
                totalCache++;
                if (totalCache > 10000)
                    cache = {}, totalCache = 0;
                cache[color] = Object.assign({}, RGBA);
            }
        }
    }
    else if (typeof color === 'object') {
        if (color.a === undefined)
            color.a = 1;
        if (useOpacity)
            color = Object.assign({}, color);
        RGBA = color;
    }
    if (!RGBA)
        RGBA = { r: 255, g: 255, b: 255, a: 1 };
    if (useOpacity)
        RGBA.a *= opacity;
    return RGBA;
}
function hexToRGBA(color) {
    let r, g, b, a = 1;
    switch (color.length) {
        case 9:
            r = int(color.slice(1, 3), 16);
            g = int(color.slice(3, 5), 16);
            b = int(color.slice(5, 7), 16);
            a = int(color.slice(7, 9), 16) / 255;
            break;
        case 7:
            r = int(color.slice(1, 3), 16);
            g = int(color.slice(3, 5), 16);
            b = int(color.slice(5, 7), 16);
            break;
        case 5:
            r = int(color[1] + color[1], 16);
            g = int(color[2] + color[2], 16);
            b = int(color[3] + color[3], 16);
            a = int(color[4] + color[4], 16) / 255;
            break;
        case 4:
            r = int(color[1] + color[1], 16);
            g = int(color[2] + color[2], 16);
            b = int(color[3] + color[3], 16);
            break;
        case 3:
            r = g = b = int(color[1] + color[2], 16);
            break;
        case 2:
            r = g = b = int(color[1] + color[1], 16);
            break;
    }
    return { r, g, b, a };
}
function rgbToRGBA(color) {
    const match = rgbMatch.exec(color);
    return {
        r: int(match[1]),
        g: int(match[2]),
        b: int(match[3]),
        a: 1
    };
}
function rgbaToRGBA(color) {
    const match = rgbaMatch.exec(color);
    return {
        r: int(match[1]),
        g: int(match[2]),
        b: int(match[3]),
        a: float(match[4])
    };
}
function hslToRGBA(color) {
    const match = hslMatch.exec(color);
    return hsla(float(match[1]), float(match[2]), float(match[3]), 1);
}
function hslaToRGBA(color) {
    const match = hslaMatch.exec(color);
    return hsla(float(match[1]), float(match[2]), float(match[3]), float(match[4]));
}
const n1 = 1 / 6, n2 = 0.5, n3 = 2 / 3, n4 = 1 / 3;
function hue(p, q, t) {
    if (t < 0)
        t++;
    else if (t > 1)
        t--;
    if (t < n1)
        return p + (q - p) * 6 * t;
    if (t < n2)
        return q;
    if (t < n3)
        return p + (q - p) * (n3 - t) * 6;
    return p;
}
function hsla(h, s, l, a = 1) {
    let r, g, b;
    h /= 360, s /= 100, l /= 100;
    if (s === 0) {
        r = g = b = l;
    }
    else {
        let q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        let p = 2 * l - q;
        r = hue(p, q, h + n4);
        g = hue(p, q, h);
        b = hue(p, q, h - n4);
    }
    return { r: round$1(r * 255), g: round$1(g * 255), b: round$1(b * 255), a };
}

draw.ColorConvert.object = colorToRGBA;

const { round } = Math;
const { fourNumber } = draw.MathHelper;
const TransitionList = {
    fill: paint,
    stroke: paint,
    cornerRadius(from, to, t) {
        if (typeof from === 'number' && typeof to === 'number')
            return number(from, to, t);
        from = fourNumber(from), to = fourNumber(to);
        return from.map((f, i) => number(f, to[i], t));
    },
    shadow,
    innerShadow: shadow
};
const TransitionModule = {
    value,
    number,
    color
};
function value(from, to, t) {
    return (typeof from === 'number' && typeof to === 'number') ? from + (to - from) * t : to;
}
function number(from, to, t, roundValue) {
    from || (from = 0), to || (to = 0);
    const value = from + (to - from) * t;
    return roundValue ? round(value) : value;
}
function color(from, to, t) {
    from = draw.ColorConvert.object(from), to = draw.ColorConvert.object(to);
    const rgb = number(from.r, to.r, t, 1) + ',' + number(from.g, to.g, t, 1) + ',' + number(from.b, to.b, t, 1);
    const a = number(from.a, to.a, t);
    return a === 1 ? 'rgb(' + rgb + ')' : 'rgba(' + rgb + ',' + a + ')';
}
function paint(from, to, t) {
    return (typeof from === 'string' && typeof to === 'string') ? color(from, to, t) : to;
}
function shadow(from, to, t) {
    if (from instanceof Array || to instanceof Array)
        return to;
    from = from || {}, to = to || {};
    return {
        x: number(from.x, to.x, t),
        y: number(from.y, to.y, t),
        blur: number(from.blur, to.blur, t),
        spread: number(from.spread, to.spread, t),
        color: color(from.color || '#FFFFFF00', to.color || '#FFFFFF00', t),
        visible: to.visible,
        blendMode: to.blendMode,
        box: to.box || from.box
    };
}

draw.State.canAnimate = true;
Object.assign(draw.Transition, TransitionModule);
Object.assign(draw.Transition.list, TransitionList);
const ui = draw.UI.prototype;
animationType()(ui, 'animation');
draw.dataType()(ui, 'animationOut');
draw.dataType(true)(ui, 'transition');
draw.dataType()(ui, 'transitionOut');
ui.animate = function (keyframe, options, kill, isTemp) {
    if (keyframe === undefined)
        return this.__animate;
    if (typeof keyframe === 'object') {
        if (keyframe.keyframes)
            options = keyframe, keyframe = keyframe.keyframes;
        else if (keyframe.style)
            options = keyframe, keyframe = keyframe.style;
    }
    this.killAnimate(kill);
    return this.__animate = new exports.Animate(this, keyframe, options, isTemp);
};
ui.killAnimate = function (_type) {
    const animate = this.__animate;
    if (animate)
        animate.kill(), this.__animate = null;
};
ui.__runAnimation = function (type, complete) {
    this.animate(type === 'in' ? this.animation : this.animationOut);
    if (complete)
        this.__animate.on(AnimateEvent.COMPLETED, complete);
};

exports.AnimateEasing = AnimateEasing;
exports.AnimateEvent = AnimateEvent;
