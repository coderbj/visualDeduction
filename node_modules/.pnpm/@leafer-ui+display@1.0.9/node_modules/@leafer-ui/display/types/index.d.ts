import { IString, INumber, IBoolean, IMaskType, IEraserType, IAlign, IUnitPointData, IPathCommandData, IPathCommandObject, IPathString, IWindingRule, IFlowType, IFourNumber, IGap, IPointGap, IFlowAlign, IFlowAxisAlign, IFlowWrap, IFlowBoxType, IAutoSize, IAutoBoxData, IConstraint, IRangeSize, IAxis, IBoundsData, IHitType, ICursorType, IUnitData, IObject, IPointData, IPathCreator, IValue, IFindCondition, ILeaferCanvas, IPathDrawer, IExportFileType, IJSONOptions, IPickOptions, IPickResult, IRenderer, IWatcher, ILayouter, ISelector, IInteraction, ICanvasManager, IHitCanvasManager, ILeaferConfig, IAutoBounds, IBounds, IEventListenerId, ITimer, IControl, ILeaferType, IScreenSizeData, IResizeEvent, IZoomType, IClientPointData, IRenderOptions, ILeaferImage, ICanvasContext2DSettings, ICanvasContext2D } from '@leafer/interface';
import { Leaf, LeafList } from '@leafer/core';
import { IUI, IUIData, IUIInputData, ILeafer, IGroup, IBlendMode, IFill, IStroke, IStrokeAlign, IStrokeWidthString, IStrokeCap, IStrokeJoin, IDashPatternString, IArrowType, ICornerRadiusString, IShadowEffect, IShadowString, IBlurEffect, IGrayscaleEffect, IEffect, IAnimation, ITransition, IStates, IStateName, IAnimate, IEditorConfig, IFindUIMethod, IKeyframe, IAnimateType, IExportOptions, IExportResult, IEditorConfigFunction, IEditToolFunction, IGroupData, IGroupInputData, IUIJSONData, IFindCondition as IFindCondition$1, ILeaferData, IApp, IEditorBase, IFunction, ILeaferInputData, IBox, IBoxData, IOverflow, IBoxInputData, IFrame, IFrameData, IFrameInputData, IRect, IRectData, IRectInputData, IEllipse, IEllipseData, IEllipseInputData, IPolygon, IPolygonData, IPolygonInputData, IStar, IStarData, IStarInputData, ILine, ILineData, ILineInputData, IImage, IImageData, IImageInputData, ICanvas, ICanvasData, ICanvasInputData, IText, ITextData, IHitType as IHitType$1, IFontWeight, ITextCase, ITextDecoration, ITextAlign, IVerticalAlign, ITextWrap, ITextDrawData, ITextInputData, IPath, IPathData, IPathInputData, IPen, IPenData, IPathCommandData as IPathCommandData$1, IPenInputData } from '@leafer-ui/interface';

declare class UI extends Leaf implements IUI {
    __: IUIData;
    proxyData?: IUIInputData;
    __proxyData?: IUIInputData;
    get app(): ILeafer;
    leafer?: ILeafer;
    parent?: IGroup;
    zoomLayer: IGroup;
    get isFrame(): boolean;
    children?: IUI[];
    id?: IString;
    name?: IString;
    className?: IString;
    blendMode?: IBlendMode;
    opacity?: INumber;
    visible?: IBoolean | 0;
    locked?: IBoolean;
    zIndex?: INumber;
    mask?: IBoolean | IMaskType;
    eraser?: IBoolean | IEraserType;
    x?: INumber;
    y?: INumber;
    width?: INumber;
    height?: INumber;
    scaleX?: INumber;
    scaleY?: INumber;
    rotation?: INumber;
    skewX?: INumber;
    skewY?: INumber;
    offsetX?: INumber;
    offsetY?: INumber;
    scrollX?: INumber;
    scrollY?: INumber;
    origin?: IAlign | IUnitPointData;
    around?: IAlign | IUnitPointData;
    lazy?: IBoolean;
    pixelRatio?: INumber;
    path?: IPathCommandData | IPathCommandObject[] | IPathString;
    windingRule?: IWindingRule;
    closed?: boolean;
    flow?: IFlowType;
    padding?: IFourNumber;
    gap?: IGap | IPointGap;
    flowAlign?: IFlowAlign | IFlowAxisAlign;
    flowWrap?: IFlowWrap;
    itemBox?: IFlowBoxType;
    inFlow?: IBoolean;
    autoWidth?: IAutoSize;
    autoHeight?: IAutoSize;
    lockRatio?: IBoolean;
    autoBox?: IAutoBoxData | IConstraint;
    widthRange?: IRangeSize;
    heightRange?: IRangeSize;
    draggable?: IBoolean | IAxis;
    dragBounds?: IBoundsData | 'parent';
    editable?: IBoolean;
    hittable?: IBoolean;
    hitFill?: IHitType;
    hitStroke?: IHitType;
    hitBox?: IBoolean;
    hitChildren?: IBoolean;
    hitSelf?: IBoolean;
    hitRadius?: INumber;
    cursor?: ICursorType | ICursorType[];
    fill?: IFill;
    stroke?: IStroke;
    strokeAlign?: IStrokeAlign;
    strokeWidth?: IFourNumber | IStrokeWidthString;
    strokeWidthFixed?: IBoolean;
    strokeCap?: IStrokeCap;
    strokeJoin?: IStrokeJoin;
    dashPattern?: INumber[] | IDashPatternString;
    dashOffset?: INumber;
    miterLimit?: INumber;
    startArrow?: IArrowType;
    endArrow?: IArrowType;
    cornerRadius?: IFourNumber | ICornerRadiusString;
    cornerSmoothing?: INumber;
    shadow?: IShadowEffect | IShadowEffect[] | IShadowString;
    innerShadow?: IShadowEffect | IShadowEffect[] | IShadowString;
    blur?: INumber | IBlurEffect;
    backgroundBlur?: INumber | IBlurEffect;
    grayscale?: INumber | IGrayscaleEffect;
    filter?: IEffect | IEffect[];
    animation?: IAnimation;
    animationOut?: IAnimation;
    transition?: ITransition;
    transitionOut?: ITransition;
    motionPath?: boolean;
    motion?: INumber | IUnitData;
    motionRotation?: INumber | IBoolean;
    states?: IStates;
    state?: IStateName;
    selected?: IBoolean;
    disabled?: IBoolean;
    normalStyle?: IUIInputData;
    hoverStyle?: IUIInputData;
    pressStyle?: IUIInputData;
    focusStyle?: IUIInputData;
    selectedStyle?: IUIInputData;
    disabledStyle?: IUIInputData;
    button?: IBoolean;
    data: IObject;
    set scale(value: INumber | IPointData);
    get scale(): INumber | IPointData;
    __animate?: IAnimate;
    get pen(): IPathCreator;
    get editConfig(): IEditorConfig;
    get editOuter(): string;
    get editInner(): string;
    constructor(data?: IUIInputData);
    reset(_data?: IUIInputData): void;
    set(data: IUIInputData, isTemp?: boolean): void;
    get(name?: string | string[] | IUIInputData): IUIInputData | IValue;
    createProxyData(): IUIInputData;
    find(_condition: number | string | IFindCondition | IFindUIMethod, _options?: any): IUI[];
    findTag(tag: string | string[]): IUI[];
    findOne(_condition: number | string | IFindCondition | IFindUIMethod, _options?: any): IUI | undefined;
    findId(id: number | string): IUI | undefined;
    getPath(curve?: boolean, pathForRender?: boolean): IPathCommandData;
    getPathString(curve?: boolean, pathForRender?: boolean, floatLength?: number): IPathString;
    load(): void;
    __onUpdateSize(): void;
    __updateRenderPath(): void;
    __drawRenderPath(canvas: ILeaferCanvas): void;
    __drawPath(canvas: ILeaferCanvas): void;
    __drawPathByData(drawer: IPathDrawer, data: IPathCommandData): void;
    __drawPathByBox(drawer: IPathDrawer): void;
    animate(_keyframe?: IUIInputData | IKeyframe[] | IAnimation, _options?: ITransition, _type?: IAnimateType, _isTemp?: boolean): IAnimate;
    killAnimate(_type?: IAnimateType): void;
    export(filename: IExportFileType | string, options?: IExportOptions | number | boolean): Promise<IExportResult>;
    clone(data?: IUIInputData): IUI;
    static one(data: IUIInputData, x?: number, y?: number, width?: number, height?: number): IUI;
    static registerUI(): void;
    static registerData(data: IUIData): void;
    static setEditConfig(_config: IEditorConfig | IEditorConfigFunction): void;
    static setEditOuter(_toolName: string | IEditToolFunction): void;
    static setEditInner(_editorName: string | IEditToolFunction): void;
    destroy(): void;
}

declare class Group extends UI implements IGroup {
    get __tag(): string;
    get isBranch(): boolean;
    __: IGroupData;
    children: IUI[];
    constructor(data?: IGroupInputData);
    reset(data?: IGroupInputData): void;
    __setBranch(): void;
    set(data: IUIInputData, isTemp?: boolean): void;
    toJSON(options?: IJSONOptions): IUIJSONData;
    pick(_hitPoint: IPointData, _options?: IPickOptions): IPickResult;
    addAt(child: IUI | IUI[] | IUIInputData | IUIInputData[], index: number): void;
    addAfter(child: IUI | IUI[] | IUIInputData | IUIInputData[], after: IUI): void;
    addBefore(child: IUI | IUI[] | IUIInputData | IUIInputData[], before: IUI): void;
    add(_child: IUI | IUI[] | IUIInputData | IUIInputData[], _index?: number): void;
    addMany(..._children: IUI[] | IUIInputData[]): void;
    remove(_child?: IUI | number | string | IFindCondition$1 | IFindUIMethod, _destroy?: boolean): void;
    removeAll(_destroy?: boolean): void;
    clear(): void;
}

declare class Leafer extends Group implements ILeafer {
    static list: LeafList;
    get __tag(): string;
    __: ILeaferData;
    pixelRatio?: INumber;
    get isApp(): boolean;
    get app(): ILeafer;
    get isLeafer(): boolean;
    parent?: IApp;
    running: boolean;
    created: boolean;
    ready: boolean;
    viewReady: boolean;
    viewCompleted: boolean;
    get imageReady(): boolean;
    get layoutLocked(): boolean;
    transforming: boolean;
    view: unknown;
    canvas: ILeaferCanvas;
    renderer: IRenderer;
    watcher: IWatcher;
    layouter: ILayouter;
    selector?: ISelector;
    interaction?: IInteraction;
    canvasManager: ICanvasManager;
    hitCanvasManager?: IHitCanvasManager;
    editor: IEditorBase;
    userConfig: ILeaferConfig;
    config: ILeaferConfig;
    autoLayout?: IAutoBounds;
    lazyBounds: IBounds;
    get FPS(): number;
    get cursorPoint(): IPointData;
    get clientBounds(): IBoundsData;
    leafs: number;
    __eventIds: IEventListenerId[];
    protected __startTimer: ITimer;
    protected __controllers: IControl[];
    protected __initWait: IFunction[];
    protected __readyWait: IFunction[];
    protected __viewReadyWait: IFunction[];
    protected __viewCompletedWait: IFunction[];
    __nextRenderWait: IFunction[];
    constructor(userConfig?: ILeaferConfig, data?: ILeaferInputData);
    init(userConfig?: ILeaferConfig, parentApp?: IApp): void;
    onInit(): void;
    initType(_type: ILeaferType): void;
    set(data: IUIInputData): void;
    start(): void;
    stop(): void;
    unlockLayout(): void;
    lockLayout(): void;
    resize(size: IScreenSizeData): void;
    forceRender(bounds?: IBoundsData): void;
    updateCursor(cursor?: ICursorType): void;
    updateLazyBounds(): void;
    protected __doResize(size: IScreenSizeData): void;
    protected __onResize(event: IResizeEvent): void;
    protected __setApp(): void;
    protected __bindApp(app: IApp): void;
    __setLeafer(leafer: ILeafer): void;
    protected __checkAutoLayout(config: ILeaferConfig, parentApp?: IApp): void;
    __setAttr(attrName: string, newValue: IValue): boolean;
    __getAttr(attrName: string): IValue;
    protected __changeCanvasSize(attrName: string, newValue: number): void;
    protected __changeFill(newValue: string): void;
    protected __onCreated(): void;
    protected __onReady(): void;
    protected __onViewReady(): void;
    protected __onNextRender(): void;
    protected __checkViewCompleted(emit?: boolean): void;
    protected __onWatchData(): void;
    waitInit(item: IFunction, bind?: IObject): void;
    waitReady(item: IFunction, bind?: IObject): void;
    waitViewReady(item: IFunction, bind?: IObject): void;
    waitViewCompleted(item: IFunction, bind?: IObject): void;
    nextRender(item: IFunction, bind?: IObject, off?: 'off'): void;
    zoom(_zoomType: IZoomType, _padding?: IFourNumber, _fixedScale?: boolean): IBoundsData;
    getValidMove(moveX: number, moveY: number): IPointData;
    getValidScale(changeScale: number): number;
    getWorldPointByClient(clientPoint: IClientPointData, updateClient?: boolean): IPointData;
    getPagePointByClient(clientPoint: IClientPointData, updateClient?: boolean): IPointData;
    updateClientBounds(): void;
    receiveEvent(_event: any): void;
    protected __checkUpdateLayout(): void;
    protected emitLeafer(type: string): void;
    protected __listenEvents(): void;
    protected __removeListenEvents(): void;
    destroy(sync?: boolean): void;
}

declare class Box extends Group implements IBox {
    get __tag(): string;
    get isBranchLeaf(): boolean;
    __: IBoxData;
    resizeChildren?: IBoolean;
    textBox?: IBoolean;
    overflow?: IOverflow;
    isOverflow: boolean;
    constructor(data?: IBoxInputData);
    __updateStrokeSpread(): number;
    __updateRectRenderSpread(): number;
    __updateRenderSpread(): number;
    __updateRectBoxBounds(): void;
    __updateBoxBounds(_secondLayout?: boolean): void;
    __updateStrokeBounds(): void;
    __updateRenderBounds(): void;
    __updateRectRenderBounds(): void;
    __updateRectChange(): void;
    __updateChange(): void;
    __renderRect(_canvas: ILeaferCanvas, _options: IRenderOptions): void;
    __renderGroup(_canvas: ILeaferCanvas, _options: IRenderOptions): void;
    __render(canvas: ILeaferCanvas, options: IRenderOptions): void;
    __drawContent(canvas: ILeaferCanvas, options: IRenderOptions): void;
}

declare class Frame extends Box implements IFrame {
    get __tag(): string;
    get isFrame(): boolean;
    __: IFrameData;
    fill?: IFill;
    overflow?: IOverflow;
    constructor(data?: IFrameInputData);
}

declare class Rect extends UI implements IRect {
    get __tag(): string;
    __: IRectData;
    constructor(data?: IRectInputData);
}

declare class Ellipse extends UI implements IEllipse {
    get __tag(): string;
    __: IEllipseData;
    innerRadius?: INumber;
    startAngle?: INumber;
    endAngle?: INumber;
    constructor(data?: IEllipseInputData);
    __updatePath(): void;
}

declare class Polygon extends UI implements IPolygon {
    get __tag(): string;
    __: IPolygonData;
    sides?: INumber;
    points?: number[] | IPointData[];
    curve?: boolean | number;
    constructor(data?: IPolygonInputData);
    __updatePath(): void;
    __updateRenderPath(): void;
    __updateBoxBounds(): void;
}

declare class Star extends UI implements IStar {
    get __tag(): string;
    __: IStarData;
    corners?: INumber;
    innerRadius?: INumber;
    constructor(data?: IStarInputData);
    __updatePath(): void;
}

declare class Line extends UI implements ILine {
    get __tag(): string;
    __: ILineData;
    strokeAlign?: IStrokeAlign;
    height?: INumber;
    points?: number[] | IPointData[];
    curve?: boolean | number;
    closed?: boolean;
    get toPoint(): IPointData;
    set toPoint(value: IPointData);
    constructor(data?: ILineInputData);
    __updatePath(): void;
    __updateRenderPath(): void;
    __updateBoxBounds(): void;
}

declare class Image extends Rect implements IImage {
    get __tag(): string;
    __: IImageData;
    url: IString;
    get ready(): boolean;
    image?: ILeaferImage;
    constructor(data?: IImageInputData);
    destroy(): void;
}
declare const MyImage: typeof Image;

declare class Canvas extends Rect implements ICanvas {
    get __tag(): string;
    __: ICanvasData;
    width?: INumber;
    height?: INumber;
    pixelRatio?: INumber;
    smooth?: boolean;
    contextSettings?: ICanvasContext2DSettings;
    canvas?: ILeaferCanvas;
    context?: ICanvasContext2D;
    get ready(): boolean;
    url?: string;
    constructor(data?: ICanvasInputData);
    drawImage(url: string): void;
    draw(ui: IUI, offset?: IPointData, scale?: number | IPointData, rotation?: number): void;
    paint(): void;
    __drawContent(canvas: ILeaferCanvas, _options: IRenderOptions): void;
    __updateSize(): void;
    destroy(): void;
}

declare class Text extends UI implements IText {
    get __tag(): string;
    __: ITextData;
    width?: INumber;
    height?: INumber;
    resizeFontSize?: IBoolean;
    fill?: IFill;
    strokeAlign?: IStrokeAlign;
    hitFill?: IHitType$1;
    text?: IString;
    fontFamily?: IString;
    fontSize?: INumber;
    fontWeight?: IFontWeight;
    italic?: IBoolean;
    textCase?: ITextCase;
    textDecoration?: ITextDecoration;
    letterSpacing?: INumber | IUnitData;
    lineHeight?: INumber | IUnitData;
    paraIndent?: INumber;
    paraSpacing?: INumber;
    textAlign?: ITextAlign;
    verticalAlign?: IVerticalAlign;
    autoSizeAlign?: IBoolean;
    textWrap?: ITextWrap;
    textOverflow?: IOverflow | string;
    get textDrawData(): ITextDrawData;
    constructor(data?: ITextInputData);
    __drawHitPath(canvas: ILeaferCanvas): void;
    __drawPathByData(drawer: IPathDrawer, _data?: IPathCommandData): void;
    __drawRenderPath(canvas: ILeaferCanvas): void;
    __updateTextDrawData(): void;
    __updateBoxBounds(): void;
    __updateRenderSpread(): number;
    __updateRenderBounds(): void;
}

declare class Path extends UI implements IPath {
    get __tag(): string;
    __: IPathData;
    strokeAlign?: IStrokeAlign;
    constructor(data?: IPathInputData);
}

declare class Pen extends Group implements IPen {
    get __tag(): string;
    __: IPenData;
    pathElement: IPath;
    pathStyle: IPathInputData;
    path: IPathCommandData$1;
    __path: IPathCommandData$1;
    constructor(data?: IPenInputData);
    setStyle(data: IPathInputData): Pen;
    beginPath(): Pen;
    moveTo(_x: number, _y: number): Pen;
    lineTo(_x: number, _y: number): Pen;
    bezierCurveTo(_x1: number, _y1: number, _x2: number, _y2: number, _x: number, _y: number): Pen;
    quadraticCurveTo(_x1: number, _y1: number, _x: number, _y: number): Pen;
    closePath(): Pen;
    rect(_x: number, _y: number, _width: number, _height: number): Pen;
    roundRect(_x: number, _y: number, _width: number, _height: number, _cornerRadius: number | number[]): Pen;
    ellipse(_x: number, _y: number, _radiusX: number, _radiusY: number, _rotation?: number, _startAngle?: number, _endAngle?: number, _anticlockwise?: boolean): Pen;
    arc(_x: number, _y: number, _radius: number, _startAngle?: number, _endAngle?: number, _anticlockwise?: boolean): Pen;
    arcTo(_x1: number, _y1: number, _x2: number, _y2: number, _radius: number): Pen;
    drawEllipse(_x: number, _y: number, _radiusX: number, _radiusY: number, _rotation?: number, _startAngle?: number, _endAngle?: number, _anticlockwise?: boolean): Pen;
    drawArc(_x: number, _y: number, _radius: number, _startAngle?: number, _endAngle?: number, _anticlockwise?: boolean): Pen;
    drawPoints(_points: number[], _curve?: boolean | number, _close?: boolean): Pen;
    clearPath(): Pen;
    paint(): void;
}

export { Box, Canvas, Ellipse, Frame, Group, Image, Leafer, Line, MyImage, Path, Pen, Polygon, Rect, Star, Text, UI };
