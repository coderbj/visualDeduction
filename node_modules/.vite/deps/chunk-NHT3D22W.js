import {
  Cursor,
  HitCanvasManager,
  InteractionBase,
  InteractionHelper
} from "./chunk-BZP5EJJA.js";
import {
  AlignHelper,
  Answer,
  AroundHelper,
  Bounds,
  BoundsHelper,
  BranchHelper,
  ChildEvent,
  ColorConvert,
  Creator,
  DataHelper,
  Debug,
  Direction4,
  Effect,
  Export,
  FileHelper,
  Group,
  ImageEvent,
  ImageManager,
  LayoutEvent,
  LeafBoundsHelper,
  LeafHelper,
  LeafLevelList,
  LeafList,
  LeaferCanvasBase,
  LeaferImage,
  MathHelper,
  Matrix,
  MatrixHelper,
  Paint,
  PaintGradient,
  PaintImage,
  Platform,
  PointHelper,
  PropertyEvent,
  RenderEvent,
  ResizeEvent,
  Run,
  TaskProcessor,
  TextConvert,
  TwoPointBoundsHelper,
  WatchEvent,
  canvasPatch,
  canvasSizeAttrs,
  defineKey
} from "./chunk-ART566W7.js";

// node_modules/.pnpm/leafer-ui@1.0.10/node_modules/leafer-ui/dist/web.esm.js
var debug$3 = Debug.get("LeaferCanvas");
var LeaferCanvas = class extends LeaferCanvasBase {
  set zIndex(zIndex) {
    const { style } = this.view;
    style.zIndex = zIndex;
    this.setAbsolute(this.view);
  }
  set childIndex(index) {
    const { view, parentView } = this;
    if (view && parentView) {
      const beforeNode = parentView.children[index];
      if (beforeNode) {
        this.setAbsolute(beforeNode);
        parentView.insertBefore(view, beforeNode);
      } else {
        parentView.appendChild(beforeNode);
      }
    }
  }
  init() {
    const { config } = this;
    const view = config.view || config.canvas;
    view ? this.__createViewFrom(view) : this.__createView();
    const { style } = this.view;
    style.display || (style.display = "block");
    this.parentView = this.view.parentElement;
    if (this.parentView) {
      const pStyle = this.parentView.style;
      pStyle.webkitUserSelect = pStyle.userSelect = "none";
    }
    if (Platform.syncDomFont && !this.parentView) {
      style.display = "none";
      document.body.appendChild(this.view);
    }
    this.__createContext();
    if (!this.autoLayout)
      this.resize(config);
  }
  set backgroundColor(color) {
    this.view.style.backgroundColor = color;
  }
  get backgroundColor() {
    return this.view.style.backgroundColor;
  }
  set hittable(hittable) {
    this.view.style.pointerEvents = hittable ? "auto" : "none";
  }
  get hittable() {
    return this.view.style.pointerEvents !== "none";
  }
  __createView() {
    this.view = document.createElement("canvas");
  }
  __createViewFrom(inputView) {
    let find = typeof inputView === "string" ? document.getElementById(inputView) : inputView;
    if (find) {
      if (find instanceof HTMLCanvasElement) {
        this.view = find;
      } else {
        let parent = find;
        if (find === window || find === document) {
          const div = document.createElement("div");
          const { style } = div;
          style.position = "absolute";
          style.top = style.bottom = style.left = style.right = "0px";
          document.body.appendChild(div);
          parent = div;
        }
        this.__createView();
        const view = this.view;
        if (parent.hasChildNodes()) {
          this.setAbsolute(view);
          parent.style.position || (parent.style.position = "relative");
        }
        parent.appendChild(view);
      }
    } else {
      debug$3.error(`no id: ${inputView}`);
      this.__createView();
    }
  }
  setAbsolute(view) {
    const { style } = view;
    style.position = "absolute";
    style.top = style.left = "0px";
  }
  updateViewSize() {
    const { width, height, pixelRatio } = this;
    const { style } = this.view;
    style.width = width + "px";
    style.height = height + "px";
    this.view.width = Math.ceil(width * pixelRatio);
    this.view.height = Math.ceil(height * pixelRatio);
  }
  updateClientBounds() {
    this.clientBounds = this.view.getBoundingClientRect();
  }
  startAutoLayout(autoBounds, listener) {
    this.resizeListener = listener;
    if (autoBounds) {
      this.autoBounds = autoBounds;
      try {
        this.resizeObserver = new ResizeObserver((entries) => {
          this.updateClientBounds();
          for (const entry of entries)
            this.checkAutoBounds(entry.contentRect);
        });
        const parent = this.parentView;
        if (parent) {
          this.resizeObserver.observe(parent);
          this.checkAutoBounds(parent.getBoundingClientRect());
        } else {
          this.checkAutoBounds(this.view);
          debug$3.warn("no parent");
        }
      } catch (_a) {
        this.imitateResizeObserver();
      }
    } else {
      window.addEventListener("resize", () => {
        const pixelRatio = Platform.devicePixelRatio;
        if (this.pixelRatio !== pixelRatio) {
          const { width, height } = this;
          this.emitResize({ width, height, pixelRatio });
        }
      });
    }
  }
  imitateResizeObserver() {
    if (this.autoLayout) {
      if (this.parentView)
        this.checkAutoBounds(this.parentView.getBoundingClientRect());
      Platform.requestRender(this.imitateResizeObserver.bind(this));
    }
  }
  checkAutoBounds(parentSize) {
    const view = this.view;
    const { x, y, width, height } = this.autoBounds.getBoundsFrom(parentSize);
    const size = { width, height, pixelRatio: Platform.devicePixelRatio };
    if (!this.isSameSize(size)) {
      const { style } = view;
      style.marginLeft = x + "px";
      style.marginTop = y + "px";
      this.emitResize(size);
    }
  }
  stopAutoLayout() {
    this.autoLayout = false;
    this.resizeListener = null;
    if (this.resizeObserver) {
      this.resizeObserver.disconnect();
      this.resizeObserver = null;
    }
  }
  emitResize(size) {
    const oldSize = {};
    DataHelper.copyAttrs(oldSize, this, canvasSizeAttrs);
    this.resize(size);
    if (this.resizeListener && this.width !== void 0)
      this.resizeListener(new ResizeEvent(size, oldSize));
  }
  unrealCanvas() {
    if (!this.unreal && this.parentView) {
      const view = this.view;
      if (view)
        view.remove();
      this.view = this.parentView;
      this.unreal = true;
    }
  }
  destroy() {
    if (this.view) {
      this.stopAutoLayout();
      if (!this.unreal) {
        const view = this.view;
        if (view.parentElement)
          view.remove();
      }
      super.destroy();
    }
  }
};
canvasPatch(CanvasRenderingContext2D.prototype);
canvasPatch(Path2D.prototype);
var { mineType, fileType } = FileHelper;
Object.assign(Creator, {
  canvas: (options, manager) => new LeaferCanvas(options, manager),
  image: (options) => new LeaferImage(options)
});
function useCanvas(_canvasType, _power) {
  Platform.origin = {
    createCanvas(width, height) {
      const canvas2 = document.createElement("canvas");
      canvas2.width = width;
      canvas2.height = height;
      return canvas2;
    },
    canvasToDataURL: (canvas2, type, quality) => canvas2.toDataURL(mineType(type), quality),
    canvasToBolb: (canvas2, type, quality) => new Promise((resolve) => canvas2.toBlob(resolve, mineType(type), quality)),
    canvasSaveAs: (canvas2, filename, quality) => {
      const url = canvas2.toDataURL(mineType(fileType(filename)), quality);
      return Platform.origin.download(url, filename);
    },
    download(url, filename) {
      return new Promise((resolve) => {
        let el = document.createElement("a");
        el.href = url;
        el.download = filename;
        document.body.appendChild(el);
        el.click();
        document.body.removeChild(el);
        resolve();
      });
    },
    loadImage(src) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        const { crossOrigin } = Platform.image;
        if (crossOrigin) {
          img.setAttribute("crossOrigin", crossOrigin);
          img.crossOrigin = crossOrigin;
        }
        img.onload = () => {
          resolve(img);
        };
        img.onerror = (e) => {
          reject(e);
        };
        img.src = Platform.image.getRealURL(src);
      });
    }
  };
  Platform.event = {
    stopDefault(origin2) {
      origin2.preventDefault();
    },
    stopNow(origin2) {
      origin2.stopImmediatePropagation();
    },
    stop(origin2) {
      origin2.stopPropagation();
    }
  };
  Platform.canvas = Creator.canvas();
  Platform.conicGradientSupport = !!Platform.canvas.context.createConicGradient;
}
Platform.name = "web";
Platform.isMobile = "ontouchstart" in window;
Platform.requestRender = function(render) {
  window.requestAnimationFrame(render);
};
defineKey(Platform, "devicePixelRatio", { get() {
  return Math.max(1, devicePixelRatio);
} });
var { userAgent } = navigator;
if (userAgent.indexOf("Firefox") > -1) {
  Platform.conicGradientRotate90 = true;
  Platform.intWheelDeltaY = true;
  Platform.syncDomFont = true;
} else if (userAgent.indexOf("Safari") > -1 && userAgent.indexOf("Chrome") === -1) {
  Platform.fullImageShadow = true;
}
if (userAgent.indexOf("Windows") > -1) {
  Platform.os = "Windows";
  Platform.intWheelDeltaY = true;
} else if (userAgent.indexOf("Mac") > -1) {
  Platform.os = "Mac";
} else if (userAgent.indexOf("Linux") > -1) {
  Platform.os = "Linux";
}
var Watcher = class {
  get childrenChanged() {
    return this.hasAdd || this.hasRemove || this.hasVisible;
  }
  get updatedList() {
    if (this.hasRemove) {
      const updatedList = new LeafList();
      this.__updatedList.list.forEach((item) => {
        if (item.leafer)
          updatedList.add(item);
      });
      return updatedList;
    } else {
      return this.__updatedList;
    }
  }
  constructor(target, userConfig) {
    this.totalTimes = 0;
    this.config = {};
    this.__updatedList = new LeafList();
    this.target = target;
    if (userConfig)
      this.config = DataHelper.default(userConfig, this.config);
    this.__listenEvents();
  }
  start() {
    if (this.disabled)
      return;
    this.running = true;
  }
  stop() {
    this.running = false;
  }
  disable() {
    this.stop();
    this.__removeListenEvents();
    this.disabled = true;
  }
  update() {
    this.changed = true;
    if (this.running)
      this.target.emit(RenderEvent.REQUEST);
  }
  __onAttrChange(event) {
    this.__updatedList.add(event.target);
    this.update();
  }
  __onChildEvent(event) {
    if (event.type === ChildEvent.ADD) {
      this.hasAdd = true;
      this.__pushChild(event.child);
    } else {
      this.hasRemove = true;
      this.__updatedList.add(event.parent);
    }
    this.update();
  }
  __pushChild(child) {
    this.__updatedList.add(child);
    if (child.isBranch)
      this.__loopChildren(child);
  }
  __loopChildren(parent) {
    const { children } = parent;
    for (let i = 0, len = children.length; i < len; i++)
      this.__pushChild(children[i]);
  }
  __onRquestData() {
    this.target.emitEvent(new WatchEvent(WatchEvent.DATA, { updatedList: this.updatedList }));
    this.__updatedList = new LeafList();
    this.totalTimes++;
    this.changed = false;
    this.hasVisible = false;
    this.hasRemove = false;
    this.hasAdd = false;
  }
  __listenEvents() {
    const { target } = this;
    this.__eventIds = [
      target.on_(PropertyEvent.CHANGE, this.__onAttrChange, this),
      target.on_([ChildEvent.ADD, ChildEvent.REMOVE], this.__onChildEvent, this),
      target.on_(WatchEvent.REQUEST, this.__onRquestData, this)
    ];
  }
  __removeListenEvents() {
    this.target.off_(this.__eventIds);
  }
  destroy() {
    if (this.target) {
      this.stop();
      this.__removeListenEvents();
      this.target = null;
      this.__updatedList = null;
    }
  }
};
var { updateAllMatrix: updateAllMatrix$1, updateBounds: updateOneBounds, updateAllWorldOpacity } = LeafHelper;
var { pushAllChildBranch, pushAllParent } = BranchHelper;
function updateMatrix(updateList, levelList) {
  let layout;
  updateList.list.forEach((leaf) => {
    layout = leaf.__layout;
    if (levelList.without(leaf) && !layout.proxyZoom) {
      if (layout.matrixChanged) {
        updateAllMatrix$1(leaf, true);
        levelList.add(leaf);
        if (leaf.isBranch)
          pushAllChildBranch(leaf, levelList);
        pushAllParent(leaf, levelList);
      } else if (layout.boundsChanged) {
        levelList.add(leaf);
        if (leaf.isBranch)
          leaf.__tempNumber = 0;
        pushAllParent(leaf, levelList);
      }
    }
  });
}
function updateBounds(boundsList) {
  let list, branch, children;
  boundsList.sort(true);
  boundsList.levels.forEach((level) => {
    list = boundsList.levelMap[level];
    for (let i = 0, len = list.length; i < len; i++) {
      branch = list[i];
      if (branch.isBranch && branch.__tempNumber) {
        children = branch.children;
        for (let j = 0, jLen = children.length; j < jLen; j++) {
          if (!children[j].isBranch) {
            updateOneBounds(children[j]);
          }
        }
      }
      updateOneBounds(branch);
    }
  });
}
function updateChange(updateList) {
  let layout;
  updateList.list.forEach((leaf) => {
    layout = leaf.__layout;
    if (layout.opacityChanged)
      updateAllWorldOpacity(leaf);
    if (layout.stateStyleChanged)
      setTimeout(() => layout.stateStyleChanged && leaf.updateState());
    leaf.__updateChange();
  });
}
var { worldBounds } = LeafBoundsHelper;
var bigBounds = { x: 0, y: 0, width: 1e5, height: 1e5 };
var LayoutBlockData = class {
  constructor(list) {
    this.updatedBounds = new Bounds();
    this.beforeBounds = new Bounds();
    this.afterBounds = new Bounds();
    if (list instanceof Array)
      list = new LeafList(list);
    this.updatedList = list;
  }
  setBefore() {
    this.beforeBounds.setListWithFn(this.updatedList.list, worldBounds);
  }
  setAfter() {
    const { list } = this.updatedList;
    if (list.some((leaf) => leaf.noBounds)) {
      this.afterBounds.set(bigBounds);
    } else {
      this.afterBounds.setListWithFn(list, worldBounds);
    }
    this.updatedBounds.setList([this.beforeBounds, this.afterBounds]);
  }
  merge(data) {
    this.updatedList.addList(data.updatedList.list);
    this.beforeBounds.add(data.beforeBounds);
    this.afterBounds.add(data.afterBounds);
    this.updatedBounds.add(data.updatedBounds);
  }
  destroy() {
    this.updatedList = null;
  }
};
var { updateAllMatrix, updateAllChange } = LeafHelper;
var debug$2 = Debug.get("Layouter");
var Layouter = class _Layouter {
  constructor(target, userConfig) {
    this.totalTimes = 0;
    this.config = {};
    this.__levelList = new LeafLevelList();
    this.target = target;
    if (userConfig)
      this.config = DataHelper.default(userConfig, this.config);
    this.__listenEvents();
  }
  start() {
    if (this.disabled)
      return;
    this.running = true;
  }
  stop() {
    this.running = false;
  }
  disable() {
    this.stop();
    this.__removeListenEvents();
    this.disabled = true;
  }
  layout() {
    if (!this.running)
      return;
    const { target } = this;
    this.times = 0;
    try {
      target.emit(LayoutEvent.START);
      this.layoutOnce();
      target.emitEvent(new LayoutEvent(LayoutEvent.END, this.layoutedBlocks, this.times));
    } catch (e) {
      debug$2.error(e);
    }
    this.layoutedBlocks = null;
  }
  layoutAgain() {
    if (this.layouting) {
      this.waitAgain = true;
    } else {
      this.layoutOnce();
    }
  }
  layoutOnce() {
    if (this.layouting)
      return debug$2.warn("layouting");
    if (this.times > 3)
      return debug$2.warn("layout max times");
    this.times++;
    this.totalTimes++;
    this.layouting = true;
    this.target.emit(WatchEvent.REQUEST);
    if (this.totalTimes > 1) {
      this.partLayout();
    } else {
      this.fullLayout();
    }
    this.layouting = false;
    if (this.waitAgain) {
      this.waitAgain = false;
      this.layoutOnce();
    }
  }
  partLayout() {
    var _a;
    if (!((_a = this.__updatedList) === null || _a === void 0 ? void 0 : _a.length))
      return;
    const t = Run.start("PartLayout");
    const { target, __updatedList: updateList } = this;
    const { BEFORE, LAYOUT, AFTER } = LayoutEvent;
    const blocks = this.getBlocks(updateList);
    blocks.forEach((item) => item.setBefore());
    target.emitEvent(new LayoutEvent(BEFORE, blocks, this.times));
    this.extraBlock = null;
    updateList.sort();
    updateMatrix(updateList, this.__levelList);
    updateBounds(this.__levelList);
    updateChange(updateList);
    if (this.extraBlock)
      blocks.push(this.extraBlock);
    blocks.forEach((item) => item.setAfter());
    target.emitEvent(new LayoutEvent(LAYOUT, blocks, this.times));
    target.emitEvent(new LayoutEvent(AFTER, blocks, this.times));
    this.addBlocks(blocks);
    this.__levelList.reset();
    this.__updatedList = null;
    Run.end(t);
  }
  fullLayout() {
    const t = Run.start("FullLayout");
    const { target } = this;
    const { BEFORE, LAYOUT, AFTER } = LayoutEvent;
    const blocks = this.getBlocks(new LeafList(target));
    target.emitEvent(new LayoutEvent(BEFORE, blocks, this.times));
    _Layouter.fullLayout(target);
    blocks.forEach((item) => {
      item.setAfter();
    });
    target.emitEvent(new LayoutEvent(LAYOUT, blocks, this.times));
    target.emitEvent(new LayoutEvent(AFTER, blocks, this.times));
    this.addBlocks(blocks);
    Run.end(t);
  }
  static fullLayout(target) {
    updateAllMatrix(target, true);
    if (target.isBranch) {
      BranchHelper.updateBounds(target);
    } else {
      LeafHelper.updateBounds(target);
    }
    updateAllChange(target);
  }
  addExtra(leaf) {
    if (!this.__updatedList.has(leaf)) {
      const { updatedList, beforeBounds } = this.extraBlock || (this.extraBlock = new LayoutBlockData([]));
      updatedList.length ? beforeBounds.add(leaf.__world) : beforeBounds.set(leaf.__world);
      updatedList.add(leaf);
    }
  }
  createBlock(data) {
    return new LayoutBlockData(data);
  }
  getBlocks(list) {
    return [this.createBlock(list)];
  }
  addBlocks(current) {
    this.layoutedBlocks ? this.layoutedBlocks.push(...current) : this.layoutedBlocks = current;
  }
  __onReceiveWatchData(event) {
    this.__updatedList = event.data.updatedList;
  }
  __listenEvents() {
    const { target } = this;
    this.__eventIds = [
      target.on_(LayoutEvent.REQUEST, this.layout, this),
      target.on_(LayoutEvent.AGAIN, this.layoutAgain, this),
      target.on_(WatchEvent.DATA, this.__onReceiveWatchData, this)
    ];
  }
  __removeListenEvents() {
    this.target.off_(this.__eventIds);
  }
  destroy() {
    if (this.target) {
      this.stop();
      this.__removeListenEvents();
      this.target = this.config = null;
    }
  }
};
var debug$1 = Debug.get("Renderer");
var Renderer = class {
  get needFill() {
    return !!(!this.canvas.allowBackgroundColor && this.config.fill);
  }
  constructor(target, canvas2, userConfig) {
    this.FPS = 60;
    this.totalTimes = 0;
    this.times = 0;
    this.config = {
      usePartRender: true,
      maxFPS: 60
    };
    this.target = target;
    this.canvas = canvas2;
    if (userConfig)
      this.config = DataHelper.default(userConfig, this.config);
    this.__listenEvents();
    this.__requestRender();
  }
  start() {
    this.running = true;
  }
  stop() {
    this.running = false;
  }
  update() {
    this.changed = true;
  }
  requestLayout() {
    this.target.emit(LayoutEvent.REQUEST);
  }
  render(callback) {
    if (!(this.running && this.canvas.view)) {
      this.changed = true;
      return;
    }
    const { target } = this;
    this.times = 0;
    this.totalBounds = new Bounds();
    debug$1.log(target.innerName, "--->");
    try {
      if (!target.isApp)
        target.app.emit(RenderEvent.CHILD_START, target);
      this.emitRender(RenderEvent.START);
      this.renderOnce(callback);
      this.emitRender(RenderEvent.END, this.totalBounds);
      ImageManager.clearRecycled();
    } catch (e) {
      this.rendering = false;
      debug$1.error(e);
    }
    debug$1.log("-------------|");
  }
  renderAgain() {
    if (this.rendering) {
      this.waitAgain = true;
    } else {
      this.renderOnce();
    }
  }
  renderOnce(callback) {
    if (this.rendering)
      return debug$1.warn("rendering");
    if (this.times > 3)
      return debug$1.warn("render max times");
    this.times++;
    this.totalTimes++;
    this.rendering = true;
    this.changed = false;
    this.renderBounds = new Bounds();
    this.renderOptions = {};
    if (callback) {
      this.emitRender(RenderEvent.BEFORE);
      callback();
    } else {
      this.requestLayout();
      if (this.ignore) {
        this.ignore = this.rendering = false;
        return;
      }
      this.emitRender(RenderEvent.BEFORE);
      if (this.config.usePartRender && this.totalTimes > 1) {
        this.partRender();
      } else {
        this.fullRender();
      }
    }
    this.emitRender(RenderEvent.RENDER, this.renderBounds, this.renderOptions);
    this.emitRender(RenderEvent.AFTER, this.renderBounds, this.renderOptions);
    this.updateBlocks = null;
    this.rendering = false;
    if (this.waitAgain) {
      this.waitAgain = false;
      this.renderOnce();
    }
  }
  partRender() {
    const { canvas: canvas2, updateBlocks: list } = this;
    if (!list)
      return debug$1.warn("PartRender: need update attr");
    this.mergeBlocks();
    list.forEach((block) => {
      if (canvas2.bounds.hit(block) && !block.isEmpty())
        this.clipRender(block);
    });
  }
  clipRender(block) {
    const t = Run.start("PartRender");
    const { canvas: canvas2 } = this;
    const bounds2 = block.getIntersect(canvas2.bounds);
    const includes = block.includes(this.target.__world);
    const realBounds = new Bounds(bounds2);
    canvas2.save();
    if (includes && !Debug.showRepaint) {
      canvas2.clear();
    } else {
      bounds2.spread(10 + 1 / this.canvas.pixelRatio).ceil();
      canvas2.clearWorld(bounds2, true);
      canvas2.clipWorld(bounds2, true);
    }
    this.__render(bounds2, includes, realBounds);
    canvas2.restore();
    Run.end(t);
  }
  fullRender() {
    const t = Run.start("FullRender");
    const { canvas: canvas2 } = this;
    canvas2.save();
    canvas2.clear();
    this.__render(canvas2.bounds, true);
    canvas2.restore();
    Run.end(t);
  }
  __render(bounds2, includes, realBounds) {
    const options = bounds2.includes(this.target.__world) ? { includes } : { bounds: bounds2, includes };
    if (this.needFill)
      this.canvas.fillWorld(bounds2, this.config.fill);
    if (Debug.showRepaint)
      this.canvas.strokeWorld(bounds2, "red");
    this.target.__render(this.canvas, options);
    this.renderBounds = realBounds = realBounds || bounds2;
    this.renderOptions = options;
    this.totalBounds.isEmpty() ? this.totalBounds = realBounds : this.totalBounds.add(realBounds);
    if (Debug.showHitView)
      this.renderHitView(options);
    if (Debug.showBoundsView)
      this.renderBoundsView(options);
    this.canvas.updateRender(realBounds);
  }
  renderHitView(_options) {
  }
  renderBoundsView(_options) {
  }
  addBlock(block) {
    if (!this.updateBlocks)
      this.updateBlocks = [];
    this.updateBlocks.push(block);
  }
  mergeBlocks() {
    const { updateBlocks: list } = this;
    if (list) {
      const bounds2 = new Bounds();
      bounds2.setList(list);
      list.length = 0;
      list.push(bounds2);
    }
  }
  __requestRender() {
    const startTime = Date.now();
    Platform.requestRender(() => {
      this.FPS = Math.min(60, Math.ceil(1e3 / (Date.now() - startTime)));
      if (this.running) {
        if (this.changed && this.canvas.view)
          this.render();
        this.target.emit(RenderEvent.NEXT);
      }
      if (this.target)
        this.__requestRender();
    });
  }
  __onResize(e) {
    if (this.canvas.unreal)
      return;
    if (e.bigger || !e.samePixelRatio) {
      const { width, height } = e.old;
      const bounds2 = new Bounds(0, 0, width, height);
      if (!bounds2.includes(this.target.__world) || this.needFill || !e.samePixelRatio) {
        this.addBlock(this.canvas.bounds);
        this.target.forceUpdate("surface");
        return;
      }
    }
    this.addBlock(new Bounds(0, 0, 1, 1));
    this.changed = true;
  }
  __onLayoutEnd(event) {
    if (event.data)
      event.data.map((item) => {
        let empty;
        if (item.updatedList)
          item.updatedList.list.some((leaf) => {
            empty = !leaf.__world.width || !leaf.__world.height;
            if (empty) {
              if (!leaf.isLeafer)
                debug$1.tip(leaf.innerName, ": empty");
              empty = !leaf.isBranch || leaf.isBranchLeaf;
            }
            return empty;
          });
        this.addBlock(empty ? this.canvas.bounds : item.updatedBounds);
      });
  }
  emitRender(type, bounds2, options) {
    this.target.emitEvent(new RenderEvent(type, this.times, bounds2, options));
  }
  __listenEvents() {
    const { target } = this;
    this.__eventIds = [
      target.on_(RenderEvent.REQUEST, this.update, this),
      target.on_(LayoutEvent.END, this.__onLayoutEnd, this),
      target.on_(RenderEvent.AGAIN, this.renderAgain, this),
      target.on_(ResizeEvent.RESIZE, this.__onResize, this)
    ];
  }
  __removeListenEvents() {
    this.target.off_(this.__eventIds);
  }
  destroy() {
    if (this.target) {
      this.stop();
      this.__removeListenEvents();
      this.target = this.canvas = this.config = null;
    }
  }
};
var { hitRadiusPoint } = BoundsHelper;
var Picker = class {
  constructor(target, selector) {
    this.target = target;
    this.selector = selector;
  }
  getByPoint(hitPoint, hitRadius, options) {
    if (!hitRadius)
      hitRadius = 0;
    if (!options)
      options = {};
    const through = options.through || false;
    const ignoreHittable = options.ignoreHittable || false;
    const target = options.target || this.target;
    this.exclude = options.exclude || null;
    this.point = { x: hitPoint.x, y: hitPoint.y, radiusX: hitRadius, radiusY: hitRadius };
    this.findList = new LeafList(options.findList);
    if (!options.findList)
      this.hitBranch(target);
    const { list } = this.findList;
    const leaf = this.getBestMatchLeaf(list, options.bottomList, ignoreHittable);
    const path = ignoreHittable ? this.getPath(leaf) : this.getHitablePath(leaf);
    this.clear();
    return through ? { path, target: leaf, throughPath: list.length ? this.getThroughPath(list) : path } : { path, target: leaf };
  }
  getBestMatchLeaf(list, bottomList, ignoreHittable) {
    if (list.length) {
      let find;
      this.findList = new LeafList();
      const { x, y } = this.point;
      const point = { x, y, radiusX: 0, radiusY: 0 };
      for (let i = 0, len = list.length; i < len; i++) {
        find = list[i];
        if (ignoreHittable || LeafHelper.worldHittable(find)) {
          this.hitChild(find, point);
          if (this.findList.length)
            return this.findList.list[0];
        }
      }
    }
    if (bottomList) {
      for (let i = 0, len = bottomList.length; i < len; i++) {
        this.hitChild(bottomList[i].target, this.point, bottomList[i].proxy);
        if (this.findList.length)
          return this.findList.list[0];
      }
    }
    return list[0];
  }
  getPath(leaf) {
    const path = new LeafList();
    while (leaf) {
      path.add(leaf);
      leaf = leaf.parent;
    }
    if (this.target)
      path.add(this.target);
    return path;
  }
  getHitablePath(leaf) {
    const path = this.getPath(leaf && leaf.hittable ? leaf : null);
    let item, hittablePath = new LeafList();
    for (let i = path.list.length - 1; i > -1; i--) {
      item = path.list[i];
      if (!item.__.hittable)
        break;
      hittablePath.addAt(item, 0);
      if (!item.__.hitChildren)
        break;
    }
    return hittablePath;
  }
  getThroughPath(list) {
    const throughPath = new LeafList();
    const pathList = [];
    for (let i = list.length - 1; i > -1; i--) {
      pathList.push(this.getPath(list[i]));
    }
    let path, nextPath, leaf;
    for (let i = 0, len = pathList.length; i < len; i++) {
      path = pathList[i], nextPath = pathList[i + 1];
      for (let j = 0, jLen = path.length; j < jLen; j++) {
        leaf = path.list[j];
        if (nextPath && nextPath.has(leaf))
          break;
        throughPath.add(leaf);
      }
    }
    return throughPath;
  }
  hitBranch(branch) {
    this.eachFind(branch.children, branch.__onlyHitMask);
  }
  eachFind(children, hitMask) {
    let child, hit;
    const { point } = this, len = children.length;
    for (let i = len - 1; i > -1; i--) {
      child = children[i];
      if (!child.__.visible || hitMask && !child.__.mask)
        continue;
      hit = child.__.hitRadius ? true : hitRadiusPoint(child.__world, point);
      if (child.isBranch) {
        if (hit || child.__ignoreHitWorld) {
          this.eachFind(child.children, child.__onlyHitMask);
          if (child.isBranchLeaf)
            this.hitChild(child, point);
        }
      } else {
        if (hit)
          this.hitChild(child, point);
      }
    }
  }
  hitChild(child, point, proxy) {
    if (this.exclude && this.exclude.has(child))
      return;
    if (child.__hitWorld(point)) {
      const { parent } = child;
      if (parent && parent.__hasMask && !child.__.mask && !parent.children.some((item) => item.__.mask && item.__hitWorld(point)))
        return;
      this.findList.add(proxy || child);
    }
  }
  clear() {
    this.point = null;
    this.findList = null;
    this.exclude = null;
  }
  destroy() {
    this.clear();
  }
};
var { Yes, NoAndSkip, YesAndSkip } = Answer;
var idCondition = {};
var classNameCondition = {};
var tagCondition = {};
var Selector = class {
  constructor(target, userConfig) {
    this.config = {};
    this.innerIdMap = {};
    this.idMap = {};
    this.methods = {
      id: (leaf, name) => leaf.id === name ? (this.target && (this.idMap[name] = leaf), 1) : 0,
      innerId: (leaf, innerId) => leaf.innerId === innerId ? (this.target && (this.innerIdMap[innerId] = leaf), 1) : 0,
      className: (leaf, name) => leaf.className === name ? 1 : 0,
      tag: (leaf, name) => leaf.__tag === name ? 1 : 0,
      tags: (leaf, nameMap) => nameMap[leaf.__tag] ? 1 : 0
    };
    this.target = target;
    if (userConfig)
      this.config = DataHelper.default(userConfig, this.config);
    this.picker = new Picker(target, this);
    if (target)
      this.__listenEvents();
  }
  getBy(condition, branch, one, options) {
    switch (typeof condition) {
      case "number":
        const leaf = this.getByInnerId(condition, branch);
        return one ? leaf : leaf ? [leaf] : [];
      case "string":
        switch (condition[0]) {
          case "#":
            idCondition.id = condition.substring(1), condition = idCondition;
            break;
          case ".":
            classNameCondition.className = condition.substring(1), condition = classNameCondition;
            break;
          default:
            tagCondition.tag = condition, condition = tagCondition;
        }
      case "object":
        if (condition.id !== void 0) {
          const leaf2 = this.getById(condition.id, branch);
          return one ? leaf2 : leaf2 ? [leaf2] : [];
        } else if (condition.tag) {
          const { tag } = condition, isArray = tag instanceof Array;
          return this.getByMethod(isArray ? this.methods.tags : this.methods.tag, branch, one, isArray ? DataHelper.toMap(tag) : tag);
        } else {
          return this.getByMethod(this.methods.className, branch, one, condition.className);
        }
      case "function":
        return this.getByMethod(condition, branch, one, options);
    }
  }
  getByPoint(hitPoint, hitRadius, options) {
    if (Platform.name === "node" && this.target)
      this.target.emit(LayoutEvent.CHECK_UPDATE);
    return this.picker.getByPoint(hitPoint, hitRadius, options);
  }
  getByInnerId(innerId, branch) {
    const cache2 = this.innerIdMap[innerId];
    if (cache2)
      return cache2;
    this.eachFind(this.toChildren(branch), this.methods.innerId, null, innerId);
    return this.findLeaf;
  }
  getById(id, branch) {
    const cache2 = this.idMap[id];
    if (cache2 && LeafHelper.hasParent(cache2, branch || this.target))
      return cache2;
    this.eachFind(this.toChildren(branch), this.methods.id, null, id);
    return this.findLeaf;
  }
  getByClassName(className, branch) {
    return this.getByMethod(this.methods.className, branch, false, className);
  }
  getByTag(tag, branch) {
    return this.getByMethod(this.methods.tag, branch, false, tag);
  }
  getByMethod(method, branch, one, options) {
    const list = one ? null : [];
    this.eachFind(this.toChildren(branch), method, list, options);
    return list || this.findLeaf;
  }
  eachFind(children, method, list, options) {
    let child, result;
    for (let i = 0, len = children.length; i < len; i++) {
      child = children[i];
      result = method(child, options);
      if (result === Yes || result === YesAndSkip) {
        if (list) {
          list.push(child);
        } else {
          this.findLeaf = child;
          return;
        }
      }
      if (child.isBranch && result < NoAndSkip)
        this.eachFind(child.children, method, list, options);
    }
  }
  toChildren(branch) {
    this.findLeaf = null;
    return [branch || this.target];
  }
  __onRemoveChild(event) {
    const { id, innerId } = event.child;
    if (this.idMap[id])
      delete this.idMap[id];
    if (this.innerIdMap[innerId])
      delete this.innerIdMap[innerId];
  }
  __checkIdChange(event) {
    if (event.attrName === "id") {
      const id = event.oldValue;
      if (this.idMap[id])
        delete this.idMap[id];
    }
  }
  __listenEvents() {
    this.__eventIds = [
      this.target.on_(ChildEvent.REMOVE, this.__onRemoveChild, this),
      this.target.on_(PropertyEvent.CHANGE, this.__checkIdChange, this)
    ];
  }
  __removeListenEvents() {
    this.target.off_(this.__eventIds);
    this.__eventIds.length = 0;
  }
  destroy() {
    if (this.__eventIds.length) {
      this.__removeListenEvents();
      this.picker.destroy();
      this.findLeaf = null;
      this.innerIdMap = {};
      this.idMap = {};
    }
  }
};
Object.assign(Creator, {
  watcher: (target, options) => new Watcher(target, options),
  layouter: (target, options) => new Layouter(target, options),
  renderer: (target, canvas2, options) => new Renderer(target, canvas2, options),
  selector: (target, options) => new Selector(target, options)
});
Platform.layout = Layouter.fullLayout;
var PointerEventHelper = {
  convert(e, local) {
    const base = InteractionHelper.getBase(e);
    const data = Object.assign(Object.assign({}, base), { x: local.x, y: local.y, width: e.width, height: e.height, pointerType: e.pointerType, pressure: e.pressure });
    if (data.pointerType === "pen") {
      data.tangentialPressure = e.tangentialPressure;
      data.tiltX = e.tiltX;
      data.tiltY = e.tiltY;
      data.twist = e.twist;
    }
    return data;
  },
  convertMouse(e, local) {
    const base = InteractionHelper.getBase(e);
    return Object.assign(Object.assign({}, base), { x: local.x, y: local.y, width: 1, height: 1, pointerType: "mouse", pressure: 0.5 });
  },
  convertTouch(e, local) {
    const touch = PointerEventHelper.getTouch(e);
    const base = InteractionHelper.getBase(e);
    return Object.assign(Object.assign({}, base), { x: local.x, y: local.y, width: 1, height: 1, pointerType: "touch", multiTouch: e.touches.length > 1, pressure: touch.force });
  },
  getTouch(e) {
    return e.targetTouches[0] || e.changedTouches[0];
  }
};
var WheelEventHelper = {
  getMove(e, config) {
    let { moveSpeed } = config;
    let { deltaX, deltaY } = e;
    if (e.shiftKey && !deltaX) {
      deltaX = deltaY;
      deltaY = 0;
    }
    if (deltaX > 50)
      deltaX = Math.max(50, deltaX / 3);
    if (deltaY > 50)
      deltaY = Math.max(50, deltaY / 3);
    return { x: -deltaX * moveSpeed * 2, y: -deltaY * moveSpeed * 2 };
  },
  getScale(e, config) {
    let zoom;
    let scale2 = 1;
    let { zoomMode, zoomSpeed } = config;
    const delta = e.deltaY || e.deltaX;
    if (zoomMode) {
      zoom = zoomMode === "mouse" ? true : !e.deltaX && (Platform.intWheelDeltaY ? Math.abs(delta) > 17 : Math.ceil(delta) !== delta);
      if (e.shiftKey || e.metaKey || e.ctrlKey)
        zoom = true;
    } else {
      zoom = !e.shiftKey && (e.metaKey || e.ctrlKey);
    }
    if (zoom) {
      zoomSpeed = MathHelper.within(zoomSpeed, 0, 1);
      const min = e.deltaY ? config.delta.y : config.delta.x;
      scale2 = 1 - delta / (min * 4) * zoomSpeed;
      if (scale2 < 0.5)
        scale2 = 0.5;
      if (scale2 >= 1.5)
        scale2 = 1.5;
    }
    return scale2;
  }
};
var KeyEventHelper = {
  convert(e) {
    const base = InteractionHelper.getBase(e);
    const data = Object.assign(Object.assign({}, base), { code: e.code, key: e.key });
    return data;
  }
};
var { getMoveEventData, getZoomEventData, getRotateEventData, pathCanDrag } = InteractionHelper;
var Interaction = class extends InteractionBase {
  __listenEvents() {
    super.__listenEvents();
    const view = this.view = this.canvas.view;
    this.viewEvents = {
      "pointerdown": this.onPointerDown,
      "mousedown": this.onMouseDown,
      "touchstart": this.onTouchStart,
      "contextmenu": this.onContextMenu,
      "wheel": this.onWheel,
      "gesturestart": this.onGesturestart,
      "gesturechange": this.onGesturechange,
      "gestureend": this.onGestureend
    };
    this.windowEvents = {
      "pointermove": this.onPointerMove,
      "pointerup": this.onPointerUp,
      "pointercancel": this.onPointerCancel,
      "mousemove": this.onMouseMove,
      "mouseup": this.onMouseUp,
      "touchmove": this.onTouchMove,
      "touchend": this.onTouchEnd,
      "touchcancel": this.onTouchCancel,
      "keydown": this.onKeyDown,
      "keyup": this.onKeyUp,
      "scroll": this.onScroll
    };
    const { viewEvents, windowEvents } = this;
    for (let name in viewEvents) {
      viewEvents[name] = viewEvents[name].bind(this);
      view.addEventListener(name, viewEvents[name]);
    }
    for (let name in windowEvents) {
      windowEvents[name] = windowEvents[name].bind(this);
      window.addEventListener(name, windowEvents[name]);
    }
  }
  __removeListenEvents() {
    super.__removeListenEvents();
    const { viewEvents, windowEvents } = this;
    for (let name in viewEvents) {
      this.view.removeEventListener(name, viewEvents[name]);
      this.viewEvents = {};
    }
    for (let name in windowEvents) {
      window.removeEventListener(name, windowEvents[name]);
      this.windowEvents = {};
    }
  }
  getTouches(touches) {
    const list = [];
    for (let i = 0, len = touches.length; i < len; i++) {
      list.push(touches[i]);
    }
    return list;
  }
  preventDefaultPointer(e) {
    const { pointer } = this.config;
    if (pointer.preventDefault)
      e.preventDefault();
  }
  preventDefaultWheel(e) {
    const { wheel } = this.config;
    if (wheel.preventDefault)
      e.preventDefault();
  }
  preventWindowPointer(e) {
    return !this.downData && e.target !== this.view;
  }
  onKeyDown(e) {
    this.keyDown(KeyEventHelper.convert(e));
  }
  onKeyUp(e) {
    this.keyUp(KeyEventHelper.convert(e));
  }
  onContextMenu(e) {
    if (this.config.pointer.preventDefaultMenu)
      e.preventDefault();
    this.menu(PointerEventHelper.convert(e, this.getLocal(e)));
  }
  onScroll() {
    this.canvas.updateClientBounds();
  }
  onPointerDown(e) {
    this.preventDefaultPointer(e);
    if (this.config.pointer.touch || this.useMultiTouch)
      return;
    this.usePointer || (this.usePointer = true);
    this.pointerDown(PointerEventHelper.convert(e, this.getLocal(e)));
  }
  onPointerMove(e) {
    if (this.config.pointer.touch || this.useMultiTouch || this.preventWindowPointer(e))
      return;
    this.usePointer || (this.usePointer = true);
    this.pointerMove(PointerEventHelper.convert(e, this.getLocal(e, true)));
  }
  onPointerUp(e) {
    if (this.downData)
      this.preventDefaultPointer(e);
    if (this.config.pointer.touch || this.useMultiTouch || this.preventWindowPointer(e))
      return;
    this.pointerUp(PointerEventHelper.convert(e, this.getLocal(e)));
  }
  onPointerCancel() {
    if (this.useMultiTouch)
      return;
    this.pointerCancel();
  }
  onMouseDown(e) {
    this.preventDefaultPointer(e);
    if (this.useTouch || this.usePointer)
      return;
    this.pointerDown(PointerEventHelper.convertMouse(e, this.getLocal(e)));
  }
  onMouseMove(e) {
    if (this.useTouch || this.usePointer || this.preventWindowPointer(e))
      return;
    this.pointerMove(PointerEventHelper.convertMouse(e, this.getLocal(e, true)));
  }
  onMouseUp(e) {
    if (this.downData)
      this.preventDefaultPointer(e);
    if (this.useTouch || this.usePointer || this.preventWindowPointer(e))
      return;
    this.pointerUp(PointerEventHelper.convertMouse(e, this.getLocal(e)));
  }
  onMouseCancel() {
    if (this.useTouch || this.usePointer)
      return;
    this.pointerCancel();
  }
  onTouchStart(e) {
    const touch = PointerEventHelper.getTouch(e);
    const local = this.getLocal(touch, true);
    const { preventDefault } = this.config.touch;
    if (preventDefault === true || preventDefault === "auto" && pathCanDrag(this.findPath(local)))
      e.preventDefault();
    this.multiTouchStart(e);
    if (this.usePointer)
      return;
    if (this.touchTimer) {
      window.clearTimeout(this.touchTimer);
      this.touchTimer = 0;
    }
    this.useTouch = true;
    this.pointerDown(PointerEventHelper.convertTouch(e, local));
  }
  onTouchMove(e) {
    this.multiTouchMove(e);
    if (this.usePointer || this.preventWindowPointer(e))
      return;
    const touch = PointerEventHelper.getTouch(e);
    this.pointerMove(PointerEventHelper.convertTouch(e, this.getLocal(touch)));
  }
  onTouchEnd(e) {
    this.multiTouchEnd();
    if (this.usePointer || this.preventWindowPointer(e))
      return;
    if (this.touchTimer)
      clearTimeout(this.touchTimer);
    this.touchTimer = setTimeout(() => {
      this.useTouch = false;
    }, 500);
    const touch = PointerEventHelper.getTouch(e);
    this.pointerUp(PointerEventHelper.convertTouch(e, this.getLocal(touch)));
  }
  onTouchCancel() {
    if (this.usePointer)
      return;
    this.pointerCancel();
  }
  multiTouchStart(e) {
    this.useMultiTouch = e.touches.length > 1;
    this.touches = this.useMultiTouch ? this.getTouches(e.touches) : void 0;
    if (this.useMultiTouch)
      this.pointerCancel();
  }
  multiTouchMove(e) {
    if (!this.useMultiTouch)
      return;
    if (e.touches.length > 1) {
      const touches = this.getTouches(e.touches);
      const list = this.getKeepTouchList(this.touches, touches);
      if (list.length > 1) {
        this.multiTouch(InteractionHelper.getBase(e), list);
        this.touches = touches;
      }
    }
  }
  multiTouchEnd() {
    this.touches = null;
    this.useMultiTouch = false;
    this.transformEnd();
  }
  getKeepTouchList(old, touches) {
    let to;
    const list = [];
    old.forEach((from) => {
      to = touches.find((touch) => touch.identifier === from.identifier);
      if (to)
        list.push({ from: this.getLocal(from), to: this.getLocal(to) });
    });
    return list;
  }
  getLocalTouchs(points) {
    return points.map((point) => this.getLocal(point));
  }
  onWheel(e) {
    this.preventDefaultWheel(e);
    const { wheel } = this.config;
    if (wheel.disabled)
      return;
    const scale2 = wheel.getScale ? wheel.getScale(e, wheel) : WheelEventHelper.getScale(e, wheel);
    const local = this.getLocal(e);
    const eventBase = InteractionHelper.getBase(e);
    scale2 !== 1 ? this.zoom(getZoomEventData(local, scale2, eventBase)) : this.move(getMoveEventData(local, wheel.getMove ? wheel.getMove(e, wheel) : WheelEventHelper.getMove(e, wheel), eventBase));
  }
  onGesturestart(e) {
    if (this.useMultiTouch)
      return;
    this.preventDefaultWheel(e);
    this.lastGestureScale = 1;
    this.lastGestureRotation = 0;
  }
  onGesturechange(e) {
    if (this.useMultiTouch)
      return;
    this.preventDefaultWheel(e);
    const local = this.getLocal(e);
    const eventBase = InteractionHelper.getBase(e);
    const changeScale = e.scale / this.lastGestureScale;
    const changeAngle = e.rotation - this.lastGestureRotation;
    let { rotateSpeed } = this.config.wheel;
    rotateSpeed = MathHelper.within(rotateSpeed, 0, 1);
    this.zoom(getZoomEventData(local, changeScale * changeScale, eventBase));
    this.rotate(getRotateEventData(local, changeAngle / Math.PI * 180 * (rotateSpeed / 4 + 0.1), eventBase));
    this.lastGestureScale = e.scale;
    this.lastGestureRotation = e.rotation;
  }
  onGestureend(e) {
    if (this.useMultiTouch)
      return;
    this.preventDefaultWheel(e);
    this.transformEnd();
  }
  setCursor(cursor) {
    super.setCursor(cursor);
    const list = [];
    this.eachCursor(cursor, list);
    if (typeof list[list.length - 1] === "object")
      list.push("default");
    this.canvas.view.style.cursor = list.map((item) => typeof item === "object" ? `url(${item.url}) ${item.x || 0} ${item.y || 0}` : item).join(",");
  }
  eachCursor(cursor, list, level = 0) {
    level++;
    if (cursor instanceof Array) {
      cursor.forEach((item) => this.eachCursor(item, list, level));
    } else {
      const custom = typeof cursor === "string" && Cursor.get(cursor);
      if (custom && level < 2) {
        this.eachCursor(custom, list, level);
      } else {
        list.push(cursor);
      }
    }
  }
  destroy() {
    if (this.view) {
      super.destroy();
      this.view = null;
      this.touches = null;
    }
  }
};
function fillText(ui, canvas2) {
  let row2;
  const { rows: rows2, decorationY, decorationHeight } = ui.__.__textDrawData;
  for (let i = 0, len = rows2.length; i < len; i++) {
    row2 = rows2[i];
    if (row2.text)
      canvas2.fillText(row2.text, row2.x, row2.y);
    else if (row2.data)
      row2.data.forEach((charData) => {
        canvas2.fillText(charData.char, charData.x, row2.y);
      });
    if (decorationY)
      canvas2.fillRect(row2.x, row2.y + decorationY, row2.width, decorationHeight);
  }
}
function fill(fill2, ui, canvas2) {
  canvas2.fillStyle = fill2;
  ui.__.__font ? fillText(ui, canvas2) : ui.__.windingRule ? canvas2.fill(ui.__.windingRule) : canvas2.fill();
}
function fills(fills2, ui, canvas2) {
  let item;
  const { windingRule, __font } = ui.__;
  for (let i = 0, len = fills2.length; i < len; i++) {
    item = fills2[i];
    if (item.image && PaintImage.checkImage(ui, canvas2, item, !__font))
      continue;
    if (item.style) {
      canvas2.fillStyle = item.style;
      if (item.transform) {
        canvas2.save();
        canvas2.transform(item.transform);
        if (item.blendMode)
          canvas2.blendMode = item.blendMode;
        __font ? fillText(ui, canvas2) : windingRule ? canvas2.fill(windingRule) : canvas2.fill();
        canvas2.restore();
      } else {
        if (item.blendMode) {
          canvas2.saveBlendMode(item.blendMode);
          __font ? fillText(ui, canvas2) : windingRule ? canvas2.fill(windingRule) : canvas2.fill();
          canvas2.restoreBlendMode();
        } else {
          __font ? fillText(ui, canvas2) : windingRule ? canvas2.fill(windingRule) : canvas2.fill();
        }
      }
    }
  }
}
function strokeText(stroke2, ui, canvas2) {
  const { strokeAlign } = ui.__;
  const isStrokes = typeof stroke2 !== "string";
  switch (strokeAlign) {
    case "center":
      canvas2.setStroke(isStrokes ? void 0 : stroke2, ui.__.strokeWidth, ui.__);
      isStrokes ? drawStrokesStyle(stroke2, true, ui, canvas2) : drawTextStroke(ui, canvas2);
      break;
    case "inside":
      drawAlignStroke("inside", stroke2, isStrokes, ui, canvas2);
      break;
    case "outside":
      drawAlignStroke("outside", stroke2, isStrokes, ui, canvas2);
      break;
  }
}
function drawAlignStroke(align, stroke2, isStrokes, ui, canvas2) {
  const { __strokeWidth, __font } = ui.__;
  const out = canvas2.getSameCanvas(true, true);
  out.setStroke(isStrokes ? void 0 : stroke2, __strokeWidth * 2, ui.__);
  out.font = __font;
  isStrokes ? drawStrokesStyle(stroke2, true, ui, out) : drawTextStroke(ui, out);
  out.blendMode = align === "outside" ? "destination-out" : "destination-in";
  fillText(ui, out);
  out.blendMode = "normal";
  if (ui.__worldFlipped)
    canvas2.copyWorldByReset(out, ui.__nowWorld);
  else
    canvas2.copyWorldToInner(out, ui.__nowWorld, ui.__layout.renderBounds);
  out.recycle(ui.__nowWorld);
}
function drawTextStroke(ui, canvas2) {
  let row2;
  const { rows: rows2, decorationY, decorationHeight } = ui.__.__textDrawData;
  for (let i = 0, len = rows2.length; i < len; i++) {
    row2 = rows2[i];
    if (row2.text)
      canvas2.strokeText(row2.text, row2.x, row2.y);
    else if (row2.data)
      row2.data.forEach((charData) => {
        canvas2.strokeText(charData.char, charData.x, row2.y);
      });
    if (decorationY)
      canvas2.strokeRect(row2.x, row2.y + decorationY, row2.width, decorationHeight);
  }
}
function drawStrokesStyle(strokes2, isText, ui, canvas2) {
  let item;
  for (let i = 0, len = strokes2.length; i < len; i++) {
    item = strokes2[i];
    if (item.image && PaintImage.checkImage(ui, canvas2, item, false))
      continue;
    if (item.style) {
      canvas2.strokeStyle = item.style;
      if (item.blendMode) {
        canvas2.saveBlendMode(item.blendMode);
        isText ? drawTextStroke(ui, canvas2) : canvas2.stroke();
        canvas2.restoreBlendMode();
      } else {
        isText ? drawTextStroke(ui, canvas2) : canvas2.stroke();
      }
    }
  }
}
function stroke(stroke2, ui, canvas2) {
  const options = ui.__;
  const { __strokeWidth, strokeAlign, __font } = options;
  if (!__strokeWidth)
    return;
  if (__font) {
    strokeText(stroke2, ui, canvas2);
  } else {
    switch (strokeAlign) {
      case "center":
        canvas2.setStroke(stroke2, __strokeWidth, options);
        canvas2.stroke();
        break;
      case "inside":
        canvas2.save();
        canvas2.setStroke(stroke2, __strokeWidth * 2, options);
        options.windingRule ? canvas2.clip(options.windingRule) : canvas2.clip();
        canvas2.stroke();
        canvas2.restore();
        break;
      case "outside":
        const out = canvas2.getSameCanvas(true, true);
        out.setStroke(stroke2, __strokeWidth * 2, options);
        ui.__drawRenderPath(out);
        out.stroke();
        options.windingRule ? out.clip(options.windingRule) : out.clip();
        out.clearWorld(ui.__layout.renderBounds);
        if (ui.__worldFlipped)
          canvas2.copyWorldByReset(out, ui.__nowWorld);
        else
          canvas2.copyWorldToInner(out, ui.__nowWorld, ui.__layout.renderBounds);
        out.recycle(ui.__nowWorld);
        break;
    }
  }
}
function strokes(strokes2, ui, canvas2) {
  const options = ui.__;
  const { __strokeWidth, strokeAlign, __font } = options;
  if (!__strokeWidth)
    return;
  if (__font) {
    strokeText(strokes2, ui, canvas2);
  } else {
    switch (strokeAlign) {
      case "center":
        canvas2.setStroke(void 0, __strokeWidth, options);
        drawStrokesStyle(strokes2, false, ui, canvas2);
        break;
      case "inside":
        canvas2.save();
        canvas2.setStroke(void 0, __strokeWidth * 2, options);
        options.windingRule ? canvas2.clip(options.windingRule) : canvas2.clip();
        drawStrokesStyle(strokes2, false, ui, canvas2);
        canvas2.restore();
        break;
      case "outside":
        const { renderBounds } = ui.__layout;
        const out = canvas2.getSameCanvas(true, true);
        ui.__drawRenderPath(out);
        out.setStroke(void 0, __strokeWidth * 2, options);
        drawStrokesStyle(strokes2, false, ui, out);
        options.windingRule ? out.clip(options.windingRule) : out.clip();
        out.clearWorld(renderBounds);
        if (ui.__worldFlipped)
          canvas2.copyWorldByReset(out, ui.__nowWorld);
        else
          canvas2.copyWorldToInner(out, ui.__nowWorld, renderBounds);
        out.recycle(ui.__nowWorld);
        break;
    }
  }
}
var { getSpread, getOuterOf, getByMove, getIntersectData } = BoundsHelper;
function shape(ui, current, options) {
  const canvas2 = current.getSameCanvas();
  const nowWorld = ui.__nowWorld;
  let bounds2, fitMatrix, shapeBounds, worldCanvas;
  let { scaleX, scaleY } = nowWorld;
  if (scaleX < 0)
    scaleX = -scaleX;
  if (scaleY < 0)
    scaleY = -scaleY;
  if (current.bounds.includes(nowWorld)) {
    worldCanvas = canvas2;
    bounds2 = shapeBounds = nowWorld;
  } else {
    const { renderShapeSpread: spread } = ui.__layout;
    const worldClipBounds = getIntersectData(spread ? getSpread(current.bounds, scaleX === scaleY ? spread * scaleX : [spread * scaleY, spread * scaleX]) : current.bounds, nowWorld);
    fitMatrix = current.bounds.getFitMatrix(worldClipBounds);
    let { a: fitScaleX, d: fitScaleY } = fitMatrix;
    if (fitMatrix.a < 1) {
      worldCanvas = current.getSameCanvas();
      ui.__renderShape(worldCanvas, options);
      scaleX *= fitScaleX;
      scaleY *= fitScaleY;
    }
    shapeBounds = getOuterOf(nowWorld, fitMatrix);
    bounds2 = getByMove(shapeBounds, -fitMatrix.e, -fitMatrix.f);
    if (options.matrix) {
      const { matrix } = options;
      fitMatrix.multiply(matrix);
      fitScaleX *= matrix.scaleX;
      fitScaleY *= matrix.scaleY;
    }
    options = Object.assign(Object.assign({}, options), { matrix: fitMatrix.withScale(fitScaleX, fitScaleY) });
  }
  ui.__renderShape(canvas2, options);
  return {
    canvas: canvas2,
    matrix: fitMatrix,
    bounds: bounds2,
    worldCanvas,
    shapeBounds,
    scaleX,
    scaleY
  };
}
var recycleMap;
function compute(attrName, ui) {
  const data = ui.__, leafPaints = [];
  let paints = data.__input[attrName], hasOpacityPixel;
  if (!(paints instanceof Array))
    paints = [paints];
  recycleMap = PaintImage.recycleImage(attrName, data);
  for (let i = 0, len = paints.length, item; i < len; i++) {
    item = getLeafPaint(attrName, paints[i], ui);
    if (item)
      leafPaints.push(item);
  }
  data["_" + attrName] = leafPaints.length ? leafPaints : void 0;
  if (leafPaints.length && leafPaints[0].image)
    hasOpacityPixel = leafPaints[0].image.hasOpacityPixel;
  attrName === "fill" ? data.__pixelFill = hasOpacityPixel : data.__pixelStroke = hasOpacityPixel;
}
function getLeafPaint(attrName, paint, ui) {
  if (typeof paint !== "object" || paint.visible === false || paint.opacity === 0)
    return void 0;
  const { boxBounds } = ui.__layout;
  switch (paint.type) {
    case "solid":
      let { type, blendMode, color, opacity } = paint;
      return { type, blendMode, style: ColorConvert.string(color, opacity) };
    case "image":
      return PaintImage.image(ui, attrName, paint, boxBounds, !recycleMap || !recycleMap[paint.url]);
    case "linear":
      return PaintGradient.linearGradient(paint, boxBounds);
    case "radial":
      return PaintGradient.radialGradient(paint, boxBounds);
    case "angular":
      return PaintGradient.conicGradient(paint, boxBounds);
    default:
      return paint.r !== void 0 ? { type: "solid", style: ColorConvert.string(paint) } : void 0;
  }
}
var PaintModule = {
  compute,
  fill,
  fills,
  fillText,
  stroke,
  strokes,
  strokeText,
  drawTextStroke,
  shape
};
var origin = {};
var { get: get$3, rotateOfOuter: rotateOfOuter$1, translate: translate$1, scaleOfOuter: scaleOfOuter$1, scale: scaleHelper, rotate } = MatrixHelper;
function fillOrFitMode(data, box2, x, y, scaleX, scaleY, rotation) {
  const transform = get$3();
  translate$1(transform, box2.x + x, box2.y + y);
  scaleHelper(transform, scaleX, scaleY);
  if (rotation)
    rotateOfOuter$1(transform, { x: box2.x + box2.width / 2, y: box2.y + box2.height / 2 }, rotation);
  data.transform = transform;
}
function clipMode(data, box2, x, y, scaleX, scaleY, rotation) {
  const transform = get$3();
  translate$1(transform, box2.x + x, box2.y + y);
  if (scaleX)
    scaleHelper(transform, scaleX, scaleY);
  if (rotation)
    rotate(transform, rotation);
  data.transform = transform;
}
function repeatMode(data, box2, width, height, x, y, scaleX, scaleY, rotation, align) {
  const transform = get$3();
  if (rotation) {
    if (align === "center") {
      rotateOfOuter$1(transform, { x: width / 2, y: height / 2 }, rotation);
    } else {
      rotate(transform, rotation);
      switch (rotation) {
        case 90:
          translate$1(transform, height, 0);
          break;
        case 180:
          translate$1(transform, width, height);
          break;
        case 270:
          translate$1(transform, 0, width);
          break;
      }
    }
  }
  origin.x = box2.x + x;
  origin.y = box2.y + y;
  translate$1(transform, origin.x, origin.y);
  if (scaleX)
    scaleOfOuter$1(transform, origin, scaleX, scaleY);
  data.transform = transform;
}
var { get: get$2, translate } = MatrixHelper;
var tempBox = new Bounds();
var tempPoint = {};
var tempScaleData = {};
function createData(leafPaint, image2, paint, box2) {
  const { blendMode, sync } = paint;
  if (blendMode)
    leafPaint.blendMode = blendMode;
  if (sync)
    leafPaint.sync = sync;
  leafPaint.data = getPatternData(paint, box2, image2);
}
function getPatternData(paint, box2, image2) {
  let { width, height } = image2;
  if (paint.padding)
    box2 = tempBox.set(box2).shrink(paint.padding);
  if (paint.mode === "strench")
    paint.mode = "stretch";
  const { opacity, mode, align, offset, scale: scale2, size, rotation, repeat } = paint;
  const sameBox = box2.width === width && box2.height === height;
  const data = { mode };
  const swapSize = align !== "center" && (rotation || 0) % 180 === 90;
  const swapWidth = swapSize ? height : width, swapHeight = swapSize ? width : height;
  let x = 0, y = 0, scaleX, scaleY;
  if (!mode || mode === "cover" || mode === "fit") {
    if (!sameBox || rotation) {
      const sw = box2.width / swapWidth, sh = box2.height / swapHeight;
      scaleX = scaleY = mode === "fit" ? Math.min(sw, sh) : Math.max(sw, sh);
      x += (box2.width - width * scaleX) / 2, y += (box2.height - height * scaleY) / 2;
    }
  } else if (scale2 || size) {
    MathHelper.getScaleData(scale2, size, image2, tempScaleData);
    scaleX = tempScaleData.scaleX;
    scaleY = tempScaleData.scaleY;
  }
  if (align) {
    const imageBounds = { x, y, width: swapWidth, height: swapHeight };
    if (scaleX)
      imageBounds.width *= scaleX, imageBounds.height *= scaleY;
    AlignHelper.toPoint(align, imageBounds, box2, tempPoint, true);
    x += tempPoint.x, y += tempPoint.y;
  }
  if (offset)
    x += offset.x, y += offset.y;
  switch (mode) {
    case "stretch":
      if (!sameBox)
        width = box2.width, height = box2.height;
      break;
    case "normal":
    case "clip":
      if (x || y || scaleX || rotation)
        clipMode(data, box2, x, y, scaleX, scaleY, rotation);
      break;
    case "repeat":
      if (!sameBox || scaleX || rotation)
        repeatMode(data, box2, width, height, x, y, scaleX, scaleY, rotation, align);
      if (!repeat)
        data.repeat = "repeat";
      break;
    case "fit":
    case "cover":
    default:
      if (scaleX)
        fillOrFitMode(data, box2, x, y, scaleX, scaleY, rotation);
  }
  if (!data.transform) {
    if (box2.x || box2.y) {
      data.transform = get$2();
      translate(data.transform, box2.x, box2.y);
    }
  }
  if (scaleX && mode !== "stretch") {
    data.scaleX = scaleX;
    data.scaleY = scaleY;
  }
  data.width = width;
  data.height = height;
  if (opacity)
    data.opacity = opacity;
  if (repeat)
    data.repeat = typeof repeat === "string" ? repeat === "x" ? "repeat-x" : "repeat-y" : "repeat";
  return data;
}
var cache;
var box = new Bounds();
var { isSame } = BoundsHelper;
function image(ui, attrName, paint, boxBounds, firstUse) {
  let leafPaint, event;
  const image2 = ImageManager.get(paint);
  if (cache && paint === cache.paint && isSame(boxBounds, cache.boxBounds)) {
    leafPaint = cache.leafPaint;
  } else {
    leafPaint = { type: paint.type, image: image2 };
    cache = image2.use > 1 ? { leafPaint, paint, boxBounds: box.set(boxBounds) } : null;
  }
  if (firstUse || image2.loading)
    event = { image: image2, attrName, attrValue: paint };
  if (image2.ready) {
    checkSizeAndCreateData(ui, attrName, paint, image2, leafPaint, boxBounds);
    if (firstUse) {
      onLoad(ui, event);
      onLoadSuccess(ui, event);
    }
  } else if (image2.error) {
    if (firstUse)
      onLoadError(ui, event, image2.error);
  } else {
    if (firstUse) {
      ignoreRender(ui, true);
      onLoad(ui, event);
    }
    leafPaint.loadId = image2.load(() => {
      ignoreRender(ui, false);
      if (!ui.destroyed) {
        if (checkSizeAndCreateData(ui, attrName, paint, image2, leafPaint, boxBounds)) {
          if (image2.hasOpacityPixel)
            ui.__layout.hitCanvasChanged = true;
          ui.forceUpdate("surface");
        }
        onLoadSuccess(ui, event);
      }
      leafPaint.loadId = null;
    }, (error) => {
      ignoreRender(ui, false);
      onLoadError(ui, event, error);
      leafPaint.loadId = null;
    });
  }
  return leafPaint;
}
function checkSizeAndCreateData(ui, attrName, paint, image2, leafPaint, boxBounds) {
  if (attrName === "fill" && !ui.__.__naturalWidth) {
    const data = ui.__;
    data.__naturalWidth = image2.width / data.pixelRatio;
    data.__naturalHeight = image2.height / data.pixelRatio;
    if (data.__autoSide) {
      ui.forceUpdate("width");
      if (ui.__proxyData) {
        ui.setProxyAttr("width", data.width);
        ui.setProxyAttr("height", data.height);
      }
      return false;
    }
  }
  if (!leafPaint.data)
    createData(leafPaint, image2, paint, boxBounds);
  return true;
}
function onLoad(ui, event) {
  emit(ui, ImageEvent.LOAD, event);
}
function onLoadSuccess(ui, event) {
  emit(ui, ImageEvent.LOADED, event);
}
function onLoadError(ui, event, error) {
  event.error = error;
  ui.forceUpdate("surface");
  emit(ui, ImageEvent.ERROR, event);
}
function emit(ui, type, data) {
  if (ui.hasEvent(type))
    ui.emitEvent(new ImageEvent(type, data));
}
function ignoreRender(ui, value) {
  const { leafer } = ui;
  if (leafer && leafer.viewReady)
    leafer.renderer.ignore = value;
}
var { get: get$1, scale, copy: copy$1 } = MatrixHelper;
var { ceil, abs: abs$1 } = Math;
function createPattern(ui, paint, pixelRatio) {
  let { scaleX, scaleY } = ImageManager.patternLocked ? ui.__world : ui.__nowWorld;
  const id = scaleX + "-" + scaleY + "-" + pixelRatio;
  if (paint.patternId !== id && !ui.destroyed) {
    scaleX = abs$1(scaleX);
    scaleY = abs$1(scaleY);
    const { image: image2, data } = paint;
    let imageScale, imageMatrix, { width, height, scaleX: sx, scaleY: sy, opacity, transform, repeat } = data;
    if (sx) {
      imageMatrix = get$1();
      copy$1(imageMatrix, transform);
      scale(imageMatrix, 1 / sx, 1 / sy);
      scaleX *= sx;
      scaleY *= sy;
    }
    scaleX *= pixelRatio;
    scaleY *= pixelRatio;
    width *= scaleX;
    height *= scaleY;
    const size = width * height;
    if (!repeat) {
      if (size > Platform.image.maxCacheSize)
        return false;
    }
    let maxSize = Platform.image.maxPatternSize;
    if (!image2.isSVG) {
      const imageSize = image2.width * image2.height;
      if (maxSize > imageSize)
        maxSize = imageSize;
    }
    if (size > maxSize)
      imageScale = Math.sqrt(size / maxSize);
    if (imageScale) {
      scaleX /= imageScale;
      scaleY /= imageScale;
      width /= imageScale;
      height /= imageScale;
    }
    if (sx) {
      scaleX /= sx;
      scaleY /= sy;
    }
    if (transform || scaleX !== 1 || scaleY !== 1) {
      if (!imageMatrix) {
        imageMatrix = get$1();
        if (transform)
          copy$1(imageMatrix, transform);
      }
      scale(imageMatrix, 1 / scaleX, 1 / scaleY);
    }
    const canvas2 = image2.getCanvas(ceil(width) || 1, ceil(height) || 1, opacity);
    const pattern = image2.getPattern(canvas2, repeat || (Platform.origin.noRepeat || "no-repeat"), imageMatrix, paint);
    paint.style = pattern;
    paint.patternId = id;
    return true;
  } else {
    return false;
  }
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
var { abs } = Math;
function checkImage(ui, canvas2, paint, allowPaint) {
  const { scaleX, scaleY } = ImageManager.patternLocked ? ui.__world : ui.__nowWorld;
  const { pixelRatio } = canvas2;
  if (!paint.data || paint.patternId === scaleX + "-" + scaleY + "-" + pixelRatio && !Export.running) {
    return false;
  } else {
    const { data } = paint;
    if (allowPaint) {
      if (!data.repeat) {
        let { width, height } = data;
        width *= abs(scaleX) * pixelRatio;
        height *= abs(scaleY) * pixelRatio;
        if (data.scaleX) {
          width *= data.scaleX;
          height *= data.scaleY;
        }
        allowPaint = width * height > Platform.image.maxCacheSize || Export.running;
      } else {
        allowPaint = false;
      }
    }
    if (allowPaint) {
      canvas2.save();
      ui.windingRule ? canvas2.clip(ui.windingRule) : canvas2.clip();
      if (paint.blendMode)
        canvas2.blendMode = paint.blendMode;
      if (data.opacity)
        canvas2.opacity *= data.opacity;
      if (data.transform)
        canvas2.transform(data.transform);
      canvas2.drawImage(paint.image.view, 0, 0, data.width, data.height);
      canvas2.restore();
      return true;
    } else {
      if (!paint.style || paint.sync || Export.running) {
        createPattern(ui, paint, pixelRatio);
      } else {
        if (!paint.patternTask) {
          paint.patternTask = ImageManager.patternTasker.add(() => __awaiter(this, void 0, void 0, function* () {
            paint.patternTask = null;
            if (canvas2.bounds.hit(ui.__nowWorld))
              createPattern(ui, paint, pixelRatio);
            ui.forceUpdate("surface");
          }), 300);
        }
      }
      return false;
    }
  }
}
function recycleImage(attrName, data) {
  const paints = data["_" + attrName];
  if (paints instanceof Array) {
    let image2, recycleMap2, input, url;
    for (let i = 0, len = paints.length; i < len; i++) {
      image2 = paints[i].image;
      url = image2 && image2.url;
      if (url) {
        if (!recycleMap2)
          recycleMap2 = {};
        recycleMap2[url] = true;
        ImageManager.recycle(image2);
        if (image2.loading) {
          if (!input) {
            input = data.__input && data.__input[attrName] || [];
            if (!(input instanceof Array))
              input = [input];
          }
          image2.unload(paints[i].loadId, !input.some((item) => item.url === url));
        }
      }
    }
    return recycleMap2;
  }
  return null;
}
var PaintImageModule = {
  image,
  checkImage,
  createPattern,
  recycleImage,
  createData,
  getPatternData,
  fillOrFitMode,
  clipMode,
  repeatMode
};
var { toPoint: toPoint$2 } = AroundHelper;
var realFrom$2 = {};
var realTo$2 = {};
function linearGradient(paint, box2) {
  let { from, to, type, blendMode, opacity } = paint;
  toPoint$2(from || "top", box2, realFrom$2);
  toPoint$2(to || "bottom", box2, realTo$2);
  const style = Platform.canvas.createLinearGradient(realFrom$2.x, realFrom$2.y, realTo$2.x, realTo$2.y);
  applyStops(style, paint.stops, opacity);
  const data = { type, style };
  if (blendMode)
    data.blendMode = blendMode;
  return data;
}
function applyStops(gradient, stops, opacity) {
  if (stops) {
    let stop;
    for (let i = 0, len = stops.length; i < len; i++) {
      stop = stops[i];
      if (typeof stop === "string") {
        gradient.addColorStop(i / (len - 1), ColorConvert.string(stop, opacity));
      } else {
        gradient.addColorStop(stop.offset, ColorConvert.string(stop.color, opacity));
      }
    }
  }
}
var { getAngle, getDistance: getDistance$1 } = PointHelper;
var { get, rotateOfOuter, scaleOfOuter } = MatrixHelper;
var { toPoint: toPoint$1 } = AroundHelper;
var realFrom$1 = {};
var realTo$1 = {};
function radialGradient(paint, box2) {
  let { from, to, type, opacity, blendMode, stretch } = paint;
  toPoint$1(from || "center", box2, realFrom$1);
  toPoint$1(to || "bottom", box2, realTo$1);
  const style = Platform.canvas.createRadialGradient(realFrom$1.x, realFrom$1.y, 0, realFrom$1.x, realFrom$1.y, getDistance$1(realFrom$1, realTo$1));
  applyStops(style, paint.stops, opacity);
  const data = { type, style };
  const transform = getTransform(box2, realFrom$1, realTo$1, stretch, true);
  if (transform)
    data.transform = transform;
  if (blendMode)
    data.blendMode = blendMode;
  return data;
}
function getTransform(box2, from, to, stretch, rotate90) {
  let transform;
  const { width, height } = box2;
  if (width !== height || stretch) {
    const angle = getAngle(from, to);
    transform = get();
    if (rotate90) {
      scaleOfOuter(transform, from, width / height * (stretch || 1), 1);
      rotateOfOuter(transform, from, angle + 90);
    } else {
      scaleOfOuter(transform, from, 1, width / height * (stretch || 1));
      rotateOfOuter(transform, from, angle);
    }
  }
  return transform;
}
var { getDistance } = PointHelper;
var { toPoint } = AroundHelper;
var realFrom = {};
var realTo = {};
function conicGradient(paint, box2) {
  let { from, to, type, opacity, blendMode, stretch } = paint;
  toPoint(from || "center", box2, realFrom);
  toPoint(to || "bottom", box2, realTo);
  const style = Platform.conicGradientSupport ? Platform.canvas.createConicGradient(0, realFrom.x, realFrom.y) : Platform.canvas.createRadialGradient(realFrom.x, realFrom.y, 0, realFrom.x, realFrom.y, getDistance(realFrom, realTo));
  applyStops(style, paint.stops, opacity);
  const data = { type, style };
  const transform = getTransform(box2, realFrom, realTo, stretch || 1, Platform.conicGradientRotate90);
  if (transform)
    data.transform = transform;
  if (blendMode)
    data.blendMode = blendMode;
  return data;
}
var PaintGradientModule = {
  linearGradient,
  radialGradient,
  conicGradient,
  getTransform
};
var { copy, toOffsetOutBounds: toOffsetOutBounds$1 } = BoundsHelper;
var tempBounds = {};
var offsetOutBounds$1 = {};
function shadow(ui, current, shape2) {
  let copyBounds, spreadScale;
  const { __nowWorld: nowWorld, __layout } = ui;
  const { shadow: shadow2 } = ui.__;
  const { worldCanvas, bounds: bounds2, shapeBounds, scaleX, scaleY } = shape2;
  const other = current.getSameCanvas();
  const end = shadow2.length - 1;
  toOffsetOutBounds$1(bounds2, offsetOutBounds$1);
  shadow2.forEach((item, index) => {
    other.setWorldShadow(offsetOutBounds$1.offsetX + item.x * scaleX, offsetOutBounds$1.offsetY + item.y * scaleY, item.blur * scaleX, item.color);
    spreadScale = item.spread ? 1 + item.spread * 2 / (__layout.boxBounds.width + (__layout.strokeBoxSpread || 0) * 2) : 0;
    drawWorldShadow(other, offsetOutBounds$1, spreadScale, shape2);
    copyBounds = bounds2;
    if (item.box) {
      other.restore();
      other.save();
      if (worldCanvas) {
        other.copyWorld(other, bounds2, nowWorld, "copy");
        copyBounds = nowWorld;
      }
      worldCanvas ? other.copyWorld(worldCanvas, nowWorld, nowWorld, "destination-out") : other.copyWorld(shape2.canvas, shapeBounds, bounds2, "destination-out");
    }
    if (ui.__worldFlipped) {
      current.copyWorldByReset(other, copyBounds, nowWorld, item.blendMode);
    } else {
      current.copyWorldToInner(other, copyBounds, __layout.renderBounds, item.blendMode);
    }
    if (end && index < end)
      other.clearWorld(copyBounds, true);
  });
  other.recycle(copyBounds);
}
function drawWorldShadow(canvas2, outBounds, spreadScale, shape2) {
  const { bounds: bounds2, shapeBounds } = shape2;
  if (Platform.fullImageShadow) {
    copy(tempBounds, canvas2.bounds);
    tempBounds.x += outBounds.x - shapeBounds.x;
    tempBounds.y += outBounds.y - shapeBounds.y;
    if (spreadScale) {
      const { matrix } = shape2;
      tempBounds.x -= (bounds2.x + (matrix ? matrix.e : 0) + bounds2.width / 2) * (spreadScale - 1);
      tempBounds.y -= (bounds2.y + (matrix ? matrix.f : 0) + bounds2.height / 2) * (spreadScale - 1);
      tempBounds.width *= spreadScale;
      tempBounds.height *= spreadScale;
    }
    canvas2.copyWorld(shape2.canvas, canvas2.bounds, tempBounds);
  } else {
    if (spreadScale) {
      copy(tempBounds, outBounds);
      tempBounds.x -= outBounds.width / 2 * (spreadScale - 1);
      tempBounds.y -= outBounds.height / 2 * (spreadScale - 1);
      tempBounds.width *= spreadScale;
      tempBounds.height *= spreadScale;
    }
    canvas2.copyWorld(shape2.canvas, shapeBounds, spreadScale ? tempBounds : outBounds);
  }
}
var { toOffsetOutBounds } = BoundsHelper;
var offsetOutBounds = {};
function innerShadow(ui, current, shape2) {
  let copyBounds, spreadScale;
  const { __nowWorld: nowWorld, __layout } = ui;
  const { innerShadow: innerShadow2 } = ui.__;
  const { worldCanvas, bounds: bounds2, shapeBounds, scaleX, scaleY } = shape2;
  const other = current.getSameCanvas();
  const end = innerShadow2.length - 1;
  toOffsetOutBounds(bounds2, offsetOutBounds);
  innerShadow2.forEach((item, index) => {
    other.save();
    other.setWorldShadow(offsetOutBounds.offsetX + item.x * scaleX, offsetOutBounds.offsetY + item.y * scaleY, item.blur * scaleX);
    spreadScale = item.spread ? 1 - item.spread * 2 / (__layout.boxBounds.width + (__layout.strokeBoxSpread || 0) * 2) : 0;
    drawWorldShadow(other, offsetOutBounds, spreadScale, shape2);
    other.restore();
    if (worldCanvas) {
      other.copyWorld(other, bounds2, nowWorld, "copy");
      other.copyWorld(worldCanvas, nowWorld, nowWorld, "source-out");
      copyBounds = nowWorld;
    } else {
      other.copyWorld(shape2.canvas, shapeBounds, bounds2, "source-out");
      copyBounds = bounds2;
    }
    other.fillWorld(copyBounds, item.color, "source-in");
    if (ui.__worldFlipped) {
      current.copyWorldByReset(other, copyBounds, nowWorld, item.blendMode);
    } else {
      current.copyWorldToInner(other, copyBounds, __layout.renderBounds, item.blendMode);
    }
    if (end && index < end)
      other.clearWorld(copyBounds, true);
  });
  other.recycle(copyBounds);
}
function blur(ui, current, origin2) {
  const { blur: blur2 } = ui.__;
  origin2.setWorldBlur(blur2 * ui.__nowWorld.a);
  origin2.copyWorldToInner(current, ui.__nowWorld, ui.__layout.renderBounds);
  origin2.filter = "none";
}
function backgroundBlur(_ui, _current, _shape) {
}
var EffectModule = {
  shadow,
  innerShadow,
  blur,
  backgroundBlur
};
var { excludeRenderBounds } = LeafBoundsHelper;
Group.prototype.__renderMask = function(canvas2, options) {
  let child, maskCanvas, contentCanvas, maskOpacity, currentMask, mask;
  const { children } = this;
  for (let i = 0, len = children.length; i < len; i++) {
    child = children[i], mask = child.__.mask;
    if (mask) {
      if (currentMask) {
        maskEnd(this, currentMask, canvas2, contentCanvas, maskCanvas, maskOpacity);
        maskCanvas = contentCanvas = null;
      }
      if (mask === "path" || mask === "clipping-path") {
        if (child.opacity < 1) {
          currentMask = "opacity-path";
          maskOpacity = child.opacity;
          if (!contentCanvas)
            contentCanvas = getCanvas(canvas2);
        } else {
          currentMask = "path";
          canvas2.save();
        }
        child.__clip(contentCanvas || canvas2, options);
      } else {
        currentMask = mask === "grayscale" ? "grayscale" : "alpha";
        if (!maskCanvas)
          maskCanvas = getCanvas(canvas2);
        if (!contentCanvas)
          contentCanvas = getCanvas(canvas2);
        child.__render(maskCanvas, options);
      }
      if (!(mask === "clipping" || mask === "clipping-path"))
        continue;
    }
    if (excludeRenderBounds(child, options))
      continue;
    child.__render(contentCanvas || canvas2, options);
  }
  maskEnd(this, currentMask, canvas2, contentCanvas, maskCanvas, maskOpacity);
};
function maskEnd(leaf, maskMode, canvas2, contentCanvas, maskCanvas, maskOpacity) {
  switch (maskMode) {
    case "grayscale":
      maskCanvas.useGrayscaleAlpha(leaf.__nowWorld);
    case "alpha":
      usePixelMask(leaf, canvas2, contentCanvas, maskCanvas);
      break;
    case "opacity-path":
      copyContent(leaf, canvas2, contentCanvas, maskOpacity);
      break;
    case "path":
      canvas2.restore();
  }
}
function getCanvas(canvas2) {
  return canvas2.getSameCanvas(false, true);
}
function usePixelMask(leaf, canvas2, content, mask) {
  const realBounds = leaf.__nowWorld;
  content.resetTransform();
  content.opacity = 1;
  content.useMask(mask, realBounds);
  mask.recycle(realBounds);
  copyContent(leaf, canvas2, content, 1);
}
function copyContent(leaf, canvas2, content, maskOpacity) {
  const realBounds = leaf.__nowWorld;
  canvas2.resetTransform();
  canvas2.opacity = maskOpacity;
  canvas2.copyWorld(content, realBounds);
  content.recycle(realBounds);
}
var money = "";
var letter = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz";
var langBefore = "" + money;
var langAfter = "";
var langSymbol = "";
var langBreak$1 = "";
var beforeChar = `{[(<'"` + langBefore;
var afterChar = `>)]}%!?,.:;'"` + langAfter;
var symbolChar = afterChar + "_#~&*+\\=|" + langSymbol;
var breakChar = "- " + langBreak$1;
var cjkRangeList = [
  [19968, 40959],
  [13312, 19903],
  [131072, 173791],
  [173824, 177983],
  [177984, 178207],
  [178208, 183983],
  [183984, 191471],
  [196608, 201551],
  [201552, 205743],
  [11904, 12031],
  [12032, 12255],
  [12272, 12287],
  [12288, 12351],
  [12736, 12783],
  [12800, 13055],
  [13056, 13311],
  [63744, 64255],
  [65072, 65103],
  [127488, 127743],
  [194560, 195103]
];
var cjkReg = new RegExp(cjkRangeList.map(([start, end]) => `[\\u${start.toString(16)}-\\u${end.toString(16)}]`).join("|"));
function mapChar(str) {
  const map = {};
  str.split("").forEach((char2) => map[char2] = true);
  return map;
}
var letterMap = mapChar(letter);
var beforeMap = mapChar(beforeChar);
var afterMap = mapChar(afterChar);
var symbolMap = mapChar(symbolChar);
var breakMap = mapChar(breakChar);
var CharType;
(function(CharType2) {
  CharType2[CharType2["Letter"] = 0] = "Letter";
  CharType2[CharType2["Single"] = 1] = "Single";
  CharType2[CharType2["Before"] = 2] = "Before";
  CharType2[CharType2["After"] = 3] = "After";
  CharType2[CharType2["Symbol"] = 4] = "Symbol";
  CharType2[CharType2["Break"] = 5] = "Break";
})(CharType || (CharType = {}));
var { Letter: Letter$1, Single: Single$1, Before: Before$1, After: After$1, Symbol: Symbol$1, Break: Break$1 } = CharType;
function getCharType(char2) {
  if (letterMap[char2]) {
    return Letter$1;
  } else if (breakMap[char2]) {
    return Break$1;
  } else if (beforeMap[char2]) {
    return Before$1;
  } else if (afterMap[char2]) {
    return After$1;
  } else if (symbolMap[char2]) {
    return Symbol$1;
  } else if (cjkReg.test(char2)) {
    return Single$1;
  } else {
    return Letter$1;
  }
}
var TextRowHelper = {
  trimRight(row2) {
    const { words } = row2;
    let trimRight2 = 0, len = words.length, char2;
    for (let i = len - 1; i > -1; i--) {
      char2 = words[i].data[0];
      if (char2.char === " ") {
        trimRight2++;
        row2.width -= char2.width;
      } else {
        break;
      }
    }
    if (trimRight2)
      words.splice(len - trimRight2, trimRight2);
  }
};
function getTextCase(char2, textCase, firstChar) {
  switch (textCase) {
    case "title":
      return firstChar ? char2.toUpperCase() : char2;
    case "upper":
      return char2.toUpperCase();
    case "lower":
      return char2.toLowerCase();
    default:
      return char2;
  }
}
var { trimRight } = TextRowHelper;
var { Letter, Single, Before, After, Symbol, Break } = CharType;
var word;
var row;
var wordWidth;
var rowWidth;
var realWidth;
var char;
var charWidth;
var startCharSize;
var charSize;
var charType;
var lastCharType;
var langBreak;
var afterBreak;
var paraStart;
var textDrawData;
var rows = [];
var bounds;
var findMaxWidth;
function createRows(drawData, content, style) {
  textDrawData = drawData;
  rows = drawData.rows;
  bounds = drawData.bounds;
  findMaxWidth = !bounds.width && !style.autoSizeAlign;
  const { __letterSpacing, paraIndent, textCase } = style;
  const { canvas: canvas2 } = Platform;
  const { width, height } = bounds;
  const charMode = width || height || __letterSpacing || textCase !== "none";
  if (charMode) {
    const wrap = style.textWrap !== "none";
    const breakAll = style.textWrap === "break";
    paraStart = true;
    lastCharType = null;
    startCharSize = charWidth = charSize = wordWidth = rowWidth = 0;
    word = { data: [] }, row = { words: [] };
    for (let i = 0, len = content.length; i < len; i++) {
      char = content[i];
      if (char === "\n") {
        if (wordWidth)
          addWord();
        row.paraEnd = true;
        addRow();
        paraStart = true;
      } else {
        charType = getCharType(char);
        if (charType === Letter && textCase !== "none")
          char = getTextCase(char, textCase, !wordWidth);
        charWidth = canvas2.measureText(char).width;
        if (__letterSpacing) {
          if (__letterSpacing < 0)
            charSize = charWidth;
          charWidth += __letterSpacing;
        }
        langBreak = charType === Single && (lastCharType === Single || lastCharType === Letter) || lastCharType === Single && charType !== After;
        afterBreak = (charType === Before || charType === Single) && (lastCharType === Symbol || lastCharType === After);
        realWidth = paraStart && paraIndent ? width - paraIndent : width;
        if (wrap && (width && rowWidth + wordWidth + charWidth > realWidth)) {
          if (breakAll) {
            if (wordWidth)
              addWord();
            if (rowWidth)
              addRow();
          } else {
            if (!afterBreak)
              afterBreak = charType === Letter && lastCharType == After;
            if (langBreak || afterBreak || charType === Break || charType === Before || charType === Single || wordWidth + charWidth > realWidth) {
              if (wordWidth)
                addWord();
              if (rowWidth)
                addRow();
            } else {
              if (rowWidth)
                addRow();
            }
          }
        }
        if (char === " " && paraStart !== true && rowWidth + wordWidth === 0) ;
        else {
          if (charType === Break) {
            if (char === " " && wordWidth)
              addWord();
            addChar(char, charWidth);
            addWord();
          } else if (langBreak || afterBreak) {
            if (wordWidth)
              addWord();
            addChar(char, charWidth);
          } else {
            addChar(char, charWidth);
          }
        }
        lastCharType = charType;
      }
    }
    if (wordWidth)
      addWord();
    if (rowWidth)
      addRow();
    rows.length > 0 && (rows[rows.length - 1].paraEnd = true);
  } else {
    content.split("\n").forEach((content2) => {
      textDrawData.paraNumber++;
      rowWidth = canvas2.measureText(content2).width;
      rows.push({ x: paraIndent || 0, text: content2, width: rowWidth, paraStart: true });
      if (findMaxWidth)
        setMaxWidth();
    });
  }
}
function addChar(char2, width) {
  if (charSize && !startCharSize)
    startCharSize = charSize;
  word.data.push({ char: char2, width });
  wordWidth += width;
}
function addWord() {
  rowWidth += wordWidth;
  word.width = wordWidth;
  row.words.push(word);
  word = { data: [] };
  wordWidth = 0;
}
function addRow() {
  if (paraStart) {
    textDrawData.paraNumber++;
    row.paraStart = true;
    paraStart = false;
  }
  if (charSize) {
    row.startCharSize = startCharSize;
    row.endCharSize = charSize;
    startCharSize = 0;
  }
  row.width = rowWidth;
  if (bounds.width)
    trimRight(row);
  else if (findMaxWidth)
    setMaxWidth();
  rows.push(row);
  row = { words: [] };
  rowWidth = 0;
}
function setMaxWidth() {
  if (rowWidth > (textDrawData.maxWidth || 0))
    textDrawData.maxWidth = rowWidth;
}
var CharMode = 0;
var WordMode = 1;
var TextMode = 2;
function layoutChar(drawData, style, width, _height) {
  const { rows: rows2 } = drawData;
  const { textAlign, paraIndent, letterSpacing } = style;
  let charX, addWordWidth, indentWidth, mode, wordChar;
  rows2.forEach((row2) => {
    if (row2.words) {
      indentWidth = paraIndent && row2.paraStart ? paraIndent : 0;
      addWordWidth = width && textAlign === "justify" && row2.words.length > 1 ? (width - row2.width - indentWidth) / (row2.words.length - 1) : 0;
      mode = letterSpacing || row2.isOverflow ? CharMode : addWordWidth > 0.01 ? WordMode : TextMode;
      if (row2.isOverflow && !letterSpacing)
        row2.textMode = true;
      if (mode === TextMode) {
        row2.x += indentWidth;
        toTextChar$1(row2);
      } else {
        row2.x += indentWidth;
        charX = row2.x;
        row2.data = [];
        row2.words.forEach((word2) => {
          if (mode === WordMode) {
            wordChar = { char: "", x: charX };
            charX = toWordChar(word2.data, charX, wordChar);
            if (row2.isOverflow || wordChar.char !== " ")
              row2.data.push(wordChar);
          } else {
            charX = toChar(word2.data, charX, row2.data, row2.isOverflow);
          }
          if (!row2.paraEnd && addWordWidth) {
            charX += addWordWidth;
            row2.width += addWordWidth;
          }
        });
      }
      row2.words = null;
    }
  });
}
function toTextChar$1(row2) {
  row2.text = "";
  row2.words.forEach((word2) => {
    word2.data.forEach((char2) => {
      row2.text += char2.char;
    });
  });
}
function toWordChar(data, charX, wordChar) {
  data.forEach((char2) => {
    wordChar.char += char2.char;
    charX += char2.width;
  });
  return charX;
}
function toChar(data, charX, rowData, isOverflow) {
  data.forEach((char2) => {
    if (isOverflow || char2.char !== " ") {
      char2.x = charX;
      rowData.push(char2);
    }
    charX += char2.width;
  });
  return charX;
}
function layoutText(drawData, style) {
  const { rows: rows2, bounds: bounds2 } = drawData;
  const { __lineHeight, __baseLine, __letterSpacing, __clipText, textAlign, verticalAlign, paraSpacing, autoSizeAlign } = style;
  let { x, y, width, height } = bounds2, realHeight = __lineHeight * rows2.length + (paraSpacing ? paraSpacing * (drawData.paraNumber - 1) : 0);
  let starY = __baseLine;
  if (__clipText && realHeight > height) {
    realHeight = Math.max(height, __lineHeight);
    drawData.overflow = rows2.length;
  } else if (height || autoSizeAlign) {
    switch (verticalAlign) {
      case "middle":
        y += (height - realHeight) / 2;
        break;
      case "bottom":
        y += height - realHeight;
    }
  }
  starY += y;
  let row2, rowX, rowWidth2, layoutWidth = width || autoSizeAlign ? width : drawData.maxWidth;
  for (let i = 0, len = rows2.length; i < len; i++) {
    row2 = rows2[i];
    row2.x = x;
    if (row2.width < width || row2.width > width && !__clipText) {
      switch (textAlign) {
        case "center":
          row2.x += (layoutWidth - row2.width) / 2;
          break;
        case "right":
          row2.x += layoutWidth - row2.width;
      }
    }
    if (row2.paraStart && paraSpacing && i > 0)
      starY += paraSpacing;
    row2.y = starY;
    starY += __lineHeight;
    if (drawData.overflow > i && starY > realHeight) {
      row2.isOverflow = true;
      drawData.overflow = i + 1;
    }
    rowX = row2.x;
    rowWidth2 = row2.width;
    if (__letterSpacing < 0) {
      if (row2.width < 0) {
        rowWidth2 = -row2.width + style.fontSize + __letterSpacing;
        rowX -= rowWidth2;
        rowWidth2 += style.fontSize;
      } else {
        rowWidth2 -= __letterSpacing;
      }
    }
    if (rowX < bounds2.x)
      bounds2.x = rowX;
    if (rowWidth2 > bounds2.width)
      bounds2.width = rowWidth2;
    if (__clipText && width && width < rowWidth2) {
      row2.isOverflow = true;
      if (!drawData.overflow)
        drawData.overflow = rows2.length;
    }
  }
  bounds2.y = y;
  bounds2.height = realHeight;
}
function clipText(drawData, style, x, width) {
  if (!width)
    return;
  const { rows: rows2, overflow } = drawData;
  let { textOverflow } = style;
  rows2.splice(overflow);
  if (textOverflow && textOverflow !== "show") {
    if (textOverflow === "hide")
      textOverflow = "";
    else if (textOverflow === "ellipsis")
      textOverflow = "...";
    let char2, charRight;
    const ellipsisWidth = textOverflow ? Platform.canvas.measureText(textOverflow).width : 0;
    const right2 = x + width - ellipsisWidth;
    const list = style.textWrap === "none" ? rows2 : [rows2[overflow - 1]];
    list.forEach((row2) => {
      if (row2.isOverflow && row2.data) {
        let end = row2.data.length - 1;
        for (let i = end; i > -1; i--) {
          char2 = row2.data[i];
          charRight = char2.x + char2.width;
          if (i === end && charRight < right2) {
            break;
          } else if (charRight < right2 && char2.char !== " ") {
            row2.data.splice(i + 1);
            row2.width -= char2.width;
            break;
          }
          row2.width -= char2.width;
        }
        row2.width += ellipsisWidth;
        row2.data.push({ char: textOverflow, x: charRight });
        if (row2.textMode)
          toTextChar(row2);
      }
    });
  }
}
function toTextChar(row2) {
  row2.text = "";
  row2.data.forEach((char2) => {
    row2.text += char2.char;
  });
  row2.data = null;
}
function decorationText(drawData, style) {
  const { fontSize } = style;
  drawData.decorationHeight = fontSize / 11;
  switch (style.textDecoration) {
    case "under":
      drawData.decorationY = fontSize * 0.15;
      break;
    case "delete":
      drawData.decorationY = -fontSize * 0.35;
  }
}
var { top, right, bottom, left } = Direction4;
function getDrawData(content, style) {
  if (typeof content !== "string")
    content = String(content);
  let x = 0, y = 0;
  let width = style.__getInput("width") || 0;
  let height = style.__getInput("height") || 0;
  const { textDecoration, __font, __padding: padding } = style;
  if (padding) {
    if (width)
      x = padding[left], width -= padding[right] + padding[left];
    else if (!style.autoSizeAlign)
      x = padding[left];
    if (height)
      y = padding[top], height -= padding[top] + padding[bottom];
    else if (!style.autoSizeAlign)
      y = padding[top];
  }
  const drawData = {
    bounds: { x, y, width, height },
    rows: [],
    paraNumber: 0,
    font: Platform.canvas.font = __font
  };
  createRows(drawData, content, style);
  if (padding)
    padAutoText(padding, drawData, style, width, height);
  layoutText(drawData, style);
  layoutChar(drawData, style, width);
  if (drawData.overflow)
    clipText(drawData, style, x, width);
  if (textDecoration !== "none")
    decorationText(drawData, style);
  return drawData;
}
function padAutoText(padding, drawData, style, width, height) {
  if (!width && style.autoSizeAlign) {
    switch (style.textAlign) {
      case "left":
        offsetText(drawData, "x", padding[left]);
        break;
      case "right":
        offsetText(drawData, "x", -padding[right]);
    }
  }
  if (!height && style.autoSizeAlign) {
    switch (style.verticalAlign) {
      case "top":
        offsetText(drawData, "y", padding[top]);
        break;
      case "bottom":
        offsetText(drawData, "y", -padding[bottom]);
    }
  }
}
function offsetText(drawData, attrName, value) {
  const { bounds: bounds2, rows: rows2 } = drawData;
  bounds2[attrName] += value;
  for (let i = 0; i < rows2.length; i++)
    rows2[i][attrName] += value;
}
var TextConvertModule = {
  getDrawData
};
function string(color, opacity) {
  const doOpacity = typeof opacity === "number" && opacity !== 1;
  if (typeof color === "string") {
    if (doOpacity && ColorConvert.object)
      color = ColorConvert.object(color);
    else
      return color;
  }
  let a = color.a === void 0 ? 1 : color.a;
  if (doOpacity)
    a *= opacity;
  const rgb = color.r + "," + color.g + "," + color.b;
  return a === 1 ? "rgb(" + rgb + ")" : "rgba(" + rgb + "," + a + ")";
}
var ColorConvertModule = {
  string
};
var { setPoint, addPoint, toBounds } = TwoPointBoundsHelper;
function getTrimBounds(canvas2) {
  const { width, height } = canvas2.view;
  const { data } = canvas2.context.getImageData(0, 0, width, height);
  let x, y, pointBounds, index = 0;
  for (let i = 0; i < data.length; i += 4) {
    if (data[i + 3] !== 0) {
      x = index % width;
      y = (index - x) / width;
      pointBounds ? addPoint(pointBounds, x, y) : setPoint(pointBounds = {}, x, y);
    }
    index++;
  }
  const bounds2 = new Bounds();
  toBounds(pointBounds, bounds2);
  return bounds2.scale(1 / canvas2.pixelRatio).ceil();
}
var ExportModule = {
  export(leaf, filename, options) {
    this.running = true;
    const fileType2 = FileHelper.fileType(filename);
    const isDownload = filename.includes(".");
    options = FileHelper.getExportOptions(options);
    return addTask((success) => new Promise((resolve) => {
      const over = (result) => {
        success(result);
        resolve();
        this.running = false;
      };
      const { toURL } = Platform;
      const { download } = Platform.origin;
      if (fileType2 === "json") {
        isDownload && download(toURL(JSON.stringify(leaf.toJSON(options.json)), "text"), filename);
        return over({ data: isDownload ? true : leaf.toJSON(options.json) });
      }
      if (fileType2 === "svg") {
        isDownload && download(toURL(leaf.toSVG(), "svg"), filename);
        return over({ data: isDownload ? true : leaf.toSVG() });
      }
      const { leafer } = leaf;
      if (leafer) {
        checkLazy(leaf);
        leafer.waitViewCompleted(() => __awaiter(this, void 0, void 0, function* () {
          let renderBounds, trimBounds, scaleX = 1, scaleY = 1;
          const { worldTransform, isLeafer, isFrame } = leaf;
          const { slice, trim, onCanvas } = options;
          const smooth = options.smooth === void 0 ? leafer.config.smooth : options.smooth;
          const contextSettings = options.contextSettings || leafer.config.contextSettings;
          const screenshot = options.screenshot || leaf.isApp;
          const fill2 = isLeafer && screenshot ? options.fill === void 0 ? leaf.fill : options.fill : options.fill;
          const needFill = FileHelper.isOpaqueImage(filename) || fill2, matrix = new Matrix();
          if (screenshot) {
            renderBounds = screenshot === true ? isLeafer ? leafer.canvas.bounds : leaf.worldRenderBounds : screenshot;
          } else {
            let relative = options.relative || (isLeafer ? "inner" : "local");
            scaleX = worldTransform.scaleX;
            scaleY = worldTransform.scaleY;
            switch (relative) {
              case "inner":
                matrix.set(worldTransform);
                break;
              case "local":
                matrix.set(worldTransform).divide(leaf.localTransform);
                scaleX /= leaf.scaleX;
                scaleY /= leaf.scaleY;
                break;
              case "world":
                scaleX = 1;
                scaleY = 1;
                break;
              case "page":
                relative = leaf.leafer;
              default:
                matrix.set(worldTransform).divide(leaf.getTransform(relative));
                const l = relative.worldTransform;
                scaleX /= scaleX / l.scaleX;
                scaleY /= scaleY / l.scaleY;
            }
            renderBounds = leaf.getBounds("render", relative);
          }
          const scaleData = { scaleX: 1, scaleY: 1 };
          MathHelper.getScaleData(options.scale, options.size, renderBounds, scaleData);
          let pixelRatio = options.pixelRatio || 1;
          if (leaf.isApp) {
            scaleData.scaleX *= pixelRatio;
            scaleData.scaleY *= pixelRatio;
            pixelRatio = leaf.app.pixelRatio;
          }
          const { x, y, width, height } = new Bounds(renderBounds).scale(scaleData.scaleX, scaleData.scaleY);
          const renderOptions = { matrix: matrix.scale(1 / scaleData.scaleX, 1 / scaleData.scaleY).invert().translate(-x, -y).withScale(1 / scaleX * scaleData.scaleX, 1 / scaleY * scaleData.scaleY) };
          let canvas2 = Creator.canvas({ width: Math.round(width), height: Math.round(height), pixelRatio, smooth, contextSettings });
          let sliceLeaf;
          if (slice) {
            sliceLeaf = leaf;
            sliceLeaf.__worldOpacity = 0;
            leaf = leafer;
            renderOptions.bounds = canvas2.bounds;
          }
          canvas2.save();
          if (isFrame && fill2 !== void 0) {
            const oldFill = leaf.get("fill");
            leaf.fill = "";
            leaf.__render(canvas2, renderOptions);
            leaf.fill = oldFill;
          } else {
            leaf.__render(canvas2, renderOptions);
          }
          canvas2.restore();
          if (sliceLeaf)
            sliceLeaf.__updateWorldOpacity();
          if (trim) {
            trimBounds = getTrimBounds(canvas2);
            const old = canvas2, { width: width2, height: height2 } = trimBounds;
            const config = { x: 0, y: 0, width: width2, height: height2, pixelRatio };
            canvas2 = Creator.canvas(config);
            canvas2.copyWorld(old, trimBounds, config);
          }
          if (needFill)
            canvas2.fillWorld(canvas2.bounds, fill2 || "#FFFFFF", "destination-over");
          if (onCanvas)
            onCanvas(canvas2);
          const data = filename === "canvas" ? canvas2 : yield canvas2.export(filename, options);
          over({ data, width: canvas2.pixelWidth, height: canvas2.pixelHeight, renderBounds, trimBounds });
        }));
      } else {
        over({ data: false });
      }
    }));
  }
};
var tasker;
function addTask(task) {
  if (!tasker)
    tasker = new TaskProcessor();
  return new Promise((resolve) => {
    tasker.add(() => __awaiter(this, void 0, void 0, function* () {
      return yield task(resolve);
    }), { parallel: false });
  });
}
function checkLazy(leaf) {
  if (leaf.__.__needComputePaint)
    leaf.__.__computePaint();
  if (leaf.isBranch)
    leaf.children.forEach((child) => checkLazy(child));
}
var canvas = LeaferCanvasBase.prototype;
var debug = Debug.get("@leafer-ui/export");
canvas.export = function(filename, options) {
  const { quality, blob } = FileHelper.getExportOptions(options);
  if (filename.includes("."))
    return this.saveAs(filename, quality);
  else if (blob)
    return this.toBlob(filename, quality);
  else
    return this.toDataURL(filename, quality);
};
canvas.toBlob = function(type, quality) {
  return new Promise((resolve) => {
    Platform.origin.canvasToBolb(this.view, type, quality).then((blob) => {
      resolve(blob);
    }).catch((e) => {
      debug.error(e);
      resolve(null);
    });
  });
};
canvas.toDataURL = function(type, quality) {
  return Platform.origin.canvasToDataURL(this.view, type, quality);
};
canvas.saveAs = function(filename, quality) {
  return new Promise((resolve) => {
    Platform.origin.canvasSaveAs(this.view, filename, quality).then(() => {
      resolve(true);
    }).catch((e) => {
      debug.error(e);
      resolve(false);
    });
  });
};
Object.assign(TextConvert, TextConvertModule);
Object.assign(ColorConvert, ColorConvertModule);
Object.assign(Paint, PaintModule);
Object.assign(PaintImage, PaintImageModule);
Object.assign(PaintGradient, PaintGradientModule);
Object.assign(Effect, EffectModule);
Object.assign(Export, ExportModule);
Object.assign(Creator, {
  interaction: (target, canvas2, selector, options) => new Interaction(target, canvas2, selector, options),
  hitCanvas: (options, manager) => new LeaferCanvas(options, manager),
  hitCanvasManager: () => new HitCanvasManager()
});
useCanvas();

export {
  LeaferCanvas,
  useCanvas,
  Watcher,
  Layouter,
  Renderer,
  Selector,
  Interaction
};
//# sourceMappingURL=chunk-NHT3D22W.js.map
