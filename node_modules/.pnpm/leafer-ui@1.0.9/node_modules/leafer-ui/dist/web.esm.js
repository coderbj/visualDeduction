import { Debug, LeaferCanvasBase, Platform, DataHelper, canvasSizeAttrs, ResizeEvent, canvasPatch, Creator, LeaferImage, defineKey, FileHelper, LeafList, RenderEvent, ChildEvent, WatchEvent, PropertyEvent, LeafHelper, BranchHelper, Bounds, LeafBoundsHelper, LeafLevelList, LayoutEvent, Run, ImageManager, BoundsHelper, Answer, MathHelper, MatrixHelper, AlignHelper, ImageEvent, AroundHelper, PointHelper, Direction4, TwoPointBoundsHelper, TaskProcessor, Matrix } from '@leafer/core';
export * from '@leafer/core';
export { LeaferImage } from '@leafer/core';
import { InteractionHelper, InteractionBase, Cursor, HitCanvasManager } from '@leafer-ui/core';
export * from '@leafer-ui/core';
import { PaintImage, ColorConvert, PaintGradient, Export, Group, TextConvert, Paint, Effect } from '@leafer-ui/draw';

const debug$3 = Debug.get('LeaferCanvas');
class LeaferCanvas extends LeaferCanvasBase {
    set zIndex(zIndex) {
        const { style } = this.view;
        style.zIndex = zIndex;
        this.setAbsolute(this.view);
    }
    set childIndex(index) {
        const { view, parentView } = this;
        if (view && parentView) {
            const beforeNode = parentView.children[index];
            if (beforeNode) {
                this.setAbsolute(beforeNode);
                parentView.insertBefore(view, beforeNode);
            }
            else {
                parentView.appendChild(beforeNode);
            }
        }
    }
    init() {
        const { config } = this;
        const view = config.view || config.canvas;
        view ? this.__createViewFrom(view) : this.__createView();
        const { style } = this.view;
        style.display || (style.display = 'block');
        this.parentView = this.view.parentElement;
        if (this.parentView) {
            const pStyle = this.parentView.style;
            pStyle.webkitUserSelect = pStyle.userSelect = 'none';
        }
        if (Platform.syncDomFont && !this.parentView) {
            style.display = 'none';
            document.body.appendChild(this.view);
        }
        this.__createContext();
        if (!this.autoLayout)
            this.resize(config);
    }
    set backgroundColor(color) { this.view.style.backgroundColor = color; }
    get backgroundColor() { return this.view.style.backgroundColor; }
    set hittable(hittable) { this.view.style.pointerEvents = hittable ? 'auto' : 'none'; }
    get hittable() { return this.view.style.pointerEvents !== 'none'; }
    __createView() {
        this.view = document.createElement('canvas');
    }
    __createViewFrom(inputView) {
        let find = (typeof inputView === 'string') ? document.getElementById(inputView) : inputView;
        if (find) {
            if (find instanceof HTMLCanvasElement) {
                this.view = find;
            }
            else {
                let parent = find;
                if (find === window || find === document) {
                    const div = document.createElement('div');
                    const { style } = div;
                    style.position = 'absolute';
                    style.top = style.bottom = style.left = style.right = '0px';
                    document.body.appendChild(div);
                    parent = div;
                }
                this.__createView();
                const view = this.view;
                if (parent.hasChildNodes()) {
                    this.setAbsolute(view);
                    parent.style.position || (parent.style.position = 'relative');
                }
                parent.appendChild(view);
            }
        }
        else {
            debug$3.error(`no id: ${inputView}`);
            this.__createView();
        }
    }
    setAbsolute(view) {
        const { style } = view;
        style.position = 'absolute';
        style.top = style.left = '0px';
    }
    updateViewSize() {
        const { width, height, pixelRatio } = this;
        const { style } = this.view;
        style.width = width + 'px';
        style.height = height + 'px';
        this.view.width = Math.ceil(width * pixelRatio);
        this.view.height = Math.ceil(height * pixelRatio);
    }
    updateClientBounds() {
        this.clientBounds = this.view.getBoundingClientRect();
    }
    startAutoLayout(autoBounds, listener) {
        this.resizeListener = listener;
        if (autoBounds) {
            this.autoBounds = autoBounds;
            try {
                this.resizeObserver = new ResizeObserver((entries) => {
                    this.updateClientBounds();
                    for (const entry of entries)
                        this.checkAutoBounds(entry.contentRect);
                });
                const parent = this.parentView;
                if (parent) {
                    this.resizeObserver.observe(parent);
                    this.checkAutoBounds(parent.getBoundingClientRect());
                }
                else {
                    this.checkAutoBounds(this.view);
                    debug$3.warn('no parent');
                }
            }
            catch (_a) {
                this.imitateResizeObserver();
            }
        }
        else {
            window.addEventListener('resize', () => {
                const pixelRatio = Platform.devicePixelRatio;
                if (this.pixelRatio !== pixelRatio) {
                    const { width, height } = this;
                    this.emitResize({ width, height, pixelRatio });
                }
            });
        }
    }
    imitateResizeObserver() {
        if (this.autoLayout) {
            if (this.parentView)
                this.checkAutoBounds(this.parentView.getBoundingClientRect());
            Platform.requestRender(this.imitateResizeObserver.bind(this));
        }
    }
    checkAutoBounds(parentSize) {
        const view = this.view;
        const { x, y, width, height } = this.autoBounds.getBoundsFrom(parentSize);
        const size = { width, height, pixelRatio: Platform.devicePixelRatio };
        if (!this.isSameSize(size)) {
            const { style } = view;
            style.marginLeft = x + 'px';
            style.marginTop = y + 'px';
            this.emitResize(size);
        }
    }
    stopAutoLayout() {
        this.autoLayout = false;
        this.resizeListener = null;
        if (this.resizeObserver) {
            this.resizeObserver.disconnect();
            this.resizeObserver = null;
        }
    }
    emitResize(size) {
        const oldSize = {};
        DataHelper.copyAttrs(oldSize, this, canvasSizeAttrs);
        this.resize(size);
        if (this.resizeListener && this.width !== undefined)
            this.resizeListener(new ResizeEvent(size, oldSize));
    }
    unrealCanvas() {
        if (!this.unreal && this.parentView) {
            const view = this.view;
            if (view)
                view.remove();
            this.view = this.parentView;
            this.unreal = true;
        }
    }
    destroy() {
        if (this.view) {
            this.stopAutoLayout();
            if (!this.unreal) {
                const view = this.view;
                if (view.parentElement)
                    view.remove();
            }
            super.destroy();
        }
    }
}

canvasPatch(CanvasRenderingContext2D.prototype);
canvasPatch(Path2D.prototype);

const { mineType, fileType } = FileHelper;
Object.assign(Creator, {
    canvas: (options, manager) => new LeaferCanvas(options, manager),
    image: (options) => new LeaferImage(options)
});
function useCanvas(_canvasType, _power) {
    Platform.origin = {
        createCanvas(width, height) {
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            return canvas;
        },
        canvasToDataURL: (canvas, type, quality) => canvas.toDataURL(mineType(type), quality),
        canvasToBolb: (canvas, type, quality) => new Promise((resolve) => canvas.toBlob(resolve, mineType(type), quality)),
        canvasSaveAs: (canvas, filename, quality) => {
            const url = canvas.toDataURL(mineType(fileType(filename)), quality);
            return Platform.origin.download(url, filename);
        },
        download(url, filename) {
            return new Promise((resolve) => {
                let el = document.createElement('a');
                el.href = url;
                el.download = filename;
                document.body.appendChild(el);
                el.click();
                document.body.removeChild(el);
                resolve();
            });
        },
        loadImage(src) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                const { crossOrigin } = Platform.image;
                if (crossOrigin) {
                    img.setAttribute('crossOrigin', crossOrigin);
                    img.crossOrigin = crossOrigin;
                }
                img.onload = () => { resolve(img); };
                img.onerror = (e) => { reject(e); };
                img.src = Platform.image.getRealURL(src);
            });
        }
    };
    Platform.event = {
        stopDefault(origin) { origin.preventDefault(); },
        stopNow(origin) { origin.stopImmediatePropagation(); },
        stop(origin) { origin.stopPropagation(); }
    };
    Platform.canvas = Creator.canvas();
    Platform.conicGradientSupport = !!Platform.canvas.context.createConicGradient;
}
Platform.name = 'web';
Platform.isMobile = 'ontouchstart' in window;
Platform.requestRender = function (render) { window.requestAnimationFrame(render); };
defineKey(Platform, 'devicePixelRatio', { get() { return Math.max(1, devicePixelRatio); } });
const { userAgent } = navigator;
if (userAgent.indexOf("Firefox") > -1) {
    Platform.conicGradientRotate90 = true;
    Platform.intWheelDeltaY = true;
    Platform.syncDomFont = true;
}
else if (userAgent.indexOf("Safari") > -1 && userAgent.indexOf("Chrome") === -1) {
    Platform.fullImageShadow = true;
}
if (userAgent.indexOf('Windows') > -1) {
    Platform.os = 'Windows';
    Platform.intWheelDeltaY = true;
}
else if (userAgent.indexOf('Mac') > -1) {
    Platform.os = 'Mac';
}
else if (userAgent.indexOf('Linux') > -1) {
    Platform.os = 'Linux';
}

class Watcher {
    get childrenChanged() { return this.hasAdd || this.hasRemove || this.hasVisible; }
    get updatedList() {
        if (this.hasRemove) {
            const updatedList = new LeafList();
            this.__updatedList.list.forEach(item => { if (item.leafer)
                updatedList.add(item); });
            return updatedList;
        }
        else {
            return this.__updatedList;
        }
    }
    constructor(target, userConfig) {
        this.totalTimes = 0;
        this.config = {};
        this.__updatedList = new LeafList();
        this.target = target;
        if (userConfig)
            this.config = DataHelper.default(userConfig, this.config);
        this.__listenEvents();
    }
    start() {
        if (this.disabled)
            return;
        this.running = true;
    }
    stop() {
        this.running = false;
    }
    disable() {
        this.stop();
        this.__removeListenEvents();
        this.disabled = true;
    }
    update() {
        this.changed = true;
        if (this.running)
            this.target.emit(RenderEvent.REQUEST);
    }
    __onAttrChange(event) {
        this.__updatedList.add(event.target);
        this.update();
    }
    __onChildEvent(event) {
        if (event.type === ChildEvent.ADD) {
            this.hasAdd = true;
            this.__pushChild(event.child);
        }
        else {
            this.hasRemove = true;
            this.__updatedList.add(event.parent);
        }
        this.update();
    }
    __pushChild(child) {
        this.__updatedList.add(child);
        if (child.isBranch)
            this.__loopChildren(child);
    }
    __loopChildren(parent) {
        const { children } = parent;
        for (let i = 0, len = children.length; i < len; i++)
            this.__pushChild(children[i]);
    }
    __onRquestData() {
        this.target.emitEvent(new WatchEvent(WatchEvent.DATA, { updatedList: this.updatedList }));
        this.__updatedList = new LeafList();
        this.totalTimes++;
        this.changed = false;
        this.hasVisible = false;
        this.hasRemove = false;
        this.hasAdd = false;
    }
    __listenEvents() {
        const { target } = this;
        this.__eventIds = [
            target.on_(PropertyEvent.CHANGE, this.__onAttrChange, this),
            target.on_([ChildEvent.ADD, ChildEvent.REMOVE], this.__onChildEvent, this),
            target.on_(WatchEvent.REQUEST, this.__onRquestData, this)
        ];
    }
    __removeListenEvents() {
        this.target.off_(this.__eventIds);
    }
    destroy() {
        if (this.target) {
            this.stop();
            this.__removeListenEvents();
            this.target = null;
            this.__updatedList = null;
        }
    }
}

const { updateAllMatrix: updateAllMatrix$1, updateBounds: updateOneBounds, updateAllWorldOpacity } = LeafHelper;
const { pushAllChildBranch, pushAllParent } = BranchHelper;
function updateMatrix(updateList, levelList) {
    let layout;
    updateList.list.forEach(leaf => {
        layout = leaf.__layout;
        if (levelList.without(leaf) && !layout.proxyZoom) {
            if (layout.matrixChanged) {
                updateAllMatrix$1(leaf, true);
                levelList.add(leaf);
                if (leaf.isBranch)
                    pushAllChildBranch(leaf, levelList);
                pushAllParent(leaf, levelList);
            }
            else if (layout.boundsChanged) {
                levelList.add(leaf);
                if (leaf.isBranch)
                    leaf.__tempNumber = 0;
                pushAllParent(leaf, levelList);
            }
        }
    });
}
function updateBounds(boundsList) {
    let list, branch, children;
    boundsList.sort(true);
    boundsList.levels.forEach(level => {
        list = boundsList.levelMap[level];
        for (let i = 0, len = list.length; i < len; i++) {
            branch = list[i];
            if (branch.isBranch && branch.__tempNumber) {
                children = branch.children;
                for (let j = 0, jLen = children.length; j < jLen; j++) {
                    if (!children[j].isBranch) {
                        updateOneBounds(children[j]);
                    }
                }
            }
            updateOneBounds(branch);
        }
    });
}
function updateChange(updateList) {
    let layout;
    updateList.list.forEach(leaf => {
        layout = leaf.__layout;
        if (layout.opacityChanged)
            updateAllWorldOpacity(leaf);
        if (layout.stateStyleChanged)
            setTimeout(() => layout.stateStyleChanged && leaf.updateState());
        leaf.__updateChange();
    });
}

const { worldBounds } = LeafBoundsHelper;
const bigBounds = { x: 0, y: 0, width: 100000, height: 100000 };
class LayoutBlockData {
    constructor(list) {
        this.updatedBounds = new Bounds();
        this.beforeBounds = new Bounds();
        this.afterBounds = new Bounds();
        if (list instanceof Array)
            list = new LeafList(list);
        this.updatedList = list;
    }
    setBefore() {
        this.beforeBounds.setListWithFn(this.updatedList.list, worldBounds);
    }
    setAfter() {
        const { list } = this.updatedList;
        if (list.some(leaf => leaf.noBounds)) {
            this.afterBounds.set(bigBounds);
        }
        else {
            this.afterBounds.setListWithFn(list, worldBounds);
        }
        this.updatedBounds.setList([this.beforeBounds, this.afterBounds]);
    }
    merge(data) {
        this.updatedList.addList(data.updatedList.list);
        this.beforeBounds.add(data.beforeBounds);
        this.afterBounds.add(data.afterBounds);
        this.updatedBounds.add(data.updatedBounds);
    }
    destroy() {
        this.updatedList = null;
    }
}

const { updateAllMatrix, updateAllChange } = LeafHelper;
const debug$2 = Debug.get('Layouter');
class Layouter {
    constructor(target, userConfig) {
        this.totalTimes = 0;
        this.config = {};
        this.__levelList = new LeafLevelList();
        this.target = target;
        if (userConfig)
            this.config = DataHelper.default(userConfig, this.config);
        this.__listenEvents();
    }
    start() {
        if (this.disabled)
            return;
        this.running = true;
    }
    stop() {
        this.running = false;
    }
    disable() {
        this.stop();
        this.__removeListenEvents();
        this.disabled = true;
    }
    layout() {
        if (!this.running)
            return;
        const { target } = this;
        this.times = 0;
        try {
            target.emit(LayoutEvent.START);
            this.layoutOnce();
            target.emitEvent(new LayoutEvent(LayoutEvent.END, this.layoutedBlocks, this.times));
        }
        catch (e) {
            debug$2.error(e);
        }
        this.layoutedBlocks = null;
    }
    layoutAgain() {
        if (this.layouting) {
            this.waitAgain = true;
        }
        else {
            this.layoutOnce();
        }
    }
    layoutOnce() {
        if (this.layouting)
            return debug$2.warn('layouting');
        if (this.times > 3)
            return debug$2.warn('layout max times');
        this.times++;
        this.totalTimes++;
        this.layouting = true;
        this.target.emit(WatchEvent.REQUEST);
        if (this.totalTimes > 1) {
            this.partLayout();
        }
        else {
            this.fullLayout();
        }
        this.layouting = false;
        if (this.waitAgain) {
            this.waitAgain = false;
            this.layoutOnce();
        }
    }
    partLayout() {
        var _a;
        if (!((_a = this.__updatedList) === null || _a === void 0 ? void 0 : _a.length))
            return;
        const t = Run.start('PartLayout');
        const { target, __updatedList: updateList } = this;
        const { BEFORE, LAYOUT, AFTER } = LayoutEvent;
        const blocks = this.getBlocks(updateList);
        blocks.forEach(item => item.setBefore());
        target.emitEvent(new LayoutEvent(BEFORE, blocks, this.times));
        this.extraBlock = null;
        updateList.sort();
        updateMatrix(updateList, this.__levelList);
        updateBounds(this.__levelList);
        updateChange(updateList);
        if (this.extraBlock)
            blocks.push(this.extraBlock);
        blocks.forEach(item => item.setAfter());
        target.emitEvent(new LayoutEvent(LAYOUT, blocks, this.times));
        target.emitEvent(new LayoutEvent(AFTER, blocks, this.times));
        this.addBlocks(blocks);
        this.__levelList.reset();
        this.__updatedList = null;
        Run.end(t);
    }
    fullLayout() {
        const t = Run.start('FullLayout');
        const { target } = this;
        const { BEFORE, LAYOUT, AFTER } = LayoutEvent;
        const blocks = this.getBlocks(new LeafList(target));
        target.emitEvent(new LayoutEvent(BEFORE, blocks, this.times));
        Layouter.fullLayout(target);
        blocks.forEach(item => { item.setAfter(); });
        target.emitEvent(new LayoutEvent(LAYOUT, blocks, this.times));
        target.emitEvent(new LayoutEvent(AFTER, blocks, this.times));
        this.addBlocks(blocks);
        Run.end(t);
    }
    static fullLayout(target) {
        updateAllMatrix(target, true);
        if (target.isBranch) {
            BranchHelper.updateBounds(target);
        }
        else {
            LeafHelper.updateBounds(target);
        }
        updateAllChange(target);
    }
    addExtra(leaf) {
        if (!this.__updatedList.has(leaf)) {
            const { updatedList, beforeBounds } = this.extraBlock || (this.extraBlock = new LayoutBlockData([]));
            updatedList.length ? beforeBounds.add(leaf.__world) : beforeBounds.set(leaf.__world);
            updatedList.add(leaf);
        }
    }
    createBlock(data) {
        return new LayoutBlockData(data);
    }
    getBlocks(list) {
        return [this.createBlock(list)];
    }
    addBlocks(current) {
        this.layoutedBlocks ? this.layoutedBlocks.push(...current) : this.layoutedBlocks = current;
    }
    __onReceiveWatchData(event) {
        this.__updatedList = event.data.updatedList;
    }
    __listenEvents() {
        const { target } = this;
        this.__eventIds = [
            target.on_(LayoutEvent.REQUEST, this.layout, this),
            target.on_(LayoutEvent.AGAIN, this.layoutAgain, this),
            target.on_(WatchEvent.DATA, this.__onReceiveWatchData, this)
        ];
    }
    __removeListenEvents() {
        this.target.off_(this.__eventIds);
    }
    destroy() {
        if (this.target) {
            this.stop();
            this.__removeListenEvents();
            this.target = this.config = null;
        }
    }
}

const debug$1 = Debug.get('Renderer');
class Renderer {
    get needFill() { return !!(!this.canvas.allowBackgroundColor && this.config.fill); }
    constructor(target, canvas, userConfig) {
        this.FPS = 60;
        this.totalTimes = 0;
        this.times = 0;
        this.config = {
            usePartRender: true,
            maxFPS: 60
        };
        this.target = target;
        this.canvas = canvas;
        if (userConfig)
            this.config = DataHelper.default(userConfig, this.config);
        this.__listenEvents();
        this.__requestRender();
    }
    start() {
        this.running = true;
    }
    stop() {
        this.running = false;
    }
    update() {
        this.changed = true;
    }
    requestLayout() {
        this.target.emit(LayoutEvent.REQUEST);
    }
    render(callback) {
        if (!(this.running && this.canvas.view)) {
            this.changed = true;
            return;
        }
        const { target } = this;
        this.times = 0;
        this.totalBounds = new Bounds();
        debug$1.log(target.innerName, '--->');
        try {
            target.app.emit(RenderEvent.CHILD_START, target);
            this.emitRender(RenderEvent.START);
            this.renderOnce(callback);
            this.emitRender(RenderEvent.END, this.totalBounds);
            ImageManager.clearRecycled();
        }
        catch (e) {
            this.rendering = false;
            debug$1.error(e);
        }
        debug$1.log('-------------|');
    }
    renderAgain() {
        if (this.rendering) {
            this.waitAgain = true;
        }
        else {
            this.renderOnce();
        }
    }
    renderOnce(callback) {
        if (this.rendering)
            return debug$1.warn('rendering');
        if (this.times > 3)
            return debug$1.warn('render max times');
        this.times++;
        this.totalTimes++;
        this.rendering = true;
        this.changed = false;
        this.renderBounds = new Bounds();
        this.renderOptions = {};
        if (callback) {
            this.emitRender(RenderEvent.BEFORE);
            callback();
        }
        else {
            this.requestLayout();
            if (this.ignore) {
                this.ignore = this.rendering = false;
                return;
            }
            this.emitRender(RenderEvent.BEFORE);
            if (this.config.usePartRender && this.totalTimes > 1) {
                this.partRender();
            }
            else {
                this.fullRender();
            }
        }
        this.emitRender(RenderEvent.RENDER, this.renderBounds, this.renderOptions);
        this.emitRender(RenderEvent.AFTER, this.renderBounds, this.renderOptions);
        this.updateBlocks = null;
        this.rendering = false;
        if (this.waitAgain) {
            this.waitAgain = false;
            this.renderOnce();
        }
    }
    partRender() {
        const { canvas, updateBlocks: list } = this;
        if (!list)
            return debug$1.warn('PartRender: need update attr');
        this.mergeBlocks();
        list.forEach(block => { if (canvas.bounds.hit(block) && !block.isEmpty())
            this.clipRender(block); });
    }
    clipRender(block) {
        const t = Run.start('PartRender');
        const { canvas } = this;
        const bounds = block.getIntersect(canvas.bounds);
        const includes = block.includes(this.target.__world);
        const realBounds = new Bounds(bounds);
        canvas.save();
        if (includes && !Debug.showRepaint) {
            canvas.clear();
        }
        else {
            bounds.spread(10 + 1 / this.canvas.pixelRatio).ceil();
            canvas.clearWorld(bounds, true);
            canvas.clipWorld(bounds, true);
        }
        this.__render(bounds, includes, realBounds);
        canvas.restore();
        Run.end(t);
    }
    fullRender() {
        const t = Run.start('FullRender');
        const { canvas } = this;
        canvas.save();
        canvas.clear();
        this.__render(canvas.bounds, true);
        canvas.restore();
        Run.end(t);
    }
    __render(bounds, includes, realBounds) {
        const options = bounds.includes(this.target.__world) ? { includes } : { bounds, includes };
        if (this.needFill)
            this.canvas.fillWorld(bounds, this.config.fill);
        if (Debug.showRepaint)
            this.canvas.strokeWorld(bounds, 'red');
        this.target.__render(this.canvas, options);
        this.renderBounds = realBounds = realBounds || bounds;
        this.renderOptions = options;
        this.totalBounds.isEmpty() ? this.totalBounds = realBounds : this.totalBounds.add(realBounds);
        if (Debug.showHitView)
            this.renderHitView(options);
        if (Debug.showBoundsView)
            this.renderBoundsView(options);
        this.canvas.updateRender(realBounds);
    }
    renderHitView(_options) { }
    renderBoundsView(_options) { }
    addBlock(block) {
        if (!this.updateBlocks)
            this.updateBlocks = [];
        this.updateBlocks.push(block);
    }
    mergeBlocks() {
        const { updateBlocks: list } = this;
        if (list) {
            const bounds = new Bounds();
            bounds.setList(list);
            list.length = 0;
            list.push(bounds);
        }
    }
    __requestRender() {
        const startTime = Date.now();
        Platform.requestRender(() => {
            this.FPS = Math.min(60, Math.ceil(1000 / (Date.now() - startTime)));
            if (this.running) {
                if (this.changed && this.canvas.view)
                    this.render();
                this.target.emit(RenderEvent.NEXT);
            }
            if (this.target)
                this.__requestRender();
        });
    }
    __onResize(e) {
        if (this.canvas.unreal)
            return;
        if (e.bigger || !e.samePixelRatio) {
            const { width, height } = e.old;
            const bounds = new Bounds(0, 0, width, height);
            if (!bounds.includes(this.target.__world) || this.needFill || !e.samePixelRatio) {
                this.addBlock(this.canvas.bounds);
                this.target.forceUpdate('surface');
                return;
            }
        }
        this.addBlock(new Bounds(0, 0, 1, 1));
        this.changed = true;
    }
    __onLayoutEnd(event) {
        if (event.data)
            event.data.map(item => {
                let empty;
                if (item.updatedList)
                    item.updatedList.list.some(leaf => {
                        empty = (!leaf.__world.width || !leaf.__world.height);
                        if (empty) {
                            if (!leaf.isLeafer)
                                debug$1.tip(leaf.innerName, ': empty');
                            empty = (!leaf.isBranch || leaf.isBranchLeaf);
                        }
                        return empty;
                    });
                this.addBlock(empty ? this.canvas.bounds : item.updatedBounds);
            });
    }
    emitRender(type, bounds, options) {
        this.target.emitEvent(new RenderEvent(type, this.times, bounds, options));
    }
    __listenEvents() {
        const { target } = this;
        this.__eventIds = [
            target.on_(RenderEvent.REQUEST, this.update, this),
            target.on_(LayoutEvent.END, this.__onLayoutEnd, this),
            target.on_(RenderEvent.AGAIN, this.renderAgain, this),
            target.on_(ResizeEvent.RESIZE, this.__onResize, this)
        ];
    }
    __removeListenEvents() {
        this.target.off_(this.__eventIds);
    }
    destroy() {
        if (this.target) {
            this.stop();
            this.__removeListenEvents();
            this.target = this.canvas = this.config = null;
        }
    }
}

const { hitRadiusPoint } = BoundsHelper;
class Picker {
    constructor(target, selector) {
        this.target = target;
        this.selector = selector;
    }
    getByPoint(hitPoint, hitRadius, options) {
        if (!hitRadius)
            hitRadius = 0;
        if (!options)
            options = {};
        const through = options.through || false;
        const ignoreHittable = options.ignoreHittable || false;
        const target = options.target || this.target;
        this.exclude = options.exclude || null;
        this.point = { x: hitPoint.x, y: hitPoint.y, radiusX: hitRadius, radiusY: hitRadius };
        this.findList = new LeafList(options.findList);
        if (!options.findList)
            this.hitBranch(target);
        const { list } = this.findList;
        const leaf = this.getBestMatchLeaf(list, options.bottomList, ignoreHittable);
        const path = ignoreHittable ? this.getPath(leaf) : this.getHitablePath(leaf);
        this.clear();
        return through ? { path, target: leaf, throughPath: list.length ? this.getThroughPath(list) : path } : { path, target: leaf };
    }
    getBestMatchLeaf(list, bottomList, ignoreHittable) {
        if (list.length) {
            let find;
            this.findList = new LeafList();
            const { x, y } = this.point;
            const point = { x, y, radiusX: 0, radiusY: 0 };
            for (let i = 0, len = list.length; i < len; i++) {
                find = list[i];
                if (ignoreHittable || LeafHelper.worldHittable(find)) {
                    this.hitChild(find, point);
                    if (this.findList.length)
                        return this.findList.list[0];
                }
            }
        }
        if (bottomList) {
            for (let i = 0, len = bottomList.length; i < len; i++) {
                this.hitChild(bottomList[i].target, this.point, bottomList[i].proxy);
                if (this.findList.length)
                    return this.findList.list[0];
            }
        }
        return list[0];
    }
    getPath(leaf) {
        const path = new LeafList();
        while (leaf) {
            path.add(leaf);
            leaf = leaf.parent;
        }
        if (this.target)
            path.add(this.target);
        return path;
    }
    getHitablePath(leaf) {
        const path = this.getPath(leaf && leaf.hittable ? leaf : null);
        let item, hittablePath = new LeafList();
        for (let i = path.list.length - 1; i > -1; i--) {
            item = path.list[i];
            if (!item.__.hittable)
                break;
            hittablePath.addAt(item, 0);
            if (!item.__.hitChildren)
                break;
        }
        return hittablePath;
    }
    getThroughPath(list) {
        const throughPath = new LeafList();
        const pathList = [];
        for (let i = list.length - 1; i > -1; i--) {
            pathList.push(this.getPath(list[i]));
        }
        let path, nextPath, leaf;
        for (let i = 0, len = pathList.length; i < len; i++) {
            path = pathList[i], nextPath = pathList[i + 1];
            for (let j = 0, jLen = path.length; j < jLen; j++) {
                leaf = path.list[j];
                if (nextPath && nextPath.has(leaf))
                    break;
                throughPath.add(leaf);
            }
        }
        return throughPath;
    }
    hitBranch(branch) {
        this.eachFind(branch.children, branch.__onlyHitMask);
    }
    eachFind(children, hitMask) {
        let child, hit;
        const { point } = this, len = children.length;
        for (let i = len - 1; i > -1; i--) {
            child = children[i];
            if (!child.__.visible || (hitMask && !child.__.mask))
                continue;
            hit = child.__.hitRadius ? true : hitRadiusPoint(child.__world, point);
            if (child.isBranch) {
                if (hit || child.__ignoreHitWorld) {
                    this.eachFind(child.children, child.__onlyHitMask);
                    if (child.isBranchLeaf)
                        this.hitChild(child, point);
                }
            }
            else {
                if (hit)
                    this.hitChild(child, point);
            }
        }
    }
    hitChild(child, point, proxy) {
        if (this.exclude && this.exclude.has(child))
            return;
        if (child.__hitWorld(point)) {
            const { parent } = child;
            if (parent && parent.__hasMask && !child.__.mask && !parent.children.some(item => item.__.mask && item.__hitWorld(point)))
                return;
            this.findList.add(proxy || child);
        }
    }
    clear() {
        this.point = null;
        this.findList = null;
        this.exclude = null;
    }
    destroy() {
        this.clear();
    }
}

const { Yes, NoAndSkip, YesAndSkip } = Answer;
const idCondition = {}, classNameCondition = {}, tagCondition = {};
class Selector {
    constructor(target, userConfig) {
        this.config = {};
        this.innerIdMap = {};
        this.idMap = {};
        this.methods = {
            id: (leaf, name) => leaf.id === name ? (this.target && (this.idMap[name] = leaf), 1) : 0,
            innerId: (leaf, innerId) => leaf.innerId === innerId ? (this.target && (this.innerIdMap[innerId] = leaf), 1) : 0,
            className: (leaf, name) => leaf.className === name ? 1 : 0,
            tag: (leaf, name) => leaf.__tag === name ? 1 : 0,
            tags: (leaf, nameMap) => nameMap[leaf.__tag] ? 1 : 0
        };
        this.target = target;
        if (userConfig)
            this.config = DataHelper.default(userConfig, this.config);
        this.picker = new Picker(target, this);
        if (target)
            this.__listenEvents();
    }
    getBy(condition, branch, one, options) {
        switch (typeof condition) {
            case 'number':
                const leaf = this.getByInnerId(condition, branch);
                return one ? leaf : (leaf ? [leaf] : []);
            case 'string':
                switch (condition[0]) {
                    case '#':
                        idCondition.id = condition.substring(1), condition = idCondition;
                        break;
                    case '.':
                        classNameCondition.className = condition.substring(1), condition = classNameCondition;
                        break;
                    default:
                        tagCondition.tag = condition, condition = tagCondition;
                }
            case 'object':
                if (condition.id !== undefined) {
                    const leaf = this.getById(condition.id, branch);
                    return one ? leaf : (leaf ? [leaf] : []);
                }
                else if (condition.tag) {
                    const { tag } = condition, isArray = tag instanceof Array;
                    return this.getByMethod(isArray ? this.methods.tags : this.methods.tag, branch, one, isArray ? DataHelper.toMap(tag) : tag);
                }
                else {
                    return this.getByMethod(this.methods.className, branch, one, condition.className);
                }
            case 'function':
                return this.getByMethod(condition, branch, one, options);
        }
    }
    getByPoint(hitPoint, hitRadius, options) {
        if (Platform.name === 'node' && this.target)
            this.target.emit(LayoutEvent.CHECK_UPDATE);
        return this.picker.getByPoint(hitPoint, hitRadius, options);
    }
    getByInnerId(innerId, branch) {
        const cache = this.innerIdMap[innerId];
        if (cache)
            return cache;
        this.eachFind(this.toChildren(branch), this.methods.innerId, null, innerId);
        return this.findLeaf;
    }
    getById(id, branch) {
        const cache = this.idMap[id];
        if (cache && LeafHelper.hasParent(cache, branch || this.target))
            return cache;
        this.eachFind(this.toChildren(branch), this.methods.id, null, id);
        return this.findLeaf;
    }
    getByClassName(className, branch) {
        return this.getByMethod(this.methods.className, branch, false, className);
    }
    getByTag(tag, branch) {
        return this.getByMethod(this.methods.tag, branch, false, tag);
    }
    getByMethod(method, branch, one, options) {
        const list = one ? null : [];
        this.eachFind(this.toChildren(branch), method, list, options);
        return list || this.findLeaf;
    }
    eachFind(children, method, list, options) {
        let child, result;
        for (let i = 0, len = children.length; i < len; i++) {
            child = children[i];
            result = method(child, options);
            if (result === Yes || result === YesAndSkip) {
                if (list) {
                    list.push(child);
                }
                else {
                    this.findLeaf = child;
                    return;
                }
            }
            if (child.isBranch && result < NoAndSkip)
                this.eachFind(child.children, method, list, options);
        }
    }
    toChildren(branch) {
        this.findLeaf = null;
        return [branch || this.target];
    }
    __onRemoveChild(event) {
        const { id, innerId } = event.child;
        if (this.idMap[id])
            delete this.idMap[id];
        if (this.innerIdMap[innerId])
            delete this.innerIdMap[innerId];
    }
    __checkIdChange(event) {
        if (event.attrName === 'id') {
            const id = event.oldValue;
            if (this.idMap[id])
                delete this.idMap[id];
        }
    }
    __listenEvents() {
        this.__eventIds = [
            this.target.on_(ChildEvent.REMOVE, this.__onRemoveChild, this),
            this.target.on_(PropertyEvent.CHANGE, this.__checkIdChange, this)
        ];
    }
    __removeListenEvents() {
        this.target.off_(this.__eventIds);
        this.__eventIds.length = 0;
    }
    destroy() {
        if (this.__eventIds.length) {
            this.__removeListenEvents();
            this.picker.destroy();
            this.findLeaf = null;
            this.innerIdMap = {};
            this.idMap = {};
        }
    }
}

Object.assign(Creator, {
    watcher: (target, options) => new Watcher(target, options),
    layouter: (target, options) => new Layouter(target, options),
    renderer: (target, canvas, options) => new Renderer(target, canvas, options),
    selector: (target, options) => new Selector(target, options)
});
Platform.layout = Layouter.fullLayout;

const PointerEventHelper = {
    convert(e, local) {
        const base = InteractionHelper.getBase(e);
        const data = Object.assign(Object.assign({}, base), { x: local.x, y: local.y, width: e.width, height: e.height, pointerType: e.pointerType, pressure: e.pressure });
        if (data.pointerType === 'pen') {
            data.tangentialPressure = e.tangentialPressure;
            data.tiltX = e.tiltX;
            data.tiltY = e.tiltY;
            data.twist = e.twist;
        }
        return data;
    },
    convertMouse(e, local) {
        const base = InteractionHelper.getBase(e);
        return Object.assign(Object.assign({}, base), { x: local.x, y: local.y, width: 1, height: 1, pointerType: 'mouse', pressure: 0.5 });
    },
    convertTouch(e, local) {
        const touch = PointerEventHelper.getTouch(e);
        const base = InteractionHelper.getBase(e);
        return Object.assign(Object.assign({}, base), { x: local.x, y: local.y, width: 1, height: 1, pointerType: 'touch', multiTouch: e.touches.length > 1, pressure: touch.force });
    },
    getTouch(e) {
        return e.targetTouches[0] || e.changedTouches[0];
    }
};

const WheelEventHelper = {
    getMove(e, config) {
        let { moveSpeed } = config;
        let { deltaX, deltaY } = e;
        if (e.shiftKey && !deltaX) {
            deltaX = deltaY;
            deltaY = 0;
        }
        if (deltaX > 50)
            deltaX = Math.max(50, deltaX / 3);
        if (deltaY > 50)
            deltaY = Math.max(50, deltaY / 3);
        return { x: -deltaX * moveSpeed * 2, y: -deltaY * moveSpeed * 2 };
    },
    getScale(e, config) {
        let zoom;
        let scale = 1;
        let { zoomMode, zoomSpeed } = config;
        const delta = e.deltaY || e.deltaX;
        if (zoomMode) {
            zoom = (zoomMode === 'mouse') ? true : (!e.deltaX && (Platform.intWheelDeltaY ? Math.abs(delta) > 17 : Math.ceil(delta) !== delta));
            if (e.shiftKey || e.metaKey || e.ctrlKey)
                zoom = true;
        }
        else {
            zoom = !e.shiftKey && (e.metaKey || e.ctrlKey);
        }
        if (zoom) {
            zoomSpeed = MathHelper.within(zoomSpeed, 0, 1);
            const min = e.deltaY ? config.delta.y : config.delta.x;
            scale = 1 - delta / (min * 4) * zoomSpeed;
            if (scale < 0.5)
                scale = 0.5;
            if (scale >= 1.5)
                scale = 1.5;
        }
        return scale;
    }
};

const KeyEventHelper = {
    convert(e) {
        const base = InteractionHelper.getBase(e);
        const data = Object.assign(Object.assign({}, base), { code: e.code, key: e.key });
        return data;
    }
};

const { getMoveEventData, getZoomEventData, getRotateEventData, pathCanDrag } = InteractionHelper;
class Interaction extends InteractionBase {
    __listenEvents() {
        super.__listenEvents();
        const view = this.view = this.canvas.view;
        this.viewEvents = {
            'pointerdown': this.onPointerDown,
            'mousedown': this.onMouseDown,
            'touchstart': this.onTouchStart,
            'contextmenu': this.onContextMenu,
            'wheel': this.onWheel,
            'gesturestart': this.onGesturestart,
            'gesturechange': this.onGesturechange,
            'gestureend': this.onGestureend
        };
        this.windowEvents = {
            'pointermove': this.onPointerMove,
            'pointerup': this.onPointerUp,
            'pointercancel': this.onPointerCancel,
            'mousemove': this.onMouseMove,
            'mouseup': this.onMouseUp,
            'touchmove': this.onTouchMove,
            'touchend': this.onTouchEnd,
            'touchcancel': this.onTouchCancel,
            'keydown': this.onKeyDown,
            'keyup': this.onKeyUp,
            'scroll': this.onScroll
        };
        const { viewEvents, windowEvents } = this;
        for (let name in viewEvents) {
            viewEvents[name] = viewEvents[name].bind(this);
            view.addEventListener(name, viewEvents[name]);
        }
        for (let name in windowEvents) {
            windowEvents[name] = windowEvents[name].bind(this);
            window.addEventListener(name, windowEvents[name]);
        }
    }
    __removeListenEvents() {
        super.__removeListenEvents();
        const { viewEvents, windowEvents } = this;
        for (let name in viewEvents) {
            this.view.removeEventListener(name, viewEvents[name]);
            this.viewEvents = {};
        }
        for (let name in windowEvents) {
            window.removeEventListener(name, windowEvents[name]);
            this.windowEvents = {};
        }
    }
    getTouches(touches) {
        const list = [];
        for (let i = 0, len = touches.length; i < len; i++) {
            list.push(touches[i]);
        }
        return list;
    }
    preventDefaultPointer(e) {
        const { pointer } = this.config;
        if (pointer.preventDefault)
            e.preventDefault();
    }
    preventDefaultWheel(e) {
        const { wheel } = this.config;
        if (wheel.preventDefault)
            e.preventDefault();
    }
    preventWindowPointer(e) {
        return !this.downData && e.target !== this.view;
    }
    onKeyDown(e) {
        this.keyDown(KeyEventHelper.convert(e));
    }
    onKeyUp(e) {
        this.keyUp(KeyEventHelper.convert(e));
    }
    onContextMenu(e) {
        if (this.config.pointer.preventDefaultMenu)
            e.preventDefault();
        this.menu(PointerEventHelper.convert(e, this.getLocal(e)));
    }
    onScroll() {
        this.canvas.updateClientBounds();
    }
    onPointerDown(e) {
        this.preventDefaultPointer(e);
        if (this.config.pointer.touch || this.useMultiTouch)
            return;
        this.usePointer || (this.usePointer = true);
        this.pointerDown(PointerEventHelper.convert(e, this.getLocal(e)));
    }
    onPointerMove(e) {
        if (this.config.pointer.touch || this.useMultiTouch || this.preventWindowPointer(e))
            return;
        this.usePointer || (this.usePointer = true);
        this.pointerMove(PointerEventHelper.convert(e, this.getLocal(e, true)));
    }
    onPointerUp(e) {
        if (this.downData)
            this.preventDefaultPointer(e);
        if (this.config.pointer.touch || this.useMultiTouch || this.preventWindowPointer(e))
            return;
        this.pointerUp(PointerEventHelper.convert(e, this.getLocal(e)));
    }
    onPointerCancel() {
        if (this.useMultiTouch)
            return;
        this.pointerCancel();
    }
    onMouseDown(e) {
        this.preventDefaultPointer(e);
        if (this.useTouch || this.usePointer)
            return;
        this.pointerDown(PointerEventHelper.convertMouse(e, this.getLocal(e)));
    }
    onMouseMove(e) {
        if (this.useTouch || this.usePointer || this.preventWindowPointer(e))
            return;
        this.pointerMove(PointerEventHelper.convertMouse(e, this.getLocal(e, true)));
    }
    onMouseUp(e) {
        if (this.downData)
            this.preventDefaultPointer(e);
        if (this.useTouch || this.usePointer || this.preventWindowPointer(e))
            return;
        this.pointerUp(PointerEventHelper.convertMouse(e, this.getLocal(e)));
    }
    onMouseCancel() {
        if (this.useTouch || this.usePointer)
            return;
        this.pointerCancel();
    }
    onTouchStart(e) {
        const touch = PointerEventHelper.getTouch(e);
        const local = this.getLocal(touch, true);
        const { preventDefault } = this.config.touch;
        if (preventDefault === true || (preventDefault === 'auto' && pathCanDrag(this.findPath(local))))
            e.preventDefault();
        this.multiTouchStart(e);
        if (this.usePointer)
            return;
        if (this.touchTimer) {
            window.clearTimeout(this.touchTimer);
            this.touchTimer = 0;
        }
        this.useTouch = true;
        this.pointerDown(PointerEventHelper.convertTouch(e, local));
    }
    onTouchMove(e) {
        this.multiTouchMove(e);
        if (this.usePointer || this.preventWindowPointer(e))
            return;
        const touch = PointerEventHelper.getTouch(e);
        this.pointerMove(PointerEventHelper.convertTouch(e, this.getLocal(touch)));
    }
    onTouchEnd(e) {
        this.multiTouchEnd();
        if (this.usePointer || this.preventWindowPointer(e))
            return;
        if (this.touchTimer)
            clearTimeout(this.touchTimer);
        this.touchTimer = setTimeout(() => {
            this.useTouch = false;
        }, 500);
        const touch = PointerEventHelper.getTouch(e);
        this.pointerUp(PointerEventHelper.convertTouch(e, this.getLocal(touch)));
    }
    onTouchCancel() {
        if (this.usePointer)
            return;
        this.pointerCancel();
    }
    multiTouchStart(e) {
        this.useMultiTouch = (e.touches.length > 1);
        this.touches = this.useMultiTouch ? this.getTouches(e.touches) : undefined;
        if (this.useMultiTouch)
            this.pointerCancel();
    }
    multiTouchMove(e) {
        if (!this.useMultiTouch)
            return;
        if (e.touches.length > 1) {
            const touches = this.getTouches(e.touches);
            const list = this.getKeepTouchList(this.touches, touches);
            if (list.length > 1) {
                this.multiTouch(InteractionHelper.getBase(e), list);
                this.touches = touches;
            }
        }
    }
    multiTouchEnd() {
        this.touches = null;
        this.useMultiTouch = false;
        this.transformEnd();
    }
    getKeepTouchList(old, touches) {
        let to;
        const list = [];
        old.forEach(from => {
            to = touches.find(touch => touch.identifier === from.identifier);
            if (to)
                list.push({ from: this.getLocal(from), to: this.getLocal(to) });
        });
        return list;
    }
    getLocalTouchs(points) {
        return points.map(point => this.getLocal(point));
    }
    onWheel(e) {
        this.preventDefaultWheel(e);
        const { wheel } = this.config;
        if (wheel.disabled)
            return;
        const scale = wheel.getScale ? wheel.getScale(e, wheel) : WheelEventHelper.getScale(e, wheel);
        const local = this.getLocal(e);
        const eventBase = InteractionHelper.getBase(e);
        scale !== 1 ? this.zoom(getZoomEventData(local, scale, eventBase)) : this.move(getMoveEventData(local, wheel.getMove ? wheel.getMove(e, wheel) : WheelEventHelper.getMove(e, wheel), eventBase));
    }
    onGesturestart(e) {
        if (this.useMultiTouch)
            return;
        this.preventDefaultWheel(e);
        this.lastGestureScale = 1;
        this.lastGestureRotation = 0;
    }
    onGesturechange(e) {
        if (this.useMultiTouch)
            return;
        this.preventDefaultWheel(e);
        const local = this.getLocal(e);
        const eventBase = InteractionHelper.getBase(e);
        const changeScale = e.scale / this.lastGestureScale;
        const changeAngle = e.rotation - this.lastGestureRotation;
        let { rotateSpeed } = this.config.wheel;
        rotateSpeed = MathHelper.within(rotateSpeed, 0, 1);
        this.zoom(getZoomEventData(local, changeScale * changeScale, eventBase));
        this.rotate(getRotateEventData(local, changeAngle / Math.PI * 180 * (rotateSpeed / 4 + 0.1), eventBase));
        this.lastGestureScale = e.scale;
        this.lastGestureRotation = e.rotation;
    }
    onGestureend(e) {
        if (this.useMultiTouch)
            return;
        this.preventDefaultWheel(e);
        this.transformEnd();
    }
    setCursor(cursor) {
        super.setCursor(cursor);
        const list = [];
        this.eachCursor(cursor, list);
        if (typeof list[list.length - 1] === 'object')
            list.push('default');
        this.canvas.view.style.cursor = list.map(item => (typeof item === 'object') ? `url(${item.url}) ${item.x || 0} ${item.y || 0}` : item).join(',');
    }
    eachCursor(cursor, list, level = 0) {
        level++;
        if (cursor instanceof Array) {
            cursor.forEach(item => this.eachCursor(item, list, level));
        }
        else {
            const custom = typeof cursor === 'string' && Cursor.get(cursor);
            if (custom && level < 2) {
                this.eachCursor(custom, list, level);
            }
            else {
                list.push(cursor);
            }
        }
    }
    destroy() {
        if (this.view) {
            super.destroy();
            this.view = null;
            this.touches = null;
        }
    }
}

function fillText(ui, canvas) {
    let row;
    const { rows, decorationY, decorationHeight } = ui.__.__textDrawData;
    for (let i = 0, len = rows.length; i < len; i++) {
        row = rows[i];
        if (row.text)
            canvas.fillText(row.text, row.x, row.y);
        else if (row.data)
            row.data.forEach(charData => { canvas.fillText(charData.char, charData.x, row.y); });
        if (decorationY)
            canvas.fillRect(row.x, row.y + decorationY, row.width, decorationHeight);
    }
}

function fill(fill, ui, canvas) {
    canvas.fillStyle = fill;
    ui.__.__font ? fillText(ui, canvas) : (ui.__.windingRule ? canvas.fill(ui.__.windingRule) : canvas.fill());
}
function fills(fills, ui, canvas) {
    let item;
    const { windingRule, __font } = ui.__;
    for (let i = 0, len = fills.length; i < len; i++) {
        item = fills[i];
        if (item.image && PaintImage.checkImage(ui, canvas, item, !__font))
            continue;
        if (item.style) {
            canvas.fillStyle = item.style;
            if (item.transform) {
                canvas.save();
                canvas.transform(item.transform);
                if (item.blendMode)
                    canvas.blendMode = item.blendMode;
                __font ? fillText(ui, canvas) : (windingRule ? canvas.fill(windingRule) : canvas.fill());
                canvas.restore();
            }
            else {
                if (item.blendMode) {
                    canvas.saveBlendMode(item.blendMode);
                    __font ? fillText(ui, canvas) : (windingRule ? canvas.fill(windingRule) : canvas.fill());
                    canvas.restoreBlendMode();
                }
                else {
                    __font ? fillText(ui, canvas) : (windingRule ? canvas.fill(windingRule) : canvas.fill());
                }
            }
        }
    }
}

function strokeText(stroke, ui, canvas) {
    const { strokeAlign } = ui.__;
    const isStrokes = typeof stroke !== 'string';
    switch (strokeAlign) {
        case 'center':
            canvas.setStroke(isStrokes ? undefined : stroke, ui.__.strokeWidth, ui.__);
            isStrokes ? drawStrokesStyle(stroke, true, ui, canvas) : drawTextStroke(ui, canvas);
            break;
        case 'inside':
            drawAlignStroke('inside', stroke, isStrokes, ui, canvas);
            break;
        case 'outside':
            drawAlignStroke('outside', stroke, isStrokes, ui, canvas);
            break;
    }
}
function drawAlignStroke(align, stroke, isStrokes, ui, canvas) {
    const { __strokeWidth, __font } = ui.__;
    const out = canvas.getSameCanvas(true, true);
    out.setStroke(isStrokes ? undefined : stroke, __strokeWidth * 2, ui.__);
    out.font = __font;
    isStrokes ? drawStrokesStyle(stroke, true, ui, out) : drawTextStroke(ui, out);
    out.blendMode = align === 'outside' ? 'destination-out' : 'destination-in';
    fillText(ui, out);
    out.blendMode = 'normal';
    if (ui.__worldFlipped)
        canvas.copyWorldByReset(out, ui.__nowWorld);
    else
        canvas.copyWorldToInner(out, ui.__nowWorld, ui.__layout.renderBounds);
    out.recycle(ui.__nowWorld);
}
function drawTextStroke(ui, canvas) {
    let row;
    const { rows, decorationY, decorationHeight } = ui.__.__textDrawData;
    for (let i = 0, len = rows.length; i < len; i++) {
        row = rows[i];
        if (row.text)
            canvas.strokeText(row.text, row.x, row.y);
        else if (row.data)
            row.data.forEach(charData => { canvas.strokeText(charData.char, charData.x, row.y); });
        if (decorationY)
            canvas.strokeRect(row.x, row.y + decorationY, row.width, decorationHeight);
    }
}
function drawStrokesStyle(strokes, isText, ui, canvas) {
    let item;
    for (let i = 0, len = strokes.length; i < len; i++) {
        item = strokes[i];
        if (item.image && PaintImage.checkImage(ui, canvas, item, false))
            continue;
        if (item.style) {
            canvas.strokeStyle = item.style;
            if (item.blendMode) {
                canvas.saveBlendMode(item.blendMode);
                isText ? drawTextStroke(ui, canvas) : canvas.stroke();
                canvas.restoreBlendMode();
            }
            else {
                isText ? drawTextStroke(ui, canvas) : canvas.stroke();
            }
        }
    }
}

function stroke(stroke, ui, canvas) {
    const options = ui.__;
    const { __strokeWidth, strokeAlign, __font } = options;
    if (!__strokeWidth)
        return;
    if (__font) {
        strokeText(stroke, ui, canvas);
    }
    else {
        switch (strokeAlign) {
            case 'center':
                canvas.setStroke(stroke, __strokeWidth, options);
                canvas.stroke();
                break;
            case 'inside':
                canvas.save();
                canvas.setStroke(stroke, __strokeWidth * 2, options);
                options.windingRule ? canvas.clip(options.windingRule) : canvas.clip();
                canvas.stroke();
                canvas.restore();
                break;
            case 'outside':
                const out = canvas.getSameCanvas(true, true);
                out.setStroke(stroke, __strokeWidth * 2, options);
                ui.__drawRenderPath(out);
                out.stroke();
                options.windingRule ? out.clip(options.windingRule) : out.clip();
                out.clearWorld(ui.__layout.renderBounds);
                if (ui.__worldFlipped)
                    canvas.copyWorldByReset(out, ui.__nowWorld);
                else
                    canvas.copyWorldToInner(out, ui.__nowWorld, ui.__layout.renderBounds);
                out.recycle(ui.__nowWorld);
                break;
        }
    }
}
function strokes(strokes, ui, canvas) {
    const options = ui.__;
    const { __strokeWidth, strokeAlign, __font } = options;
    if (!__strokeWidth)
        return;
    if (__font) {
        strokeText(strokes, ui, canvas);
    }
    else {
        switch (strokeAlign) {
            case 'center':
                canvas.setStroke(undefined, __strokeWidth, options);
                drawStrokesStyle(strokes, false, ui, canvas);
                break;
            case 'inside':
                canvas.save();
                canvas.setStroke(undefined, __strokeWidth * 2, options);
                options.windingRule ? canvas.clip(options.windingRule) : canvas.clip();
                drawStrokesStyle(strokes, false, ui, canvas);
                canvas.restore();
                break;
            case 'outside':
                const { renderBounds } = ui.__layout;
                const out = canvas.getSameCanvas(true, true);
                ui.__drawRenderPath(out);
                out.setStroke(undefined, __strokeWidth * 2, options);
                drawStrokesStyle(strokes, false, ui, out);
                options.windingRule ? out.clip(options.windingRule) : out.clip();
                out.clearWorld(renderBounds);
                if (ui.__worldFlipped)
                    canvas.copyWorldByReset(out, ui.__nowWorld);
                else
                    canvas.copyWorldToInner(out, ui.__nowWorld, renderBounds);
                out.recycle(ui.__nowWorld);
                break;
        }
    }
}

const { getSpread, getOuterOf, getByMove, getIntersectData } = BoundsHelper;
function shape(ui, current, options) {
    const canvas = current.getSameCanvas();
    const nowWorld = ui.__nowWorld;
    let bounds, fitMatrix, shapeBounds, worldCanvas;
    let { scaleX, scaleY } = nowWorld;
    if (scaleX < 0)
        scaleX = -scaleX;
    if (scaleY < 0)
        scaleY = -scaleY;
    if (current.bounds.includes(nowWorld)) {
        worldCanvas = canvas;
        bounds = shapeBounds = nowWorld;
    }
    else {
        const { renderShapeSpread: spread } = ui.__layout;
        const worldClipBounds = getIntersectData(spread ? getSpread(current.bounds, scaleX === scaleY ? spread * scaleX : [spread * scaleY, spread * scaleX]) : current.bounds, nowWorld);
        fitMatrix = current.bounds.getFitMatrix(worldClipBounds);
        let { a: fitScaleX, d: fitScaleY } = fitMatrix;
        if (fitMatrix.a < 1) {
            worldCanvas = current.getSameCanvas();
            ui.__renderShape(worldCanvas, options);
            scaleX *= fitScaleX;
            scaleY *= fitScaleY;
        }
        shapeBounds = getOuterOf(nowWorld, fitMatrix);
        bounds = getByMove(shapeBounds, -fitMatrix.e, -fitMatrix.f);
        if (options.matrix) {
            const { matrix } = options;
            fitMatrix.multiply(matrix);
            fitScaleX *= matrix.scaleX;
            fitScaleY *= matrix.scaleY;
        }
        options = Object.assign(Object.assign({}, options), { matrix: fitMatrix.withScale(fitScaleX, fitScaleY) });
    }
    ui.__renderShape(canvas, options);
    return {
        canvas, matrix: fitMatrix, bounds,
        worldCanvas, shapeBounds, scaleX, scaleY
    };
}

let recycleMap;
function compute(attrName, ui) {
    const data = ui.__, leafPaints = [];
    let paints = data.__input[attrName], hasOpacityPixel;
    if (!(paints instanceof Array))
        paints = [paints];
    recycleMap = PaintImage.recycleImage(attrName, data);
    for (let i = 0, len = paints.length, item; i < len; i++) {
        item = getLeafPaint(attrName, paints[i], ui);
        if (item)
            leafPaints.push(item);
    }
    data['_' + attrName] = leafPaints.length ? leafPaints : undefined;
    if (leafPaints.length && leafPaints[0].image)
        hasOpacityPixel = leafPaints[0].image.hasOpacityPixel;
    attrName === 'fill' ? data.__pixelFill = hasOpacityPixel : data.__pixelStroke = hasOpacityPixel;
}
function getLeafPaint(attrName, paint, ui) {
    if (typeof paint !== 'object' || paint.visible === false || paint.opacity === 0)
        return undefined;
    const { boxBounds } = ui.__layout;
    switch (paint.type) {
        case 'solid':
            let { type, blendMode, color, opacity } = paint;
            return { type, blendMode, style: ColorConvert.string(color, opacity) };
        case 'image':
            return PaintImage.image(ui, attrName, paint, boxBounds, !recycleMap || !recycleMap[paint.url]);
        case 'linear':
            return PaintGradient.linearGradient(paint, boxBounds);
        case 'radial':
            return PaintGradient.radialGradient(paint, boxBounds);
        case 'angular':
            return PaintGradient.conicGradient(paint, boxBounds);
        default:
            return paint.r !== undefined ? { type: 'solid', style: ColorConvert.string(paint) } : undefined;
    }
}

const PaintModule = {
    compute,
    fill,
    fills,
    fillText,
    stroke,
    strokes,
    strokeText,
    drawTextStroke,
    shape
};

let origin = {};
const { get: get$3, rotateOfOuter: rotateOfOuter$1, translate: translate$1, scaleOfOuter: scaleOfOuter$1, scale: scaleHelper, rotate } = MatrixHelper;
function fillOrFitMode(data, box, x, y, scaleX, scaleY, rotation) {
    const transform = get$3();
    translate$1(transform, box.x + x, box.y + y);
    scaleHelper(transform, scaleX, scaleY);
    if (rotation)
        rotateOfOuter$1(transform, { x: box.x + box.width / 2, y: box.y + box.height / 2 }, rotation);
    data.transform = transform;
}
function clipMode(data, box, x, y, scaleX, scaleY, rotation) {
    const transform = get$3();
    translate$1(transform, box.x + x, box.y + y);
    if (scaleX)
        scaleHelper(transform, scaleX, scaleY);
    if (rotation)
        rotate(transform, rotation);
    data.transform = transform;
}
function repeatMode(data, box, width, height, x, y, scaleX, scaleY, rotation, align) {
    const transform = get$3();
    if (rotation) {
        if (align === 'center') {
            rotateOfOuter$1(transform, { x: width / 2, y: height / 2 }, rotation);
        }
        else {
            rotate(transform, rotation);
            switch (rotation) {
                case 90:
                    translate$1(transform, height, 0);
                    break;
                case 180:
                    translate$1(transform, width, height);
                    break;
                case 270:
                    translate$1(transform, 0, width);
                    break;
            }
        }
    }
    origin.x = box.x + x;
    origin.y = box.y + y;
    translate$1(transform, origin.x, origin.y);
    if (scaleX)
        scaleOfOuter$1(transform, origin, scaleX, scaleY);
    data.transform = transform;
}

const { get: get$2, translate } = MatrixHelper;
const tempBox = new Bounds();
const tempPoint = {};
const tempScaleData = {};
function createData(leafPaint, image, paint, box) {
    const { blendMode, sync } = paint;
    if (blendMode)
        leafPaint.blendMode = blendMode;
    if (sync)
        leafPaint.sync = sync;
    leafPaint.data = getPatternData(paint, box, image);
}
function getPatternData(paint, box, image) {
    let { width, height } = image;
    if (paint.padding)
        box = tempBox.set(box).shrink(paint.padding);
    if (paint.mode === 'strench')
        paint.mode = 'stretch';
    const { opacity, mode, align, offset, scale, size, rotation, repeat } = paint;
    const sameBox = box.width === width && box.height === height;
    const data = { mode };
    const swapSize = align !== 'center' && (rotation || 0) % 180 === 90;
    const swapWidth = swapSize ? height : width, swapHeight = swapSize ? width : height;
    let x = 0, y = 0, scaleX, scaleY;
    if (!mode || mode === 'cover' || mode === 'fit') {
        if (!sameBox || rotation) {
            const sw = box.width / swapWidth, sh = box.height / swapHeight;
            scaleX = scaleY = mode === 'fit' ? Math.min(sw, sh) : Math.max(sw, sh);
            x += (box.width - width * scaleX) / 2, y += (box.height - height * scaleY) / 2;
        }
    }
    else if (scale || size) {
        MathHelper.getScaleData(scale, size, image, tempScaleData);
        scaleX = tempScaleData.scaleX;
        scaleY = tempScaleData.scaleY;
    }
    if (align) {
        const imageBounds = { x, y, width: swapWidth, height: swapHeight };
        if (scaleX)
            imageBounds.width *= scaleX, imageBounds.height *= scaleY;
        AlignHelper.toPoint(align, imageBounds, box, tempPoint, true);
        x += tempPoint.x, y += tempPoint.y;
    }
    if (offset)
        x += offset.x, y += offset.y;
    switch (mode) {
        case 'stretch':
            if (!sameBox)
                width = box.width, height = box.height;
            break;
        case 'normal':
        case 'clip':
            if (x || y || scaleX || rotation)
                clipMode(data, box, x, y, scaleX, scaleY, rotation);
            break;
        case 'repeat':
            if (!sameBox || scaleX || rotation)
                repeatMode(data, box, width, height, x, y, scaleX, scaleY, rotation, align);
            if (!repeat)
                data.repeat = 'repeat';
            break;
        case 'fit':
        case 'cover':
        default:
            if (scaleX)
                fillOrFitMode(data, box, x, y, scaleX, scaleY, rotation);
    }
    if (!data.transform) {
        if (box.x || box.y) {
            data.transform = get$2();
            translate(data.transform, box.x, box.y);
        }
    }
    if (scaleX && mode !== 'stretch') {
        data.scaleX = scaleX;
        data.scaleY = scaleY;
    }
    data.width = width;
    data.height = height;
    if (opacity)
        data.opacity = opacity;
    if (repeat)
        data.repeat = typeof repeat === 'string' ? (repeat === 'x' ? 'repeat-x' : 'repeat-y') : 'repeat';
    return data;
}

let cache, box = new Bounds();
const { isSame } = BoundsHelper;
function image(ui, attrName, paint, boxBounds, firstUse) {
    let leafPaint, event;
    const image = ImageManager.get(paint);
    if (cache && paint === cache.paint && isSame(boxBounds, cache.boxBounds)) {
        leafPaint = cache.leafPaint;
    }
    else {
        leafPaint = { type: paint.type, image };
        cache = image.use > 1 ? { leafPaint, paint, boxBounds: box.set(boxBounds) } : null;
    }
    if (firstUse || image.loading)
        event = { image, attrName, attrValue: paint };
    if (image.ready) {
        checkSizeAndCreateData(ui, attrName, paint, image, leafPaint, boxBounds);
        if (firstUse) {
            onLoad(ui, event);
            onLoadSuccess(ui, event);
        }
    }
    else if (image.error) {
        if (firstUse)
            onLoadError(ui, event, image.error);
    }
    else {
        if (firstUse) {
            ignoreRender(ui, true);
            onLoad(ui, event);
        }
        leafPaint.loadId = image.load(() => {
            ignoreRender(ui, false);
            if (!ui.destroyed) {
                if (checkSizeAndCreateData(ui, attrName, paint, image, leafPaint, boxBounds)) {
                    if (image.hasOpacityPixel)
                        ui.__layout.hitCanvasChanged = true;
                    ui.forceUpdate('surface');
                }
                onLoadSuccess(ui, event);
            }
            leafPaint.loadId = null;
        }, (error) => {
            ignoreRender(ui, false);
            onLoadError(ui, event, error);
            leafPaint.loadId = null;
        });
    }
    return leafPaint;
}
function checkSizeAndCreateData(ui, attrName, paint, image, leafPaint, boxBounds) {
    if (attrName === 'fill' && !ui.__.__naturalWidth) {
        const data = ui.__;
        data.__naturalWidth = image.width / data.pixelRatio;
        data.__naturalHeight = image.height / data.pixelRatio;
        if (data.__autoSide) {
            ui.forceUpdate('width');
            if (ui.__proxyData) {
                ui.setProxyAttr('width', data.width);
                ui.setProxyAttr('height', data.height);
            }
            return false;
        }
    }
    if (!leafPaint.data)
        createData(leafPaint, image, paint, boxBounds);
    return true;
}
function onLoad(ui, event) {
    emit(ui, ImageEvent.LOAD, event);
}
function onLoadSuccess(ui, event) {
    emit(ui, ImageEvent.LOADED, event);
}
function onLoadError(ui, event, error) {
    event.error = error;
    ui.forceUpdate('surface');
    emit(ui, ImageEvent.ERROR, event);
}
function emit(ui, type, data) {
    if (ui.hasEvent(type))
        ui.emitEvent(new ImageEvent(type, data));
}
function ignoreRender(ui, value) {
    const { leafer } = ui;
    if (leafer && leafer.viewReady)
        leafer.renderer.ignore = value;
}

const { get: get$1, scale, copy: copy$1 } = MatrixHelper;
const { ceil, abs: abs$1 } = Math;
function createPattern(ui, paint, pixelRatio) {
    let { scaleX, scaleY } = ImageManager.patternLocked ? ui.__world : ui.__nowWorld;
    const id = scaleX + '-' + scaleY + '-' + pixelRatio;
    if (paint.patternId !== id && !ui.destroyed) {
        scaleX = abs$1(scaleX);
        scaleY = abs$1(scaleY);
        const { image, data } = paint;
        let imageScale, imageMatrix, { width, height, scaleX: sx, scaleY: sy, opacity, transform, repeat } = data;
        if (sx) {
            imageMatrix = get$1();
            copy$1(imageMatrix, transform);
            scale(imageMatrix, 1 / sx, 1 / sy);
            scaleX *= sx;
            scaleY *= sy;
        }
        scaleX *= pixelRatio;
        scaleY *= pixelRatio;
        width *= scaleX;
        height *= scaleY;
        const size = width * height;
        if (!repeat) {
            if (size > Platform.image.maxCacheSize)
                return false;
        }
        let maxSize = Platform.image.maxPatternSize;
        if (!image.isSVG) {
            const imageSize = image.width * image.height;
            if (maxSize > imageSize)
                maxSize = imageSize;
        }
        if (size > maxSize)
            imageScale = Math.sqrt(size / maxSize);
        if (imageScale) {
            scaleX /= imageScale;
            scaleY /= imageScale;
            width /= imageScale;
            height /= imageScale;
        }
        if (sx) {
            scaleX /= sx;
            scaleY /= sy;
        }
        if (transform || scaleX !== 1 || scaleY !== 1) {
            if (!imageMatrix) {
                imageMatrix = get$1();
                if (transform)
                    copy$1(imageMatrix, transform);
            }
            scale(imageMatrix, 1 / scaleX, 1 / scaleY);
        }
        const canvas = image.getCanvas(ceil(width) || 1, ceil(height) || 1, opacity);
        const pattern = image.getPattern(canvas, repeat || (Platform.origin.noRepeat || 'no-repeat'), imageMatrix, paint);
        paint.style = pattern;
        paint.patternId = id;
        return true;
    }
    else {
        return false;
    }
}

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol */


function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

const { abs } = Math;
function checkImage(ui, canvas, paint, allowPaint) {
    const { scaleX, scaleY } = ImageManager.patternLocked ? ui.__world : ui.__nowWorld;
    const { pixelRatio } = canvas;
    if (!paint.data || (paint.patternId === scaleX + '-' + scaleY + '-' + pixelRatio && !Export.running)) {
        return false;
    }
    else {
        const { data } = paint;
        if (allowPaint) {
            if (!data.repeat) {
                let { width, height } = data;
                width *= abs(scaleX) * pixelRatio;
                height *= abs(scaleY) * pixelRatio;
                if (data.scaleX) {
                    width *= data.scaleX;
                    height *= data.scaleY;
                }
                allowPaint = (width * height > Platform.image.maxCacheSize) || Export.running;
            }
            else {
                allowPaint = false;
            }
        }
        if (allowPaint) {
            canvas.save();
            ui.windingRule ? canvas.clip(ui.windingRule) : canvas.clip();
            if (paint.blendMode)
                canvas.blendMode = paint.blendMode;
            if (data.opacity)
                canvas.opacity *= data.opacity;
            if (data.transform)
                canvas.transform(data.transform);
            canvas.drawImage(paint.image.view, 0, 0, data.width, data.height);
            canvas.restore();
            return true;
        }
        else {
            if (!paint.style || paint.sync || Export.running) {
                createPattern(ui, paint, pixelRatio);
            }
            else {
                if (!paint.patternTask) {
                    paint.patternTask = ImageManager.patternTasker.add(() => __awaiter(this, void 0, void 0, function* () {
                        paint.patternTask = null;
                        if (canvas.bounds.hit(ui.__nowWorld))
                            createPattern(ui, paint, pixelRatio);
                        ui.forceUpdate('surface');
                    }), 300);
                }
            }
            return false;
        }
    }
}

function recycleImage(attrName, data) {
    const paints = data['_' + attrName];
    if (paints instanceof Array) {
        let image, recycleMap, input, url;
        for (let i = 0, len = paints.length; i < len; i++) {
            image = paints[i].image;
            url = image && image.url;
            if (url) {
                if (!recycleMap)
                    recycleMap = {};
                recycleMap[url] = true;
                ImageManager.recycle(image);
                if (image.loading) {
                    if (!input) {
                        input = (data.__input && data.__input[attrName]) || [];
                        if (!(input instanceof Array))
                            input = [input];
                    }
                    image.unload(paints[i].loadId, !input.some((item) => item.url === url));
                }
            }
        }
        return recycleMap;
    }
    return null;
}

const PaintImageModule = {
    image,
    checkImage,
    createPattern,
    recycleImage,
    createData,
    getPatternData,
    fillOrFitMode,
    clipMode,
    repeatMode
};

const { toPoint: toPoint$2 } = AroundHelper;
const realFrom$2 = {};
const realTo$2 = {};
function linearGradient(paint, box) {
    let { from, to, type, blendMode, opacity } = paint;
    toPoint$2(from || 'top', box, realFrom$2);
    toPoint$2(to || 'bottom', box, realTo$2);
    const style = Platform.canvas.createLinearGradient(realFrom$2.x, realFrom$2.y, realTo$2.x, realTo$2.y);
    applyStops(style, paint.stops, opacity);
    const data = { type, style };
    if (blendMode)
        data.blendMode = blendMode;
    return data;
}
function applyStops(gradient, stops, opacity) {
    if (stops) {
        let stop;
        for (let i = 0, len = stops.length; i < len; i++) {
            stop = stops[i];
            if (typeof stop === 'string') {
                gradient.addColorStop(i / (len - 1), ColorConvert.string(stop, opacity));
            }
            else {
                gradient.addColorStop(stop.offset, ColorConvert.string(stop.color, opacity));
            }
        }
    }
}

const { getAngle, getDistance: getDistance$1 } = PointHelper;
const { get, rotateOfOuter, scaleOfOuter } = MatrixHelper;
const { toPoint: toPoint$1 } = AroundHelper;
const realFrom$1 = {};
const realTo$1 = {};
function radialGradient(paint, box) {
    let { from, to, type, opacity, blendMode, stretch } = paint;
    toPoint$1(from || 'center', box, realFrom$1);
    toPoint$1(to || 'bottom', box, realTo$1);
    const style = Platform.canvas.createRadialGradient(realFrom$1.x, realFrom$1.y, 0, realFrom$1.x, realFrom$1.y, getDistance$1(realFrom$1, realTo$1));
    applyStops(style, paint.stops, opacity);
    const data = { type, style };
    const transform = getTransform(box, realFrom$1, realTo$1, stretch, true);
    if (transform)
        data.transform = transform;
    if (blendMode)
        data.blendMode = blendMode;
    return data;
}
function getTransform(box, from, to, stretch, rotate90) {
    let transform;
    const { width, height } = box;
    if (width !== height || stretch) {
        const angle = getAngle(from, to);
        transform = get();
        if (rotate90) {
            scaleOfOuter(transform, from, width / height * (stretch || 1), 1);
            rotateOfOuter(transform, from, angle + 90);
        }
        else {
            scaleOfOuter(transform, from, 1, width / height * (stretch || 1));
            rotateOfOuter(transform, from, angle);
        }
    }
    return transform;
}

const { getDistance } = PointHelper;
const { toPoint } = AroundHelper;
const realFrom = {};
const realTo = {};
function conicGradient(paint, box) {
    let { from, to, type, opacity, blendMode, stretch } = paint;
    toPoint(from || 'center', box, realFrom);
    toPoint(to || 'bottom', box, realTo);
    const style = Platform.conicGradientSupport ? Platform.canvas.createConicGradient(0, realFrom.x, realFrom.y) : Platform.canvas.createRadialGradient(realFrom.x, realFrom.y, 0, realFrom.x, realFrom.y, getDistance(realFrom, realTo));
    applyStops(style, paint.stops, opacity);
    const data = { type, style };
    const transform = getTransform(box, realFrom, realTo, stretch || 1, Platform.conicGradientRotate90);
    if (transform)
        data.transform = transform;
    if (blendMode)
        data.blendMode = blendMode;
    return data;
}

const PaintGradientModule = {
    linearGradient,
    radialGradient,
    conicGradient,
    getTransform
};

const { copy, toOffsetOutBounds: toOffsetOutBounds$1 } = BoundsHelper;
const tempBounds = {};
const offsetOutBounds$1 = {};
function shadow(ui, current, shape) {
    let copyBounds, spreadScale;
    const { __nowWorld: nowWorld, __layout } = ui;
    const { shadow } = ui.__;
    const { worldCanvas, bounds, shapeBounds, scaleX, scaleY } = shape;
    const other = current.getSameCanvas();
    const end = shadow.length - 1;
    toOffsetOutBounds$1(bounds, offsetOutBounds$1);
    shadow.forEach((item, index) => {
        other.setWorldShadow((offsetOutBounds$1.offsetX + item.x * scaleX), (offsetOutBounds$1.offsetY + item.y * scaleY), item.blur * scaleX, item.color);
        spreadScale = item.spread ? 1 + item.spread * 2 / (__layout.boxBounds.width + (__layout.strokeBoxSpread || 0) * 2) : 0;
        drawWorldShadow(other, offsetOutBounds$1, spreadScale, shape);
        copyBounds = bounds;
        if (item.box) {
            other.restore();
            other.save();
            if (worldCanvas) {
                other.copyWorld(other, bounds, nowWorld, 'copy');
                copyBounds = nowWorld;
            }
            worldCanvas ? other.copyWorld(worldCanvas, nowWorld, nowWorld, 'destination-out') : other.copyWorld(shape.canvas, shapeBounds, bounds, 'destination-out');
        }
        if (ui.__worldFlipped) {
            current.copyWorldByReset(other, copyBounds, nowWorld, item.blendMode);
        }
        else {
            current.copyWorldToInner(other, copyBounds, __layout.renderBounds, item.blendMode);
        }
        if (end && index < end)
            other.clearWorld(copyBounds, true);
    });
    other.recycle(copyBounds);
}
function drawWorldShadow(canvas, outBounds, spreadScale, shape) {
    const { bounds, shapeBounds } = shape;
    if (Platform.fullImageShadow) {
        copy(tempBounds, canvas.bounds);
        tempBounds.x += (outBounds.x - shapeBounds.x);
        tempBounds.y += (outBounds.y - shapeBounds.y);
        if (spreadScale) {
            const { matrix } = shape;
            tempBounds.x -= (bounds.x + (matrix ? matrix.e : 0) + bounds.width / 2) * (spreadScale - 1);
            tempBounds.y -= (bounds.y + (matrix ? matrix.f : 0) + bounds.height / 2) * (spreadScale - 1);
            tempBounds.width *= spreadScale;
            tempBounds.height *= spreadScale;
        }
        canvas.copyWorld(shape.canvas, canvas.bounds, tempBounds);
    }
    else {
        if (spreadScale) {
            copy(tempBounds, outBounds);
            tempBounds.x -= (outBounds.width / 2) * (spreadScale - 1);
            tempBounds.y -= (outBounds.height / 2) * (spreadScale - 1);
            tempBounds.width *= spreadScale;
            tempBounds.height *= spreadScale;
        }
        canvas.copyWorld(shape.canvas, shapeBounds, spreadScale ? tempBounds : outBounds);
    }
}

const { toOffsetOutBounds } = BoundsHelper;
const offsetOutBounds = {};
function innerShadow(ui, current, shape) {
    let copyBounds, spreadScale;
    const { __nowWorld: nowWorld, __layout: __layout } = ui;
    const { innerShadow } = ui.__;
    const { worldCanvas, bounds, shapeBounds, scaleX, scaleY } = shape;
    const other = current.getSameCanvas();
    const end = innerShadow.length - 1;
    toOffsetOutBounds(bounds, offsetOutBounds);
    innerShadow.forEach((item, index) => {
        other.save();
        other.setWorldShadow((offsetOutBounds.offsetX + item.x * scaleX), (offsetOutBounds.offsetY + item.y * scaleY), item.blur * scaleX);
        spreadScale = item.spread ? 1 - item.spread * 2 / (__layout.boxBounds.width + (__layout.strokeBoxSpread || 0) * 2) : 0;
        drawWorldShadow(other, offsetOutBounds, spreadScale, shape);
        other.restore();
        if (worldCanvas) {
            other.copyWorld(other, bounds, nowWorld, 'copy');
            other.copyWorld(worldCanvas, nowWorld, nowWorld, 'source-out');
            copyBounds = nowWorld;
        }
        else {
            other.copyWorld(shape.canvas, shapeBounds, bounds, 'source-out');
            copyBounds = bounds;
        }
        other.fillWorld(copyBounds, item.color, 'source-in');
        if (ui.__worldFlipped) {
            current.copyWorldByReset(other, copyBounds, nowWorld, item.blendMode);
        }
        else {
            current.copyWorldToInner(other, copyBounds, __layout.renderBounds, item.blendMode);
        }
        if (end && index < end)
            other.clearWorld(copyBounds, true);
    });
    other.recycle(copyBounds);
}

function blur(ui, current, origin) {
    const { blur } = ui.__;
    origin.setWorldBlur(blur * ui.__nowWorld.a);
    origin.copyWorldToInner(current, ui.__nowWorld, ui.__layout.renderBounds);
    origin.filter = 'none';
}

function backgroundBlur(_ui, _current, _shape) {
}

const EffectModule = {
    shadow,
    innerShadow,
    blur,
    backgroundBlur
};

const { excludeRenderBounds } = LeafBoundsHelper;
Group.prototype.__renderMask = function (canvas, options) {
    let child, maskCanvas, contentCanvas, maskOpacity, currentMask;
    const { children } = this;
    for (let i = 0, len = children.length; i < len; i++) {
        child = children[i];
        if (child.__.mask) {
            if (currentMask) {
                maskEnd(this, currentMask, canvas, contentCanvas, maskCanvas, maskOpacity);
                maskCanvas = contentCanvas = null;
            }
            if (child.__.mask === 'path') {
                if (child.opacity < 1) {
                    currentMask = 'opacity-path';
                    maskOpacity = child.opacity;
                    if (!contentCanvas)
                        contentCanvas = getCanvas(canvas);
                }
                else {
                    currentMask = 'path';
                    canvas.save();
                }
                child.__clip(contentCanvas || canvas, options);
            }
            else {
                currentMask = 'alpha';
                if (!maskCanvas)
                    maskCanvas = getCanvas(canvas);
                if (!contentCanvas)
                    contentCanvas = getCanvas(canvas);
                child.__render(maskCanvas, options);
            }
            if (child.__.mask !== 'clipping')
                continue;
        }
        if (excludeRenderBounds(child, options))
            continue;
        child.__render(contentCanvas || canvas, options);
    }
    maskEnd(this, currentMask, canvas, contentCanvas, maskCanvas, maskOpacity);
};
function maskEnd(leaf, maskMode, canvas, contentCanvas, maskCanvas, maskOpacity) {
    switch (maskMode) {
        case 'alpha':
            usePixelMask(leaf, canvas, contentCanvas, maskCanvas);
            break;
        case 'opacity-path':
            copyContent(leaf, canvas, contentCanvas, maskOpacity);
            break;
        case 'path':
            canvas.restore();
    }
}
function getCanvas(canvas) {
    return canvas.getSameCanvas(false, true);
}
function usePixelMask(leaf, canvas, content, mask) {
    const realBounds = leaf.__nowWorld;
    content.resetTransform();
    content.opacity = 1;
    content.useMask(mask, realBounds);
    mask.recycle(realBounds);
    copyContent(leaf, canvas, content, 1);
}
function copyContent(leaf, canvas, content, maskOpacity) {
    const realBounds = leaf.__nowWorld;
    canvas.resetTransform();
    canvas.opacity = maskOpacity;
    canvas.copyWorld(content, realBounds);
    content.recycle(realBounds);
}

const money = '';
const letter = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz';
const langBefore = '' + money;
const langAfter = '';
const langSymbol = '';
const langBreak$1 = '';
const beforeChar = '{[(<\'"' + langBefore;
const afterChar = '>)]}%!?,.:;\'"' + langAfter;
const symbolChar = afterChar + '_#~&*+\\=|' + langSymbol;
const breakChar = '- ' + langBreak$1;
const cjkRangeList = [
    [0x4E00, 0x9FFF],
    [0x3400, 0x4DBF],
    [0x20000, 0x2A6DF],
    [0x2A700, 0x2B73F],
    [0x2B740, 0x2B81F],
    [0x2B820, 0x2CEAF],
    [0x2CEB0, 0x2EBEF],
    [0x30000, 0x3134F],
    [0x31350, 0x323AF],
    [0x2E80, 0x2EFF],
    [0x2F00, 0x2FDF],
    [0x2FF0, 0x2FFF],
    [0x3000, 0x303F],
    [0x31C0, 0x31EF],
    [0x3200, 0x32FF],
    [0x3300, 0x33FF],
    [0xF900, 0xFAFF],
    [0xFE30, 0xFE4F],
    [0x1F200, 0x1F2FF],
    [0x2F800, 0x2FA1F],
];
const cjkReg = new RegExp(cjkRangeList.map(([start, end]) => `[\\u${start.toString(16)}-\\u${end.toString(16)}]`).join('|'));
function mapChar(str) {
    const map = {};
    str.split('').forEach(char => map[char] = true);
    return map;
}
const letterMap = mapChar(letter);
const beforeMap = mapChar(beforeChar);
const afterMap = mapChar(afterChar);
const symbolMap = mapChar(symbolChar);
const breakMap = mapChar(breakChar);
var CharType;
(function (CharType) {
    CharType[CharType["Letter"] = 0] = "Letter";
    CharType[CharType["Single"] = 1] = "Single";
    CharType[CharType["Before"] = 2] = "Before";
    CharType[CharType["After"] = 3] = "After";
    CharType[CharType["Symbol"] = 4] = "Symbol";
    CharType[CharType["Break"] = 5] = "Break";
})(CharType || (CharType = {}));
const { Letter: Letter$1, Single: Single$1, Before: Before$1, After: After$1, Symbol: Symbol$1, Break: Break$1 } = CharType;
function getCharType(char) {
    if (letterMap[char]) {
        return Letter$1;
    }
    else if (breakMap[char]) {
        return Break$1;
    }
    else if (beforeMap[char]) {
        return Before$1;
    }
    else if (afterMap[char]) {
        return After$1;
    }
    else if (symbolMap[char]) {
        return Symbol$1;
    }
    else if (cjkReg.test(char)) {
        return Single$1;
    }
    else {
        return Letter$1;
    }
}

const TextRowHelper = {
    trimRight(row) {
        const { words } = row;
        let trimRight = 0, len = words.length, char;
        for (let i = len - 1; i > -1; i--) {
            char = words[i].data[0];
            if (char.char === ' ') {
                trimRight++;
                row.width -= char.width;
            }
            else {
                break;
            }
        }
        if (trimRight)
            words.splice(len - trimRight, trimRight);
    }
};

function getTextCase(char, textCase, firstChar) {
    switch (textCase) {
        case 'title':
            return firstChar ? char.toUpperCase() : char;
        case 'upper':
            return char.toUpperCase();
        case 'lower':
            return char.toLowerCase();
        default:
            return char;
    }
}

const { trimRight } = TextRowHelper;
const { Letter, Single, Before, After, Symbol, Break } = CharType;
let word, row, wordWidth, rowWidth, realWidth;
let char, charWidth, startCharSize, charSize, charType, lastCharType, langBreak, afterBreak, paraStart;
let textDrawData, rows = [], bounds, findMaxWidth;
function createRows(drawData, content, style) {
    textDrawData = drawData;
    rows = drawData.rows;
    bounds = drawData.bounds;
    findMaxWidth = !bounds.width && !style.autoSizeAlign;
    const { __letterSpacing, paraIndent, textCase } = style;
    const { canvas } = Platform;
    const { width, height } = bounds;
    const charMode = width || height || __letterSpacing || (textCase !== 'none');
    if (charMode) {
        const wrap = style.textWrap !== 'none';
        const breakAll = style.textWrap === 'break';
        paraStart = true;
        lastCharType = null;
        startCharSize = charWidth = charSize = wordWidth = rowWidth = 0;
        word = { data: [] }, row = { words: [] };
        for (let i = 0, len = content.length; i < len; i++) {
            char = content[i];
            if (char === '\n') {
                if (wordWidth)
                    addWord();
                row.paraEnd = true;
                addRow();
                paraStart = true;
            }
            else {
                charType = getCharType(char);
                if (charType === Letter && textCase !== 'none')
                    char = getTextCase(char, textCase, !wordWidth);
                charWidth = canvas.measureText(char).width;
                if (__letterSpacing) {
                    if (__letterSpacing < 0)
                        charSize = charWidth;
                    charWidth += __letterSpacing;
                }
                langBreak = (charType === Single && (lastCharType === Single || lastCharType === Letter)) || (lastCharType === Single && charType !== After);
                afterBreak = ((charType === Before || charType === Single) && (lastCharType === Symbol || lastCharType === After));
                realWidth = paraStart && paraIndent ? width - paraIndent : width;
                if (wrap && (width && rowWidth + wordWidth + charWidth > realWidth)) {
                    if (breakAll) {
                        if (wordWidth)
                            addWord();
                        if (rowWidth)
                            addRow();
                    }
                    else {
                        if (!afterBreak)
                            afterBreak = charType === Letter && lastCharType == After;
                        if (langBreak || afterBreak || charType === Break || charType === Before || charType === Single || (wordWidth + charWidth > realWidth)) {
                            if (wordWidth)
                                addWord();
                            if (rowWidth)
                                addRow();
                        }
                        else {
                            if (rowWidth)
                                addRow();
                        }
                    }
                }
                if (char === ' ' && paraStart !== true && (rowWidth + wordWidth) === 0) ;
                else {
                    if (charType === Break) {
                        if (char === ' ' && wordWidth)
                            addWord();
                        addChar(char, charWidth);
                        addWord();
                    }
                    else if (langBreak || afterBreak) {
                        if (wordWidth)
                            addWord();
                        addChar(char, charWidth);
                    }
                    else {
                        addChar(char, charWidth);
                    }
                }
                lastCharType = charType;
            }
        }
        if (wordWidth)
            addWord();
        if (rowWidth)
            addRow();
        rows.length > 0 && (rows[rows.length - 1].paraEnd = true);
    }
    else {
        content.split('\n').forEach(content => {
            textDrawData.paraNumber++;
            rowWidth = canvas.measureText(content).width;
            rows.push({ x: paraIndent || 0, text: content, width: rowWidth, paraStart: true });
            if (findMaxWidth)
                setMaxWidth();
        });
    }
}
function addChar(char, width) {
    if (charSize && !startCharSize)
        startCharSize = charSize;
    word.data.push({ char, width });
    wordWidth += width;
}
function addWord() {
    rowWidth += wordWidth;
    word.width = wordWidth;
    row.words.push(word);
    word = { data: [] };
    wordWidth = 0;
}
function addRow() {
    if (paraStart) {
        textDrawData.paraNumber++;
        row.paraStart = true;
        paraStart = false;
    }
    if (charSize) {
        row.startCharSize = startCharSize;
        row.endCharSize = charSize;
        startCharSize = 0;
    }
    row.width = rowWidth;
    if (bounds.width)
        trimRight(row);
    else if (findMaxWidth)
        setMaxWidth();
    rows.push(row);
    row = { words: [] };
    rowWidth = 0;
}
function setMaxWidth() {
    if (rowWidth > (textDrawData.maxWidth || 0))
        textDrawData.maxWidth = rowWidth;
}

const CharMode = 0;
const WordMode = 1;
const TextMode = 2;
function layoutChar(drawData, style, width, _height) {
    const { rows } = drawData;
    const { textAlign, paraIndent, letterSpacing } = style;
    let charX, addWordWidth, indentWidth, mode, wordChar;
    rows.forEach(row => {
        if (row.words) {
            indentWidth = paraIndent && row.paraStart ? paraIndent : 0;
            addWordWidth = (width && textAlign === 'justify' && row.words.length > 1) ? (width - row.width - indentWidth) / (row.words.length - 1) : 0;
            mode = (letterSpacing || row.isOverflow) ? CharMode : (addWordWidth > 0.01 ? WordMode : TextMode);
            if (row.isOverflow && !letterSpacing)
                row.textMode = true;
            if (mode === TextMode) {
                row.x += indentWidth;
                toTextChar$1(row);
            }
            else {
                row.x += indentWidth;
                charX = row.x;
                row.data = [];
                row.words.forEach(word => {
                    if (mode === WordMode) {
                        wordChar = { char: '', x: charX };
                        charX = toWordChar(word.data, charX, wordChar);
                        if (row.isOverflow || wordChar.char !== ' ')
                            row.data.push(wordChar);
                    }
                    else {
                        charX = toChar(word.data, charX, row.data, row.isOverflow);
                    }
                    if (!row.paraEnd && addWordWidth) {
                        charX += addWordWidth;
                        row.width += addWordWidth;
                    }
                });
            }
            row.words = null;
        }
    });
}
function toTextChar$1(row) {
    row.text = '';
    row.words.forEach(word => {
        word.data.forEach(char => {
            row.text += char.char;
        });
    });
}
function toWordChar(data, charX, wordChar) {
    data.forEach(char => {
        wordChar.char += char.char;
        charX += char.width;
    });
    return charX;
}
function toChar(data, charX, rowData, isOverflow) {
    data.forEach(char => {
        if (isOverflow || char.char !== ' ') {
            char.x = charX;
            rowData.push(char);
        }
        charX += char.width;
    });
    return charX;
}

function layoutText(drawData, style) {
    const { rows, bounds } = drawData;
    const { __lineHeight, __baseLine, __letterSpacing, __clipText, textAlign, verticalAlign, paraSpacing, autoSizeAlign } = style;
    let { x, y, width, height } = bounds, realHeight = __lineHeight * rows.length + (paraSpacing ? paraSpacing * (drawData.paraNumber - 1) : 0);
    let starY = __baseLine;
    if (__clipText && realHeight > height) {
        realHeight = Math.max(height, __lineHeight);
        drawData.overflow = rows.length;
    }
    else if (height || autoSizeAlign) {
        switch (verticalAlign) {
            case 'middle':
                y += (height - realHeight) / 2;
                break;
            case 'bottom': y += (height - realHeight);
        }
    }
    starY += y;
    let row, rowX, rowWidth, layoutWidth = (width || autoSizeAlign) ? width : drawData.maxWidth;
    for (let i = 0, len = rows.length; i < len; i++) {
        row = rows[i];
        row.x = x;
        if (row.width < width || (row.width > width && !__clipText)) {
            switch (textAlign) {
                case 'center':
                    row.x += (layoutWidth - row.width) / 2;
                    break;
                case 'right': row.x += layoutWidth - row.width;
            }
        }
        if (row.paraStart && paraSpacing && i > 0)
            starY += paraSpacing;
        row.y = starY;
        starY += __lineHeight;
        if (drawData.overflow > i && starY > realHeight) {
            row.isOverflow = true;
            drawData.overflow = i + 1;
        }
        rowX = row.x;
        rowWidth = row.width;
        if (__letterSpacing < 0) {
            if (row.width < 0) {
                rowWidth = -row.width + style.fontSize + __letterSpacing;
                rowX -= rowWidth;
                rowWidth += style.fontSize;
            }
            else {
                rowWidth -= __letterSpacing;
            }
        }
        if (rowX < bounds.x)
            bounds.x = rowX;
        if (rowWidth > bounds.width)
            bounds.width = rowWidth;
        if (__clipText && width && width < rowWidth) {
            row.isOverflow = true;
            if (!drawData.overflow)
                drawData.overflow = rows.length;
        }
    }
    bounds.y = y;
    bounds.height = realHeight;
}

function clipText(drawData, style, x, width) {
    if (!width)
        return;
    const { rows, overflow } = drawData;
    let { textOverflow } = style;
    rows.splice(overflow);
    if (textOverflow && textOverflow !== 'show') {
        if (textOverflow === 'hide')
            textOverflow = '';
        else if (textOverflow === 'ellipsis')
            textOverflow = '...';
        let char, charRight;
        const ellipsisWidth = textOverflow ? Platform.canvas.measureText(textOverflow).width : 0;
        const right = x + width - ellipsisWidth;
        const list = style.textWrap === 'none' ? rows : [rows[overflow - 1]];
        list.forEach(row => {
            if (row.isOverflow && row.data) {
                let end = row.data.length - 1;
                for (let i = end; i > -1; i--) {
                    char = row.data[i];
                    charRight = char.x + char.width;
                    if (i === end && charRight < right) {
                        break;
                    }
                    else if (charRight < right && char.char !== ' ') {
                        row.data.splice(i + 1);
                        row.width -= char.width;
                        break;
                    }
                    row.width -= char.width;
                }
                row.width += ellipsisWidth;
                row.data.push({ char: textOverflow, x: charRight });
                if (row.textMode)
                    toTextChar(row);
            }
        });
    }
}
function toTextChar(row) {
    row.text = '';
    row.data.forEach(char => {
        row.text += char.char;
    });
    row.data = null;
}

function decorationText(drawData, style) {
    const { fontSize } = style;
    drawData.decorationHeight = fontSize / 11;
    switch (style.textDecoration) {
        case 'under':
            drawData.decorationY = fontSize * 0.15;
            break;
        case 'delete':
            drawData.decorationY = -fontSize * 0.35;
    }
}

const { top, right, bottom, left } = Direction4;
function getDrawData(content, style) {
    if (typeof content !== 'string')
        content = String(content);
    let x = 0, y = 0;
    let width = style.__getInput('width') || 0;
    let height = style.__getInput('height') || 0;
    const { textDecoration, __font, __padding: padding } = style;
    if (padding) {
        if (width)
            x = padding[left], width -= (padding[right] + padding[left]);
        else if (!style.autoSizeAlign)
            x = padding[left];
        if (height)
            y = padding[top], height -= (padding[top] + padding[bottom]);
        else if (!style.autoSizeAlign)
            y = padding[top];
    }
    const drawData = {
        bounds: { x, y, width, height },
        rows: [],
        paraNumber: 0,
        font: Platform.canvas.font = __font
    };
    createRows(drawData, content, style);
    if (padding)
        padAutoText(padding, drawData, style, width, height);
    layoutText(drawData, style);
    layoutChar(drawData, style, width);
    if (drawData.overflow)
        clipText(drawData, style, x, width);
    if (textDecoration !== 'none')
        decorationText(drawData, style);
    return drawData;
}
function padAutoText(padding, drawData, style, width, height) {
    if (!width && style.autoSizeAlign) {
        switch (style.textAlign) {
            case 'left':
                offsetText(drawData, 'x', padding[left]);
                break;
            case 'right': offsetText(drawData, 'x', -padding[right]);
        }
    }
    if (!height && style.autoSizeAlign) {
        switch (style.verticalAlign) {
            case 'top':
                offsetText(drawData, 'y', padding[top]);
                break;
            case 'bottom': offsetText(drawData, 'y', -padding[bottom]);
        }
    }
}
function offsetText(drawData, attrName, value) {
    const { bounds, rows } = drawData;
    bounds[attrName] += value;
    for (let i = 0; i < rows.length; i++)
        rows[i][attrName] += value;
}

const TextConvertModule = {
    getDrawData
};

function string(color, opacity) {
    const doOpacity = typeof opacity === 'number' && opacity !== 1;
    if (typeof color === 'string') {
        if (doOpacity && ColorConvert.object)
            color = ColorConvert.object(color);
        else
            return color;
    }
    let a = color.a === undefined ? 1 : color.a;
    if (doOpacity)
        a *= opacity;
    const rgb = color.r + ',' + color.g + ',' + color.b;
    return a === 1 ? 'rgb(' + rgb + ')' : 'rgba(' + rgb + ',' + a + ')';
}

const ColorConvertModule = {
    string
};

const { setPoint, addPoint, toBounds } = TwoPointBoundsHelper;
function getTrimBounds(canvas) {
    const { width, height } = canvas.view;
    const { data } = canvas.context.getImageData(0, 0, width, height);
    let x, y, pointBounds, index = 0;
    for (let i = 0; i < data.length; i += 4) {
        if (data[i + 3] !== 0) {
            x = index % width;
            y = (index - x) / width;
            pointBounds ? addPoint(pointBounds, x, y) : setPoint(pointBounds = {}, x, y);
        }
        index++;
    }
    const bounds = new Bounds();
    toBounds(pointBounds, bounds);
    return bounds.scale(1 / canvas.pixelRatio).ceil();
}

const ExportModule = {
    export(leaf, filename, options) {
        this.running = true;
        const fileType = FileHelper.fileType(filename);
        const isDownload = filename.includes('.');
        options = FileHelper.getExportOptions(options);
        return addTask((success) => new Promise((resolve) => {
            const over = (result) => {
                success(result);
                resolve();
                this.running = false;
            };
            const { toURL } = Platform;
            const { download } = Platform.origin;
            if (fileType === 'json') {
                isDownload && download(toURL(JSON.stringify(leaf.toJSON(options.json)), 'text'), filename);
                return over({ data: isDownload ? true : leaf.toJSON(options.json) });
            }
            if (fileType === 'svg') {
                isDownload && download(toURL(leaf.toSVG(), 'svg'), filename);
                return over({ data: isDownload ? true : leaf.toSVG() });
            }
            const { leafer } = leaf;
            if (leafer) {
                checkLazy(leaf);
                leafer.waitViewCompleted(() => __awaiter(this, void 0, void 0, function* () {
                    let renderBounds, trimBounds, scaleX = 1, scaleY = 1;
                    const { worldTransform, isLeafer, isFrame } = leaf;
                    const { slice, trim, onCanvas } = options;
                    const smooth = options.smooth === undefined ? leafer.config.smooth : options.smooth;
                    const contextSettings = options.contextSettings || leafer.config.contextSettings;
                    const screenshot = options.screenshot || leaf.isApp;
                    const fill = (isLeafer && screenshot) ? (options.fill === undefined ? leaf.fill : options.fill) : options.fill;
                    const needFill = FileHelper.isOpaqueImage(filename) || fill, matrix = new Matrix();
                    if (screenshot) {
                        renderBounds = screenshot === true ? (isLeafer ? leafer.canvas.bounds : leaf.worldRenderBounds) : screenshot;
                    }
                    else {
                        let relative = options.relative || (isLeafer ? 'inner' : 'local');
                        scaleX = worldTransform.scaleX;
                        scaleY = worldTransform.scaleY;
                        switch (relative) {
                            case 'inner':
                                matrix.set(worldTransform);
                                break;
                            case 'local':
                                matrix.set(worldTransform).divide(leaf.localTransform);
                                scaleX /= leaf.scaleX;
                                scaleY /= leaf.scaleY;
                                break;
                            case 'world':
                                scaleX = 1;
                                scaleY = 1;
                                break;
                            case 'page':
                                relative = leaf.leafer;
                            default:
                                matrix.set(worldTransform).divide(leaf.getTransform(relative));
                                const l = relative.worldTransform;
                                scaleX /= scaleX / l.scaleX;
                                scaleY /= scaleY / l.scaleY;
                        }
                        renderBounds = leaf.getBounds('render', relative);
                    }
                    const scaleData = { scaleX: 1, scaleY: 1 };
                    MathHelper.getScaleData(options.scale, options.size, renderBounds, scaleData);
                    let pixelRatio = options.pixelRatio || 1;
                    if (leaf.isApp) {
                        scaleData.scaleX *= pixelRatio;
                        scaleData.scaleY *= pixelRatio;
                        pixelRatio = leaf.app.pixelRatio;
                    }
                    const { x, y, width, height } = new Bounds(renderBounds).scale(scaleData.scaleX, scaleData.scaleY);
                    const renderOptions = { matrix: matrix.scale(1 / scaleData.scaleX, 1 / scaleData.scaleY).invert().translate(-x, -y).withScale(1 / scaleX * scaleData.scaleX, 1 / scaleY * scaleData.scaleY) };
                    let canvas = Creator.canvas({ width: Math.round(width), height: Math.round(height), pixelRatio, smooth, contextSettings });
                    let sliceLeaf;
                    if (slice) {
                        sliceLeaf = leaf;
                        sliceLeaf.__worldOpacity = 0;
                        leaf = leafer;
                        renderOptions.bounds = canvas.bounds;
                    }
                    canvas.save();
                    if (isFrame && fill !== undefined) {
                        const oldFill = leaf.get('fill');
                        leaf.fill = '';
                        leaf.__render(canvas, renderOptions);
                        leaf.fill = oldFill;
                    }
                    else {
                        leaf.__render(canvas, renderOptions);
                    }
                    canvas.restore();
                    if (sliceLeaf)
                        sliceLeaf.__updateWorldOpacity();
                    if (trim) {
                        trimBounds = getTrimBounds(canvas);
                        const old = canvas, { width, height } = trimBounds;
                        const config = { x: 0, y: 0, width, height, pixelRatio };
                        canvas = Creator.canvas(config);
                        canvas.copyWorld(old, trimBounds, config);
                    }
                    if (needFill)
                        canvas.fillWorld(canvas.bounds, fill || '#FFFFFF', 'destination-over');
                    if (onCanvas)
                        onCanvas(canvas);
                    const data = filename === 'canvas' ? canvas : yield canvas.export(filename, options);
                    over({ data, width: canvas.pixelWidth, height: canvas.pixelHeight, renderBounds, trimBounds });
                }));
            }
            else {
                over({ data: false });
            }
        }));
    }
};
let tasker;
function addTask(task) {
    if (!tasker)
        tasker = new TaskProcessor();
    return new Promise((resolve) => {
        tasker.add(() => __awaiter(this, void 0, void 0, function* () { return yield task(resolve); }), { parallel: false });
    });
}
function checkLazy(leaf) {
    if (leaf.__.__needComputePaint)
        leaf.__.__computePaint();
    if (leaf.isBranch)
        leaf.children.forEach(child => checkLazy(child));
}

const canvas = LeaferCanvasBase.prototype;
const debug = Debug.get('@leafer-ui/export');
canvas.export = function (filename, options) {
    const { quality, blob } = FileHelper.getExportOptions(options);
    if (filename.includes('.')) {
        return this.saveAs(filename, quality);
    }
    else if (blob) {
        return this.toBlob(filename, quality);
    }
    else {
        return this.toDataURL(filename, quality);
    }
};
canvas.toBlob = function (type, quality) {
    return new Promise((resolve) => {
        Platform.origin.canvasToBolb(this.view, type, quality).then((blob) => {
            resolve(blob);
        }).catch((e) => {
            debug.error(e);
            resolve(null);
        });
    });
};
canvas.toDataURL = function (type, quality) {
    return Platform.origin.canvasToDataURL(this.view, type, quality);
};
canvas.saveAs = function (filename, quality) {
    return new Promise((resolve) => {
        Platform.origin.canvasSaveAs(this.view, filename, quality).then(() => {
            resolve(true);
        }).catch((e) => {
            debug.error(e);
            resolve(false);
        });
    });
};

Object.assign(TextConvert, TextConvertModule);
Object.assign(ColorConvert, ColorConvertModule);
Object.assign(Paint, PaintModule);
Object.assign(PaintImage, PaintImageModule);
Object.assign(PaintGradient, PaintGradientModule);
Object.assign(Effect, EffectModule);
Object.assign(Export, ExportModule);

Object.assign(Creator, {
    interaction: (target, canvas, selector, options) => new Interaction(target, canvas, selector, options),
    hitCanvas: (options, manager) => new LeaferCanvas(options, manager),
    hitCanvasManager: () => new HitCanvasManager()
});
useCanvas();

export { Interaction, Layouter, LeaferCanvas, Renderer, Selector, Watcher, useCanvas };
