import {
  Interaction,
  Layouter,
  LeaferCanvas,
  Renderer,
  Selector,
  Watcher,
  useCanvas
} from "./chunk-NHT3D22W.js";
import {
  TextEditor
} from "./chunk-B4IJSZKH.js";
import {
  EditBox,
  EditDataHelper,
  EditPoint,
  EditSelect,
  EditSelectHelper,
  EditTool,
  EditToolCreator,
  Editor,
  EditorEvent,
  EditorGroupEvent,
  EditorHelper,
  EditorMoveEvent,
  EditorRotateEvent,
  EditorScaleEvent,
  EditorSkewEvent,
  InnerEditor,
  InnerEditorEvent,
  LineEditTool,
  PathScaler,
  SelectArea,
  Stroker,
  registerEditTool,
  registerInnerEditor,
  scaleResize,
  scaleResizeFontSize,
  scaleResizeGroup,
  scaleResizePath,
  scaleResizePoints
} from "./chunk-WCIMPE26.js";
import {
  Arrow,
  ArrowData,
  PathArrowModule,
  PathMatrixHelper,
  arrowType
} from "./chunk-L4EJ255O.js";
import {
  App,
  Cursor,
  DragEvent,
  DropEvent,
  HitCanvasManager,
  InteractionBase,
  InteractionHelper,
  KeyEvent,
  Keyboard,
  LeaferTypeCreator,
  MoveEvent,
  MultiTouchHelper,
  MyDragEvent,
  MyPointerEvent,
  PointerButton,
  PointerEvent,
  RotateEvent,
  SwipeEvent,
  UIEvent,
  ZoomEvent,
  addInteractionWindow
} from "./chunk-BZP5EJJA.js";
import {
  AlignHelper,
  Answer,
  AroundHelper,
  AutoBounds,
  BezierHelper,
  Bounds,
  BoundsHelper,
  Box,
  BoxData,
  Branch,
  BranchHelper,
  BranchRender,
  Canvas,
  CanvasData,
  CanvasManager,
  ChildEvent,
  ColorConvert,
  Creator,
  DataHelper,
  Debug,
  Direction4,
  Direction9,
  Effect,
  Ellipse,
  EllipseData,
  EllipseHelper,
  Event,
  EventCreator,
  Eventer,
  Export,
  FileHelper,
  Frame,
  FrameData,
  Group,
  GroupData,
  Image,
  ImageData,
  ImageEvent,
  ImageManager,
  IncrementId,
  LayoutEvent,
  Leaf,
  LeafBounds,
  LeafBoundsHelper,
  LeafData,
  LeafDataProxy,
  LeafEventer,
  LeafHelper,
  LeafLayout,
  LeafLevelList,
  LeafList,
  LeafMatrix,
  LeafRender,
  Leafer,
  LeaferCanvasBase,
  LeaferData,
  LeaferEvent,
  LeaferImage,
  Line,
  LineData,
  MathHelper,
  Matrix,
  MatrixHelper,
  MyImage,
  NeedConvertToCanvasCommandMap,
  OneRadian,
  PI2,
  PI_2,
  Paint,
  PaintGradient,
  PaintImage,
  Path,
  PathArrow,
  PathBounds,
  PathCommandDataHelper,
  PathCommandMap,
  PathConvert,
  PathCorner,
  PathCreator,
  PathData,
  PathDrawer,
  PathHelper,
  PathNumberCommandLengthMap,
  PathNumberCommandMap,
  Pen,
  PenData,
  Platform,
  Point,
  PointHelper,
  Polygon,
  PolygonData,
  PropertyEvent,
  Rect,
  RectData,
  RectHelper,
  RectRender,
  RenderEvent,
  ResizeEvent,
  Run,
  Star,
  StarData,
  State,
  StringNumberMap,
  TaskItem,
  TaskProcessor,
  Text,
  TextConvert,
  TextData,
  Transition,
  TwoPointBoundsHelper,
  UI,
  UIBounds,
  UICreator,
  UIData,
  UIRender,
  UnitConvert,
  WaitHelper,
  WatchEvent,
  affectRenderBoundsType,
  affectStrokeBoundsType,
  attr,
  autoLayoutType,
  boundsType,
  canvasPatch,
  canvasSizeAttrs,
  cursorType,
  dataProcessor,
  dataType,
  decorateLeafAttr,
  defineDataProcessor,
  defineKey,
  defineLeafAttr,
  doBoundsType,
  doStrokeType,
  effectType,
  emptyData,
  eraserType,
  getBoundsData,
  getDescriptor,
  getMatrixData,
  getPointData,
  hitType,
  isNull,
  layoutProcessor,
  maskType,
  naturalBoundsType,
  needPlugin,
  opacityType,
  pathInputType,
  pathType,
  pen,
  positionType,
  registerUI,
  registerUIEvent,
  resizeType,
  rewrite,
  rewriteAble,
  rotationType,
  scaleType,
  sortType,
  strokeType,
  surfaceType,
  tempBounds,
  tempMatrix,
  tempPoint$2,
  useModule,
  version,
  visibleType,
  zoomLayerType
} from "./chunk-ART566W7.js";
import "./chunk-5WRI5ZAA.js";

// node_modules/.pnpm/@leafer-in+view@1.0.10_@leafer-in+interface@1.0.10_@leafer-ui+draw@1.0.10_@leafer-ui+interface@1.0.10/node_modules/@leafer-in/view/dist/view.esm.js
function getZoomScale(scaleX, type) {
  let scale = 1;
  const out = type === "out", absScale = Math.abs(scaleX);
  if (absScale > 1) {
    while (out ? scale < absScale : scale <= absScale)
      scale *= 2;
    if (out)
      scale /= 2;
  } else {
    while (out ? scale >= absScale : scale > absScale)
      scale /= 2;
    if (!out)
      scale *= 2;
  }
  return scale / scaleX;
}
function getFixBounds(bounds, scaleBounds) {
  let { x, y, width, height } = bounds;
  let fix;
  if (!height)
    height = width * (scaleBounds.height / scaleBounds.width), fix = true;
  if (!width)
    width = height * (scaleBounds.width / scaleBounds.height), fix = true;
  return fix ? { x, y, width, height } : bounds;
}
Leafer.prototype.zoom = function(zoomType, padding, fixed) {
  const { zoomLayer } = this;
  const limitBounds = this.canvas.bounds.clone().shrink(padding ? padding : 30), bounds = new Bounds();
  const center = { x: limitBounds.x + limitBounds.width / 2, y: limitBounds.y + limitBounds.height / 2 };
  let changeScale;
  const { scaleX } = this.__;
  if (typeof zoomType === "string") {
    switch (zoomType) {
      case "in":
        changeScale = getZoomScale(scaleX, "in");
        break;
      case "out":
        changeScale = getZoomScale(scaleX, "out");
        break;
      case "fit":
        zoomType = this.boxBounds;
        break;
      case "fit-width":
        zoomType = new Bounds(this.boxBounds);
        zoomType.height = 0;
        break;
      case "fit-height":
        zoomType = new Bounds(this.boxBounds);
        zoomType.width = 0;
        break;
    }
  } else if (typeof zoomType === "number") {
    changeScale = zoomType / scaleX;
  }
  if (changeScale) {
    if (changeScale !== 1)
      zoomLayer.scaleOfWorld(center, this.getValidScale(changeScale));
  } else if (typeof zoomType === "object") {
    const isArray = zoomType instanceof Array;
    if (isArray || zoomType.tag) {
      const list = isArray ? zoomType : [zoomType];
      bounds.setListWithFn(list, LeafBoundsHelper.worldBounds);
    } else {
      const innerBounds = getFixBounds(zoomType, limitBounds);
      bounds.set(zoomLayer.getWorldBounds(innerBounds));
    }
    const { x, y, width, height } = bounds;
    let moveX = limitBounds.x - x, moveY = limitBounds.y - y;
    if (fixed) {
      moveX += Math.max((limitBounds.width - width) / 2, 0);
      moveY += Math.max((limitBounds.height - height) / 2, 0);
    } else {
      const fitScale = this.getValidScale(Math.min(limitBounds.width / width, limitBounds.height / height));
      moveX += (limitBounds.width - width * fitScale) / 2;
      moveY += (limitBounds.height - height * fitScale) / 2;
      zoomLayer.scaleOfWorld(bounds, fitScale);
      bounds.scaleOf(bounds, fitScale);
    }
    zoomLayer.move(moveX, moveY);
    return bounds.move(moveX, moveY);
  }
  return zoomLayer.worldBoxBounds;
};

// node_modules/.pnpm/@leafer-in+scroll@1.0.10_@leafer-in+interface@1.0.10_@leafer-ui+core@1.0.10_@leafer-ui+draw@1_5jxfcrsoakyiyenuhgxxltnydy/node_modules/@leafer-in/scroll/dist/scroll.esm.js
var ScrollBar = class extends Group {
  get isOutside() {
    return true;
  }
  constructor(target, userConfig) {
    super();
    this.config = {
      theme: "light",
      padding: 0,
      minSize: 10
    };
    if (target.isApp) {
      target.sky.add(this);
      target = target.tree;
    }
    this.target = target;
    if (userConfig)
      DataHelper.assign(this.config, userConfig);
    this.changeTheme(this.config.theme);
    this.waitLeafer(this.__listenEvents, this);
  }
  changeTheme(theme) {
    let style;
    if (typeof theme === "string") {
      style = { fill: "black", stroke: "rgba(255,255,255,0.8)" };
      if (theme === "dark") {
        style.fill = "white";
        style.stroke = "rgba(0,0,0,0.2)";
      }
    } else {
      style = theme;
    }
    if (!this.scrollXBar)
      this.addMany(this.scrollXBar = new Box(), this.scrollYBar = new Box());
    style = Object.assign({ strokeAlign: "center", opacity: 0.5, width: 6, cornerRadius: 3, hoverStyle: { opacity: 0.6 }, pressStyle: { opacity: 0.7 } }, style);
    if (!style.height)
      style.height = style.width;
    this.scrollXBar.set(Object.assign(Object.assign({}, style), { visible: false }));
    this.scrollYBar.set(Object.assign(Object.assign({}, style), { visible: false }));
    if (this.leafer)
      this.update();
  }
  update(check) {
    if (this.dragScrolling)
      return;
    const { minSize, padding } = this.config;
    const { zoomLayer, canvas } = this.target.leafer;
    const { worldRenderBounds } = zoomLayer;
    if (check && this.scrollBounds && this.scrollBounds.isSame(worldRenderBounds))
      return;
    this.scrollBounds = new Bounds(worldRenderBounds);
    const bounds = canvas.bounds.clone().shrink(padding);
    const totalBounds = bounds.clone().add(worldRenderBounds);
    const ratioX = this.ratioX = bounds.width / totalBounds.width;
    const ratioY = this.ratioY = bounds.height / totalBounds.height;
    const scrollRatioX = (bounds.x - totalBounds.x) / totalBounds.width;
    const scrollRatioY = (bounds.y - totalBounds.y) / totalBounds.height;
    const showScrollXBar = ratioX < 1;
    const showScrollYBar = ratioY < 1;
    const { scrollXBar, scrollYBar } = this;
    const { x, y, width, height } = bounds.shrink([2, showScrollYBar ? scrollYBar.width + 6 : 2, showScrollXBar ? scrollXBar.height + 6 : 2, 2]);
    scrollXBar.set({
      x: x + width * scrollRatioX,
      y: y + height + 2,
      width: Math.max(width * ratioX, minSize),
      visible: showScrollXBar
    });
    scrollYBar.set({
      x: x + width + 2,
      y: y + height * scrollRatioY,
      height: Math.max(height * ratioY, minSize),
      visible: showScrollYBar
    });
  }
  onDrag(e) {
    this.dragScrolling = true;
    this.__dragOut = this.app.config.move.dragOut;
    this.app.config.move.dragOut = false;
    const scrollX = e.current === this.scrollXBar;
    const move = this.target.leafer.getValidMove(scrollX ? -e.moveX / this.ratioX : 0, scrollX ? 0 : -e.moveY / this.ratioY);
    this.target.moveWorld(move.x, move.y);
    e.current.moveWorld(move.x && -move.x * this.ratioX, move.y && -move.y * this.ratioY);
  }
  onDragEnd() {
    this.dragScrolling = false;
    this.app.config.move.dragOut = this.__dragOut;
  }
  __listenEvents() {
    const { scrollXBar, scrollYBar } = this;
    this.__eventIds = [
      scrollXBar.on_(DragEvent.DRAG, this.onDrag, this),
      scrollYBar.on_(DragEvent.DRAG, this.onDrag, this),
      scrollXBar.on_(DragEvent.END, this.onDragEnd, this),
      scrollYBar.on_(DragEvent.END, this.onDragEnd, this),
      this.target.on_(RenderEvent.BEFORE, () => this.update(true)),
      this.target.leafer.on_(ResizeEvent.RESIZE, () => this.update())
    ];
  }
  __removeListenEvents() {
    this.off_(this.__eventIds);
  }
  destroy() {
    if (!this.destroyed) {
      this.__removeListenEvents();
      this.target = this.config = null;
      super.destroy();
    }
  }
};

// node_modules/.pnpm/@leafer-in+html@1.0.10_@leafer-in+interface@1.0.10_@leafer-ui+draw@1.0.10_@leafer-ui+interface@1.0.10/node_modules/@leafer-in/html/dist/html.esm.js
function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var HTMLTextData = class extends ImageData {
  setText(value) {
    this._text = value;
    this.__htmlChanged = true;
  }
};
var HTMLText = class HTMLText2 extends Image {
  get __tag() {
    return "HTMLText";
  }
  get editInner() {
    return "TextEditor";
  }
  constructor(data) {
    super(data);
  }
  __updateBoxBounds() {
    const data = this.__;
    if (data.__htmlChanged) {
      const div = document.createElement("div");
      const { style } = div;
      style.all = "initial";
      style.position = "absolute";
      style.visibility = "hidden";
      div.innerHTML = this.text;
      document.body.appendChild(div);
      const { width, height } = div.getBoundingClientRect();
      const realWidth = width + 10;
      const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${realWidth}" height="${height}">
                        <foreignObject width="${realWidth}" height="${height}">
                            <style>
                                * {
                                    margin: 0;
                                    padding: 0;
                                    box-sizing: border-box;
                                }
                            </style>
                            <body xmlns="http://www.w3.org/1999/xhtml">
                                ${this.text}
                            </body>
                        </foreignObject>
                    </svg>`;
      data.__setImageFill("data:image/svg+xml," + encodeURIComponent(svg));
      data.__naturalWidth = realWidth / data.pixelRatio;
      data.__naturalHeight = height / data.pixelRatio;
      data.__htmlChanged = false;
      div.remove();
    }
    super.__updateBoxBounds();
  }
};
__decorate([
  dataProcessor(HTMLTextData)
], HTMLText.prototype, "__", void 0);
__decorate([
  boundsType("")
], HTMLText.prototype, "text", void 0);
HTMLText = __decorate([
  registerUI()
], HTMLText);
export {
  AlignHelper,
  Answer,
  App,
  AroundHelper,
  Arrow,
  ArrowData,
  AutoBounds,
  BezierHelper,
  Bounds,
  BoundsHelper,
  Box,
  BoxData,
  Branch,
  BranchHelper,
  BranchRender,
  Canvas,
  CanvasData,
  CanvasManager,
  ChildEvent,
  ColorConvert,
  Creator,
  Cursor,
  DataHelper,
  Debug,
  Direction4,
  Direction9,
  DragEvent,
  DropEvent,
  EditBox,
  EditDataHelper,
  EditPoint,
  EditSelect,
  EditSelectHelper,
  EditTool,
  EditToolCreator,
  Editor,
  EditorEvent,
  EditorGroupEvent,
  EditorHelper,
  EditorMoveEvent,
  EditorRotateEvent,
  EditorScaleEvent,
  EditorSkewEvent,
  Effect,
  Ellipse,
  EllipseData,
  EllipseHelper,
  Event,
  EventCreator,
  Eventer,
  Export,
  FileHelper,
  Frame,
  FrameData,
  Group,
  GroupData,
  HTMLText,
  HTMLTextData,
  HitCanvasManager,
  Image,
  ImageData,
  ImageEvent,
  ImageManager,
  IncrementId,
  InnerEditor,
  InnerEditorEvent,
  Interaction,
  InteractionBase,
  InteractionHelper,
  KeyEvent,
  Keyboard,
  LayoutEvent,
  Layouter,
  Leaf,
  LeafBounds,
  LeafBoundsHelper,
  LeafData,
  LeafDataProxy,
  LeafEventer,
  LeafHelper,
  LeafLayout,
  LeafLevelList,
  LeafList,
  LeafMatrix,
  LeafRender,
  Leafer,
  LeaferCanvas,
  LeaferCanvasBase,
  LeaferData,
  LeaferEvent,
  LeaferImage,
  LeaferTypeCreator,
  Line,
  LineData,
  LineEditTool,
  MathHelper,
  Matrix,
  MatrixHelper,
  MoveEvent,
  MultiTouchHelper,
  MyDragEvent,
  MyImage,
  MyPointerEvent,
  NeedConvertToCanvasCommandMap,
  OneRadian,
  PI2,
  PI_2,
  Paint,
  PaintGradient,
  PaintImage,
  Path,
  PathArrow,
  PathArrowModule,
  PathBounds,
  PathCommandDataHelper,
  PathCommandMap,
  PathConvert,
  PathCorner,
  PathCreator,
  PathData,
  PathDrawer,
  PathHelper,
  PathMatrixHelper,
  PathNumberCommandLengthMap,
  PathNumberCommandMap,
  PathScaler,
  Pen,
  PenData,
  Platform,
  Point,
  PointHelper,
  PointerButton,
  PointerEvent,
  Polygon,
  PolygonData,
  PropertyEvent,
  Rect,
  RectData,
  RectHelper,
  RectRender,
  RenderEvent,
  Renderer,
  ResizeEvent,
  RotateEvent,
  Run,
  ScrollBar,
  SelectArea,
  Selector,
  Star,
  StarData,
  State,
  StringNumberMap,
  Stroker,
  SwipeEvent,
  TaskItem,
  TaskProcessor,
  Text,
  TextConvert,
  TextData,
  TextEditor,
  Transition,
  TwoPointBoundsHelper,
  UI,
  UIBounds,
  UICreator,
  UIData,
  UIEvent,
  UIRender,
  UnitConvert,
  WaitHelper,
  WatchEvent,
  Watcher,
  ZoomEvent,
  addInteractionWindow,
  affectRenderBoundsType,
  affectStrokeBoundsType,
  arrowType,
  attr,
  autoLayoutType,
  boundsType,
  canvasPatch,
  canvasSizeAttrs,
  cursorType,
  dataProcessor,
  dataType,
  decorateLeafAttr,
  defineDataProcessor,
  defineKey,
  defineLeafAttr,
  doBoundsType,
  doStrokeType,
  effectType,
  emptyData,
  eraserType,
  getBoundsData,
  getDescriptor,
  getMatrixData,
  getPointData,
  hitType,
  isNull,
  layoutProcessor,
  maskType,
  naturalBoundsType,
  needPlugin,
  opacityType,
  pathInputType,
  pathType,
  pen,
  positionType,
  registerEditTool,
  registerInnerEditor,
  registerUI,
  registerUIEvent,
  resizeType,
  rewrite,
  rewriteAble,
  rotationType,
  scaleResize,
  scaleResizeFontSize,
  scaleResizeGroup,
  scaleResizePath,
  scaleResizePoints,
  scaleType,
  sortType,
  strokeType,
  surfaceType,
  tempBounds,
  tempMatrix,
  tempPoint$2 as tempPoint,
  useCanvas,
  useModule,
  version,
  visibleType,
  zoomLayerType
};
//# sourceMappingURL=leafer-editor.js.map
