// node_modules/.pnpm/@leafer+core@1.0.10/node_modules/@leafer/core/lib/core.esm.js
var Platform = {
  toURL(text, fileType) {
    let url = encodeURIComponent(text);
    if (fileType === "text")
      url = "data:text/plain;charset=utf-8," + url;
    else if (fileType === "svg")
      url = "data:image/svg+xml," + url;
    return url;
  },
  image: {
    hitCanvasSize: 100,
    maxCacheSize: 2560 * 1600,
    maxPatternSize: 4096 * 2160,
    crossOrigin: "anonymous",
    getRealURL(url) {
      const { prefix, suffix } = Platform.image;
      if (suffix && !url.startsWith("data:") && !url.startsWith("blob:"))
        url += (url.includes("?") ? "&" : "?") + suffix;
      if (prefix && url[0] === "/")
        url = prefix + url;
      return url;
    }
  }
};
var Creator = {};
var IncrementId = {
  RUNTIME: "runtime",
  LEAF: "leaf",
  TASK: "task",
  CNAVAS: "canvas",
  IMAGE: "image",
  types: {},
  create(typeName) {
    const { types } = I$1;
    if (types[typeName]) {
      return types[typeName]++;
    } else {
      types[typeName] = 1;
      return 0;
    }
  }
};
var I$1 = IncrementId;
var { round, pow: pow$1, PI: PI$2 } = Math;
var MathHelper = {
  within(value, min2, max) {
    if (typeof min2 === "object")
      max = min2.max, min2 = min2.min;
    if (min2 !== void 0 && value < min2)
      value = min2;
    if (max !== void 0 && value > max)
      value = max;
    return value;
  },
  fourNumber(num, maxValue) {
    let data;
    if (num instanceof Array) {
      switch (num.length) {
        case 4:
          data = maxValue === void 0 ? num : [...num];
          break;
        case 2:
          data = [num[0], num[1], num[0], num[1]];
          break;
        case 3:
          data = [num[0], num[1], num[2], num[1]];
          break;
        case 1:
          num = num[0];
          break;
        default:
          num = 0;
      }
    }
    if (!data)
      data = [num, num, num, num];
    if (maxValue) {
      for (let i = 0; i < 4; i++)
        if (data[i] > maxValue)
          data[i] = maxValue;
    }
    return data;
  },
  formatRotation(rotation, unsign) {
    rotation %= 360;
    if (unsign) {
      if (rotation < 0)
        rotation += 360;
    } else {
      if (rotation > 180)
        rotation -= 360;
      if (rotation < -180)
        rotation += 360;
    }
    return MathHelper.float(rotation);
  },
  getGapRotation(addRotation, gap, oldRotation = 0) {
    let rotation = addRotation + oldRotation;
    if (gap > 1) {
      const r = Math.abs(rotation % gap);
      if (r < 1 || r > gap - 1)
        rotation = Math.round(rotation / gap) * gap;
    }
    return rotation - oldRotation;
  },
  float(num, maxLength) {
    const a2 = maxLength ? pow$1(10, maxLength) : 1e12;
    num = round(num * a2) / a2;
    return num === -0 ? 0 : num;
  },
  getScaleData(scale, size, originSize, scaleData) {
    if (!scaleData)
      scaleData = {};
    if (size) {
      scaleData.scaleX = (typeof size === "number" ? size : size.width) / originSize.width;
      scaleData.scaleY = (typeof size === "number" ? size : size.height) / originSize.height;
    } else if (scale)
      MathHelper.assignScale(scaleData, scale);
    return scaleData;
  },
  assignScale(scaleData, scale) {
    if (typeof scale === "number") {
      scaleData.scaleX = scaleData.scaleY = scale;
    } else {
      scaleData.scaleX = scale.x;
      scaleData.scaleY = scale.y;
    }
  }
};
var OneRadian = PI$2 / 180;
var PI2 = PI$2 * 2;
var PI_2 = PI$2 / 2;
function getPointData() {
  return { x: 0, y: 0 };
}
function getBoundsData() {
  return { x: 0, y: 0, width: 0, height: 0 };
}
function getMatrixData() {
  return { a: 1, b: 0, c: 0, d: 1, e: 0, f: 0 };
}
var { sin: sin$3, cos: cos$3, acos, sqrt: sqrt$3 } = Math;
var { float: float$1 } = MathHelper;
var tempPoint$3 = {};
function getWorld() {
  return Object.assign(Object.assign(Object.assign({}, getMatrixData()), getBoundsData()), { scaleX: 1, scaleY: 1, rotation: 0, skewX: 0, skewY: 0 });
}
var MatrixHelper = {
  defaultMatrix: getMatrixData(),
  defaultWorld: getWorld(),
  tempMatrix: {},
  set(t2, a2 = 1, b = 0, c2 = 0, d = 1, e = 0, f = 0) {
    t2.a = a2;
    t2.b = b;
    t2.c = c2;
    t2.d = d;
    t2.e = e;
    t2.f = f;
  },
  get: getMatrixData,
  getWorld,
  copy(t2, matrix2) {
    t2.a = matrix2.a;
    t2.b = matrix2.b;
    t2.c = matrix2.c;
    t2.d = matrix2.d;
    t2.e = matrix2.e;
    t2.f = matrix2.f;
  },
  translate(t2, x, y) {
    t2.e += x;
    t2.f += y;
  },
  translateInner(t2, x, y, hasOrigin) {
    t2.e += t2.a * x + t2.c * y;
    t2.f += t2.b * x + t2.d * y;
    if (hasOrigin)
      t2.e -= x, t2.f -= y;
  },
  scale(t2, scaleX, scaleY = scaleX) {
    t2.a *= scaleX;
    t2.b *= scaleX;
    t2.c *= scaleY;
    t2.d *= scaleY;
  },
  scaleOfOuter(t2, origin, scaleX, scaleY) {
    M$6.toInnerPoint(t2, origin, tempPoint$3);
    M$6.scaleOfInner(t2, tempPoint$3, scaleX, scaleY);
  },
  scaleOfInner(t2, origin, scaleX, scaleY = scaleX) {
    M$6.translateInner(t2, origin.x, origin.y);
    M$6.scale(t2, scaleX, scaleY);
    M$6.translateInner(t2, -origin.x, -origin.y);
  },
  rotate(t2, rotation) {
    const { a: a2, b, c: c2, d } = t2;
    rotation *= OneRadian;
    const cosR = cos$3(rotation);
    const sinR = sin$3(rotation);
    t2.a = a2 * cosR - b * sinR;
    t2.b = a2 * sinR + b * cosR;
    t2.c = c2 * cosR - d * sinR;
    t2.d = c2 * sinR + d * cosR;
  },
  rotateOfOuter(t2, origin, rotation) {
    M$6.toInnerPoint(t2, origin, tempPoint$3);
    M$6.rotateOfInner(t2, tempPoint$3, rotation);
  },
  rotateOfInner(t2, origin, rotation) {
    M$6.translateInner(t2, origin.x, origin.y);
    M$6.rotate(t2, rotation);
    M$6.translateInner(t2, -origin.x, -origin.y);
  },
  skew(t2, skewX, skewY) {
    const { a: a2, b, c: c2, d } = t2;
    if (skewY) {
      skewY *= OneRadian;
      t2.a = a2 + c2 * skewY;
      t2.b = b + d * skewY;
    }
    if (skewX) {
      skewX *= OneRadian;
      t2.c = c2 + a2 * skewX;
      t2.d = d + b * skewX;
    }
  },
  skewOfOuter(t2, origin, skewX, skewY) {
    M$6.toInnerPoint(t2, origin, tempPoint$3);
    M$6.skewOfInner(t2, tempPoint$3, skewX, skewY);
  },
  skewOfInner(t2, origin, skewX, skewY = 0) {
    M$6.translateInner(t2, origin.x, origin.y);
    M$6.skew(t2, skewX, skewY);
    M$6.translateInner(t2, -origin.x, -origin.y);
  },
  multiply(t2, child) {
    const { a: a2, b, c: c2, d, e, f } = t2;
    t2.a = child.a * a2 + child.b * c2;
    t2.b = child.a * b + child.b * d;
    t2.c = child.c * a2 + child.d * c2;
    t2.d = child.c * b + child.d * d;
    t2.e = child.e * a2 + child.f * c2 + e;
    t2.f = child.e * b + child.f * d + f;
  },
  multiplyParent(t2, parent, to, abcdChanged, childScaleData, scrollData) {
    let { e, f } = t2;
    if (scrollData)
      e += scrollData.scrollX, f += scrollData.scrollY;
    to || (to = t2);
    if (abcdChanged === void 0)
      abcdChanged = t2.a !== 1 || t2.b || t2.c || t2.d !== 1;
    if (abcdChanged) {
      const { a: a2, b, c: c2, d } = t2;
      to.a = a2 * parent.a + b * parent.c;
      to.b = a2 * parent.b + b * parent.d;
      to.c = c2 * parent.a + d * parent.c;
      to.d = c2 * parent.b + d * parent.d;
      if (childScaleData) {
        to.scaleX = parent.scaleX * childScaleData.scaleX;
        to.scaleY = parent.scaleY * childScaleData.scaleY;
      }
    } else {
      to.a = parent.a;
      to.b = parent.b;
      to.c = parent.c;
      to.d = parent.d;
      if (childScaleData) {
        to.scaleX = parent.scaleX;
        to.scaleY = parent.scaleY;
      }
    }
    to.e = e * parent.a + f * parent.c + parent.e;
    to.f = e * parent.b + f * parent.d + parent.f;
  },
  divide(t2, child) {
    M$6.multiply(t2, M$6.tempInvert(child));
  },
  divideParent(t2, parent) {
    M$6.multiplyParent(t2, M$6.tempInvert(parent));
  },
  tempInvert(t2) {
    const { tempMatrix: tempMatrix2 } = M$6;
    M$6.copy(tempMatrix2, t2);
    M$6.invert(tempMatrix2);
    return tempMatrix2;
  },
  invert(t2) {
    const { a: a2, b, c: c2, d, e, f } = t2;
    if (!b && !c2) {
      if (a2 === 1 && d === 1) {
        t2.e = -e;
        t2.f = -f;
      } else {
        const s2 = 1 / (a2 * d);
        t2.a = d * s2;
        t2.d = a2 * s2;
        t2.e = -e * d * s2;
        t2.f = -f * a2 * s2;
      }
    } else {
      const s2 = 1 / (a2 * d - b * c2);
      t2.a = d * s2;
      t2.b = -b * s2;
      t2.c = -c2 * s2;
      t2.d = a2 * s2;
      t2.e = -(e * d - f * c2) * s2;
      t2.f = -(f * a2 - e * b) * s2;
    }
  },
  toOuterPoint(t2, inner, to, distance) {
    const { x, y } = inner;
    to || (to = inner);
    to.x = x * t2.a + y * t2.c;
    to.y = x * t2.b + y * t2.d;
    if (!distance) {
      to.x += t2.e;
      to.y += t2.f;
    }
  },
  toInnerPoint(t2, outer, to, distance) {
    const { a: a2, b, c: c2, d } = t2;
    const s2 = 1 / (a2 * d - b * c2);
    const { x, y } = outer;
    to || (to = outer);
    to.x = (x * d - y * c2) * s2;
    to.y = (y * a2 - x * b) * s2;
    if (!distance) {
      const { e, f } = t2;
      to.x -= (e * d - f * c2) * s2;
      to.y -= (f * a2 - e * b) * s2;
    }
  },
  setLayout(t2, layout, origin, around, bcChanged) {
    const { x, y, scaleX, scaleY } = layout;
    if (bcChanged === void 0)
      bcChanged = layout.rotation || layout.skewX || layout.skewY;
    if (bcChanged) {
      const { rotation, skewX, skewY } = layout;
      const r = rotation * OneRadian;
      const cosR = cos$3(r);
      const sinR = sin$3(r);
      if (skewX || skewY) {
        const sx = skewX * OneRadian;
        const sy = skewY * OneRadian;
        t2.a = (cosR + sy * -sinR) * scaleX;
        t2.b = (sinR + sy * cosR) * scaleX;
        t2.c = (-sinR + sx * cosR) * scaleY;
        t2.d = (cosR + sx * sinR) * scaleY;
      } else {
        t2.a = cosR * scaleX;
        t2.b = sinR * scaleX;
        t2.c = -sinR * scaleY;
        t2.d = cosR * scaleY;
      }
    } else {
      t2.a = scaleX;
      t2.b = 0;
      t2.c = 0;
      t2.d = scaleY;
    }
    t2.e = x;
    t2.f = y;
    if (origin = origin || around)
      M$6.translateInner(t2, -origin.x, -origin.y, !around);
  },
  getLayout(t2, origin, around, firstSkewY) {
    const { a: a2, b, c: c2, d, e, f } = t2;
    let x = e, y = f, scaleX, scaleY, rotation, skewX, skewY;
    if (b || c2) {
      const s2 = a2 * d - b * c2;
      if (c2 && !firstSkewY) {
        scaleX = sqrt$3(a2 * a2 + b * b);
        scaleY = s2 / scaleX;
        const cosR2 = a2 / scaleX;
        rotation = b > 0 ? acos(cosR2) : -acos(cosR2);
      } else {
        scaleY = sqrt$3(c2 * c2 + d * d);
        scaleX = s2 / scaleY;
        const cosR2 = c2 / scaleY;
        rotation = PI_2 - (d > 0 ? acos(-cosR2) : -acos(cosR2));
      }
      const cosR = float$1(cos$3(rotation));
      const sinR = sin$3(rotation);
      scaleX = float$1(scaleX), scaleY = float$1(scaleY);
      skewX = cosR ? float$1((c2 / scaleY + sinR) / cosR / OneRadian, 9) : 0;
      skewY = cosR ? float$1((b / scaleX - sinR) / cosR / OneRadian, 9) : 0;
      rotation = float$1(rotation / OneRadian);
    } else {
      scaleX = a2;
      scaleY = d;
      rotation = skewX = skewY = 0;
    }
    if (origin = around || origin) {
      x += origin.x * a2 + origin.y * c2;
      y += origin.x * b + origin.y * d;
      if (!around)
        x -= origin.x, y -= origin.y;
    }
    return { x, y, scaleX, scaleY, rotation, skewX, skewY };
  },
  withScale(t2, scaleX, scaleY = scaleX) {
    const world = t2;
    if (!scaleX || !scaleY) {
      const { a: a2, b, c: c2, d } = t2;
      if (b || c2) {
        scaleX = sqrt$3(a2 * a2 + b * b);
        scaleY = (a2 * d - b * c2) / scaleX;
      } else {
        scaleX = a2;
        scaleY = d;
      }
    }
    world.scaleX = scaleX;
    world.scaleY = scaleY;
    return world;
  },
  reset(t2) {
    M$6.set(t2);
  }
};
var M$6 = MatrixHelper;
var { toInnerPoint: toInnerPoint$2, toOuterPoint: toOuterPoint$3 } = MatrixHelper;
var { sin: sin$2, cos: cos$2, abs: abs$2, sqrt: sqrt$2, atan2: atan2$2, min: min$1, PI: PI$1 } = Math;
var PointHelper = {
  defaultPoint: getPointData(),
  tempPoint: {},
  tempRadiusPoint: {},
  set(t2, x = 0, y = 0) {
    t2.x = x;
    t2.y = y;
  },
  setRadius(t2, x, y) {
    t2.radiusX = x;
    t2.radiusY = y === void 0 ? x : y;
  },
  copy(t2, point2) {
    t2.x = point2.x;
    t2.y = point2.y;
  },
  copyFrom(t2, x, y) {
    t2.x = x;
    t2.y = y;
  },
  move(t2, x, y) {
    t2.x += x;
    t2.y += y;
  },
  scale(t2, scaleX, scaleY = scaleX) {
    if (t2.x)
      t2.x *= scaleX;
    if (t2.y)
      t2.y *= scaleY;
  },
  scaleOf(t2, origin, scaleX, scaleY = scaleX) {
    t2.x += (t2.x - origin.x) * (scaleX - 1);
    t2.y += (t2.y - origin.y) * (scaleY - 1);
  },
  rotate(t2, rotation, origin) {
    if (!origin)
      origin = P$5.defaultPoint;
    rotation *= OneRadian;
    const cosR = cos$2(rotation);
    const sinR = sin$2(rotation);
    const rx = t2.x - origin.x;
    const ry = t2.y - origin.y;
    t2.x = origin.x + rx * cosR - ry * sinR;
    t2.y = origin.y + rx * sinR + ry * cosR;
  },
  tempToInnerOf(t2, matrix2) {
    const { tempPoint: temp } = P$5;
    copy$7(temp, t2);
    toInnerPoint$2(matrix2, temp, temp);
    return temp;
  },
  tempToOuterOf(t2, matrix2) {
    const { tempPoint: temp } = P$5;
    copy$7(temp, t2);
    toOuterPoint$3(matrix2, temp, temp);
    return temp;
  },
  tempToInnerRadiusPointOf(t2, matrix2) {
    const { tempRadiusPoint: temp } = P$5;
    copy$7(temp, t2);
    P$5.toInnerRadiusPointOf(t2, matrix2, temp);
    return temp;
  },
  toInnerRadiusPointOf(t2, matrix2, to) {
    to || (to = t2);
    toInnerPoint$2(matrix2, t2, to);
    to.radiusX = Math.abs(t2.radiusX / matrix2.scaleX);
    to.radiusY = Math.abs(t2.radiusY / matrix2.scaleY);
  },
  toInnerOf(t2, matrix2, to) {
    toInnerPoint$2(matrix2, t2, to);
  },
  toOuterOf(t2, matrix2, to) {
    toOuterPoint$3(matrix2, t2, to);
  },
  getCenter(t2, to) {
    return { x: t2.x + (to.x - t2.x) / 2, y: t2.y + (to.y - t2.y) / 2 };
  },
  getCenterX(x1, x2) {
    return x1 + (x2 - x1) / 2;
  },
  getCenterY(y1, y2) {
    return y1 + (y2 - y1) / 2;
  },
  getDistance(t2, point2) {
    return getDistanceFrom(t2.x, t2.y, point2.x, point2.y);
  },
  getDistanceFrom(x1, y1, x2, y2) {
    const x = abs$2(x2 - x1);
    const y = abs$2(y2 - y1);
    return sqrt$2(x * x + y * y);
  },
  getMinDistanceFrom(x1, y1, x2, y2, x3, y3) {
    return min$1(getDistanceFrom(x1, y1, x2, y2), getDistanceFrom(x2, y2, x3, y3));
  },
  getAngle(t2, to) {
    return getAtan2(t2, to) / OneRadian;
  },
  getRotation(t2, origin, to, toOrigin) {
    if (!toOrigin)
      toOrigin = origin;
    return P$5.getRadianFrom(t2.x, t2.y, origin.x, origin.y, to.x, to.y, toOrigin.x, toOrigin.y) / OneRadian;
  },
  getRadianFrom(fromX, fromY, originX, originY, toX, toY, toOriginX, toOriginY) {
    if (toOriginX === void 0)
      toOriginX = originX, toOriginY = originY;
    let fromAngle = atan2$2(fromY - originY, fromX - originX);
    let toAngle = atan2$2(toY - toOriginY, toX - toOriginX);
    const radian = toAngle - fromAngle;
    return radian < -PI$1 ? radian + PI2 : radian;
  },
  getAtan2(t2, to) {
    return atan2$2(to.y - t2.y, to.x - t2.x);
  },
  getDistancePoint(t2, to, distance, changeTo) {
    const r = getAtan2(t2, to);
    to = changeTo ? to : {};
    to.x = t2.x + cos$2(r) * distance;
    to.y = t2.y + sin$2(r) * distance;
    return to;
  },
  toNumberPoints(originPoints) {
    let points = originPoints;
    if (typeof originPoints[0] === "object")
      points = [], originPoints.forEach((p) => points.push(p.x, p.y));
    return points;
  },
  reset(t2) {
    P$5.reset(t2);
  }
};
var P$5 = PointHelper;
var { getDistanceFrom, copy: copy$7, getAtan2 } = P$5;
var Point = class _Point {
  constructor(x, y) {
    this.set(x, y);
  }
  set(x, y) {
    typeof x === "object" ? PointHelper.copy(this, x) : PointHelper.set(this, x, y);
    return this;
  }
  get() {
    const { x, y } = this;
    return { x, y };
  }
  clone() {
    return new _Point(this);
  }
  move(x, y) {
    PointHelper.move(this, x, y);
    return this;
  }
  scale(scaleX, scaleY) {
    PointHelper.scale(this, scaleX, scaleY);
    return this;
  }
  scaleOf(origin, scaleX, scaleY) {
    PointHelper.scaleOf(this, origin, scaleX, scaleY);
    return this;
  }
  rotate(rotation, origin) {
    PointHelper.rotate(this, rotation, origin);
    return this;
  }
  rotateOf(origin, rotation) {
    PointHelper.rotate(this, rotation, origin);
    return this;
  }
  getRotation(origin, to, toOrigin) {
    return PointHelper.getRotation(this, origin, to, toOrigin);
  }
  toInnerOf(matrix2, to) {
    PointHelper.toInnerOf(this, matrix2, to);
    return this;
  }
  toOuterOf(matrix2, to) {
    PointHelper.toOuterOf(this, matrix2, to);
    return this;
  }
  getCenter(to) {
    return new _Point(PointHelper.getCenter(this, to));
  }
  getDistance(to) {
    return PointHelper.getDistance(this, to);
  }
  getDistancePoint(to, distance, changeTo) {
    return new _Point(PointHelper.getDistancePoint(this, to, distance, changeTo));
  }
  getAngle(to) {
    return PointHelper.getAngle(this, to);
  }
  getAtan2(to) {
    return PointHelper.getAtan2(this, to);
  }
  reset() {
    PointHelper.reset(this);
    return this;
  }
};
var tempPoint$2 = new Point();
var Matrix = class _Matrix {
  constructor(a2, b, c2, d, e, f) {
    this.set(a2, b, c2, d, e, f);
  }
  set(a2, b, c2, d, e, f) {
    typeof a2 === "object" ? MatrixHelper.copy(this, a2) : MatrixHelper.set(this, a2, b, c2, d, e, f);
    return this;
  }
  setWith(dataWithScale) {
    MatrixHelper.copy(this, dataWithScale);
    this.scaleX = dataWithScale.scaleX;
    this.scaleY = dataWithScale.scaleY;
    return this;
  }
  get() {
    const { a: a2, b, c: c2, d, e, f } = this;
    return { a: a2, b, c: c2, d, e, f };
  }
  clone() {
    return new _Matrix(this);
  }
  translate(x, y) {
    MatrixHelper.translate(this, x, y);
    return this;
  }
  translateInner(x, y) {
    MatrixHelper.translateInner(this, x, y);
    return this;
  }
  scale(x, y) {
    MatrixHelper.scale(this, x, y);
    return this;
  }
  scaleWith(x, y) {
    MatrixHelper.scale(this, x, y);
    this.scaleX *= x;
    this.scaleY *= y || x;
    return this;
  }
  scaleOfOuter(origin, x, y) {
    MatrixHelper.scaleOfOuter(this, origin, x, y);
    return this;
  }
  scaleOfInner(origin, x, y) {
    MatrixHelper.scaleOfInner(this, origin, x, y);
    return this;
  }
  rotate(angle) {
    MatrixHelper.rotate(this, angle);
    return this;
  }
  rotateOfOuter(origin, angle) {
    MatrixHelper.rotateOfOuter(this, origin, angle);
    return this;
  }
  rotateOfInner(origin, angle) {
    MatrixHelper.rotateOfInner(this, origin, angle);
    return this;
  }
  skew(x, y) {
    MatrixHelper.skew(this, x, y);
    return this;
  }
  skewOfOuter(origin, x, y) {
    MatrixHelper.skewOfOuter(this, origin, x, y);
    return this;
  }
  skewOfInner(origin, x, y) {
    MatrixHelper.skewOfInner(this, origin, x, y);
    return this;
  }
  multiply(child) {
    MatrixHelper.multiply(this, child);
    return this;
  }
  multiplyParent(parent) {
    MatrixHelper.multiplyParent(this, parent);
    return this;
  }
  divide(child) {
    MatrixHelper.divide(this, child);
    return this;
  }
  divideParent(parent) {
    MatrixHelper.divideParent(this, parent);
    return this;
  }
  invert() {
    MatrixHelper.invert(this);
    return this;
  }
  invertWith() {
    MatrixHelper.invert(this);
    this.scaleX = 1 / this.scaleX;
    this.scaleY = 1 / this.scaleY;
    return this;
  }
  toOuterPoint(inner, to, distance) {
    MatrixHelper.toOuterPoint(this, inner, to, distance);
  }
  toInnerPoint(outer, to, distance) {
    MatrixHelper.toInnerPoint(this, outer, to, distance);
  }
  setLayout(data, origin, around) {
    MatrixHelper.setLayout(this, data, origin, around);
    return this;
  }
  getLayout(origin, around, firstSkewY) {
    return MatrixHelper.getLayout(this, origin, around, firstSkewY);
  }
  withScale(scaleX, scaleY) {
    return MatrixHelper.withScale(this, scaleX, scaleY);
  }
  reset() {
    MatrixHelper.reset(this);
  }
};
var tempMatrix = new Matrix();
var TwoPointBoundsHelper = {
  tempPointBounds: {},
  setPoint(t2, minX, minY) {
    t2.minX = t2.maxX = minX;
    t2.minY = t2.maxY = minY;
  },
  addPoint(t2, x, y) {
    t2.minX = x < t2.minX ? x : t2.minX;
    t2.minY = y < t2.minY ? y : t2.minY;
    t2.maxX = x > t2.maxX ? x : t2.maxX;
    t2.maxY = y > t2.maxY ? y : t2.maxY;
  },
  addBounds(t2, x, y, width, height) {
    addPoint$3(t2, x, y);
    addPoint$3(t2, x + width, y + height);
  },
  copy(t2, pb) {
    t2.minX = pb.minX;
    t2.minY = pb.minY;
    t2.maxX = pb.maxX;
    t2.maxY = pb.maxY;
  },
  addPointBounds(t2, pb) {
    t2.minX = pb.minX < t2.minX ? pb.minX : t2.minX;
    t2.minY = pb.minY < t2.minY ? pb.minY : t2.minY;
    t2.maxX = pb.maxX > t2.maxX ? pb.maxX : t2.maxX;
    t2.maxY = pb.maxY > t2.maxY ? pb.maxY : t2.maxY;
  },
  toBounds(t2, setBounds) {
    setBounds.x = t2.minX;
    setBounds.y = t2.minY;
    setBounds.width = t2.maxX - t2.minX;
    setBounds.height = t2.maxY - t2.minY;
  }
};
var { addPoint: addPoint$3 } = TwoPointBoundsHelper;
var { tempPointBounds: tempPointBounds$1, setPoint: setPoint$2, addPoint: addPoint$2, toBounds: toBounds$2 } = TwoPointBoundsHelper;
var { toOuterPoint: toOuterPoint$2 } = MatrixHelper;
var { float, fourNumber } = MathHelper;
var { floor, ceil: ceil$1 } = Math;
var right;
var bottom;
var boundsRight;
var boundsBottom;
var point = {};
var toPoint$2 = {};
var BoundsHelper = {
  tempBounds: {},
  set(t2, x = 0, y = 0, width = 0, height = 0) {
    t2.x = x;
    t2.y = y;
    t2.width = width;
    t2.height = height;
  },
  copy(t2, bounds) {
    t2.x = bounds.x;
    t2.y = bounds.y;
    t2.width = bounds.width;
    t2.height = bounds.height;
  },
  copyAndSpread(t2, bounds, spread2, isShrink, side) {
    const { x, y, width, height } = bounds;
    if (spread2 instanceof Array) {
      const four = fourNumber(spread2);
      isShrink ? B.set(t2, x + four[3], y + four[0], width - four[1] - four[3], height - four[2] - four[0]) : B.set(t2, x - four[3], y - four[0], width + four[1] + four[3], height + four[2] + four[0]);
    } else {
      if (isShrink)
        spread2 = -spread2;
      B.set(t2, x - spread2, y - spread2, width + spread2 * 2, height + spread2 * 2);
    }
    if (side) {
      if (side === "width")
        t2.y = y, t2.height = height;
      else
        t2.x = x, t2.width = width;
    }
  },
  minX(t2) {
    return t2.width > 0 ? t2.x : t2.x + t2.width;
  },
  minY(t2) {
    return t2.height > 0 ? t2.y : t2.y + t2.height;
  },
  maxX(t2) {
    return t2.width > 0 ? t2.x + t2.width : t2.x;
  },
  maxY(t2) {
    return t2.height > 0 ? t2.y + t2.height : t2.y;
  },
  move(t2, x, y) {
    t2.x += x;
    t2.y += y;
  },
  getByMove(t2, x, y) {
    t2 = Object.assign({}, t2);
    B.move(t2, x, y);
    return t2;
  },
  toOffsetOutBounds(t2, to, parent) {
    if (!to) {
      to = t2;
    } else {
      copy$6(to, t2);
    }
    if (parent) {
      to.offsetX = -(B.maxX(parent) - t2.x);
      to.offsetY = -(B.maxY(parent) - t2.y);
    } else {
      to.offsetX = t2.x + t2.width;
      to.offsetY = t2.y + t2.height;
    }
    B.move(to, -to.offsetX, -to.offsetY);
  },
  scale(t2, scaleX, scaleY = scaleX) {
    PointHelper.scale(t2, scaleX, scaleY);
    t2.width *= scaleX;
    t2.height *= scaleY;
  },
  scaleOf(t2, origin, scaleX, scaleY = scaleX) {
    PointHelper.scaleOf(t2, origin, scaleX, scaleY);
    t2.width *= scaleX;
    t2.height *= scaleY;
  },
  tempToOuterOf(t2, matrix2) {
    B.copy(B.tempBounds, t2);
    B.toOuterOf(B.tempBounds, matrix2);
    return B.tempBounds;
  },
  getOuterOf(t2, matrix2) {
    t2 = Object.assign({}, t2);
    B.toOuterOf(t2, matrix2);
    return t2;
  },
  toOuterOf(t2, matrix2, to) {
    to || (to = t2);
    if (matrix2.b === 0 && matrix2.c === 0) {
      const { a: a2, d } = matrix2;
      if (a2 > 0) {
        to.width = t2.width * a2;
        to.x = matrix2.e + t2.x * a2;
      } else {
        to.width = t2.width * -a2;
        to.x = matrix2.e + t2.x * a2 - to.width;
      }
      if (d > 0) {
        to.height = t2.height * d;
        to.y = matrix2.f + t2.y * d;
      } else {
        to.height = t2.height * -d;
        to.y = matrix2.f + t2.y * d - to.height;
      }
    } else {
      point.x = t2.x;
      point.y = t2.y;
      toOuterPoint$2(matrix2, point, toPoint$2);
      setPoint$2(tempPointBounds$1, toPoint$2.x, toPoint$2.y);
      point.x = t2.x + t2.width;
      toOuterPoint$2(matrix2, point, toPoint$2);
      addPoint$2(tempPointBounds$1, toPoint$2.x, toPoint$2.y);
      point.y = t2.y + t2.height;
      toOuterPoint$2(matrix2, point, toPoint$2);
      addPoint$2(tempPointBounds$1, toPoint$2.x, toPoint$2.y);
      point.x = t2.x;
      toOuterPoint$2(matrix2, point, toPoint$2);
      addPoint$2(tempPointBounds$1, toPoint$2.x, toPoint$2.y);
      toBounds$2(tempPointBounds$1, to);
    }
  },
  toInnerOf(t2, matrix2, to) {
    to || (to = t2);
    B.move(to, -matrix2.e, -matrix2.f);
    B.scale(to, 1 / matrix2.a, 1 / matrix2.d);
  },
  getFitMatrix(t2, put, baseScale = 1) {
    const scale = Math.min(baseScale, Math.min(t2.width / put.width, t2.height / put.height));
    return new Matrix(scale, 0, 0, scale, -put.x * scale, -put.y * scale);
  },
  getSpread(t2, spread2, side) {
    const n = {};
    B.copyAndSpread(n, t2, spread2, false, side);
    return n;
  },
  spread(t2, spread2, side) {
    B.copyAndSpread(t2, t2, spread2, false, side);
  },
  shrink(t2, shrink, side) {
    B.copyAndSpread(t2, t2, shrink, true, side);
  },
  ceil(t2) {
    const { x, y } = t2;
    t2.x = floor(t2.x);
    t2.y = floor(t2.y);
    t2.width = x > t2.x ? ceil$1(t2.width + x - t2.x) : ceil$1(t2.width);
    t2.height = y > t2.y ? ceil$1(t2.height + y - t2.y) : ceil$1(t2.height);
  },
  unsign(t2) {
    if (t2.width < 0) {
      t2.x += t2.width;
      t2.width = -t2.width;
    }
    if (t2.height < 0) {
      t2.y += t2.height;
      t2.height = -t2.height;
    }
  },
  float(t2, maxLength) {
    t2.x = float(t2.x, maxLength);
    t2.y = float(t2.y, maxLength);
    t2.width = float(t2.width, maxLength);
    t2.height = float(t2.height, maxLength);
  },
  add(t2, bounds, isPoint) {
    right = t2.x + t2.width;
    bottom = t2.y + t2.height;
    boundsRight = bounds.x;
    boundsBottom = bounds.y;
    if (!isPoint) {
      boundsRight += bounds.width;
      boundsBottom += bounds.height;
    }
    right = right > boundsRight ? right : boundsRight;
    bottom = bottom > boundsBottom ? bottom : boundsBottom;
    t2.x = t2.x < bounds.x ? t2.x : bounds.x;
    t2.y = t2.y < bounds.y ? t2.y : bounds.y;
    t2.width = right - t2.x;
    t2.height = bottom - t2.y;
  },
  addList(t2, list2) {
    B.setListWithFn(t2, list2, void 0, true);
  },
  setList(t2, list2, addMode = false) {
    B.setListWithFn(t2, list2, void 0, addMode);
  },
  addListWithFn(t2, list2, boundsDataFn) {
    B.setListWithFn(t2, list2, boundsDataFn, true);
  },
  setListWithFn(t2, list2, boundsDataFn, addMode = false) {
    let bounds, first = true;
    for (let i = 0, len = list2.length; i < len; i++) {
      bounds = boundsDataFn ? boundsDataFn(list2[i]) : list2[i];
      if (bounds && (bounds.width || bounds.height)) {
        if (first) {
          first = false;
          if (!addMode)
            copy$6(t2, bounds);
        } else {
          add(t2, bounds);
        }
      }
    }
    if (first)
      B.reset(t2);
  },
  setPoints(t2, points) {
    points.forEach((point2, index) => index === 0 ? setPoint$2(tempPointBounds$1, point2.x, point2.y) : addPoint$2(tempPointBounds$1, point2.x, point2.y));
    toBounds$2(tempPointBounds$1, t2);
  },
  setPoint(t2, point2) {
    B.set(t2, point2.x, point2.y);
  },
  addPoint(t2, point2) {
    add(t2, point2, true);
  },
  getPoints(t2) {
    const { x, y, width, height } = t2;
    return [
      { x, y },
      { x: x + width, y },
      { x: x + width, y: y + height },
      { x, y: y + height }
    ];
  },
  hitRadiusPoint(t2, point2, pointMatrix) {
    if (pointMatrix)
      point2 = PointHelper.tempToInnerRadiusPointOf(point2, pointMatrix);
    return point2.x >= t2.x - point2.radiusX && point2.x <= t2.x + t2.width + point2.radiusX && (point2.y >= t2.y - point2.radiusY && point2.y <= t2.y + t2.height + point2.radiusY);
  },
  hitPoint(t2, point2, pointMatrix) {
    if (pointMatrix)
      point2 = PointHelper.tempToInnerOf(point2, pointMatrix);
    return point2.x >= t2.x && point2.x <= t2.x + t2.width && (point2.y >= t2.y && point2.y <= t2.y + t2.height);
  },
  hit(t2, other, otherMatrix) {
    if (otherMatrix)
      other = B.tempToOuterOf(other, otherMatrix);
    return !(t2.y + t2.height < other.y || other.y + other.height < t2.y || t2.x + t2.width < other.x || other.x + other.width < t2.x);
  },
  includes(t2, other, otherMatrix) {
    if (otherMatrix)
      other = B.tempToOuterOf(other, otherMatrix);
    return t2.x <= other.x && t2.y <= other.y && t2.x + t2.width >= other.x + other.width && t2.y + t2.height >= other.y + other.height;
  },
  getIntersectData(t2, other, otherMatrix) {
    if (otherMatrix)
      other = B.tempToOuterOf(other, otherMatrix);
    if (!B.hit(t2, other))
      return getBoundsData();
    let { x, y, width, height } = other;
    right = x + width;
    bottom = y + height;
    boundsRight = t2.x + t2.width;
    boundsBottom = t2.y + t2.height;
    x = x > t2.x ? x : t2.x;
    y = y > t2.y ? y : t2.y;
    right = right < boundsRight ? right : boundsRight;
    bottom = bottom < boundsBottom ? bottom : boundsBottom;
    width = right - x;
    height = bottom - y;
    return { x, y, width, height };
  },
  intersect(t2, other, otherMatrix) {
    B.copy(t2, B.getIntersectData(t2, other, otherMatrix));
  },
  isSame(t2, bounds) {
    return t2.x === bounds.x && t2.y === bounds.y && t2.width === bounds.width && t2.height === bounds.height;
  },
  isEmpty(t2) {
    return t2.x === 0 && t2.y === 0 && t2.width === 0 && t2.height === 0;
  },
  reset(t2) {
    B.set(t2);
  }
};
var B = BoundsHelper;
var { add, copy: copy$6 } = B;
var Bounds = class _Bounds {
  get minX() {
    return BoundsHelper.minX(this);
  }
  get minY() {
    return BoundsHelper.minY(this);
  }
  get maxX() {
    return BoundsHelper.maxX(this);
  }
  get maxY() {
    return BoundsHelper.maxY(this);
  }
  constructor(x, y, width, height) {
    this.set(x, y, width, height);
  }
  set(x, y, width, height) {
    typeof x === "object" ? BoundsHelper.copy(this, x) : BoundsHelper.set(this, x, y, width, height);
    return this;
  }
  get() {
    const { x, y, width, height } = this;
    return { x, y, width, height };
  }
  clone() {
    return new _Bounds(this);
  }
  move(x, y) {
    BoundsHelper.move(this, x, y);
    return this;
  }
  scale(scaleX, scaleY) {
    BoundsHelper.scale(this, scaleX, scaleY);
    return this;
  }
  scaleOf(origin, scaleX, scaleY) {
    BoundsHelper.scaleOf(this, origin, scaleX, scaleY);
    return this;
  }
  toOuterOf(matrix2, to) {
    BoundsHelper.toOuterOf(this, matrix2, to);
    return this;
  }
  toInnerOf(matrix2, to) {
    BoundsHelper.toInnerOf(this, matrix2, to);
    return this;
  }
  getFitMatrix(put, baseScale) {
    return BoundsHelper.getFitMatrix(this, put, baseScale);
  }
  spread(fourNumber2, side) {
    BoundsHelper.spread(this, fourNumber2, side);
    return this;
  }
  shrink(fourNumber2, side) {
    BoundsHelper.shrink(this, fourNumber2, side);
    return this;
  }
  ceil() {
    BoundsHelper.ceil(this);
    return this;
  }
  unsign() {
    BoundsHelper.unsign(this);
    return this;
  }
  float(maxLength) {
    BoundsHelper.float(this, maxLength);
    return this;
  }
  add(bounds) {
    BoundsHelper.add(this, bounds);
    return this;
  }
  addList(boundsList) {
    BoundsHelper.setList(this, boundsList, true);
    return this;
  }
  setList(boundsList) {
    BoundsHelper.setList(this, boundsList);
    return this;
  }
  addListWithFn(list2, boundsDataFn) {
    BoundsHelper.setListWithFn(this, list2, boundsDataFn, true);
    return this;
  }
  setListWithFn(list2, boundsDataFn) {
    BoundsHelper.setListWithFn(this, list2, boundsDataFn);
    return this;
  }
  setPoint(point2) {
    BoundsHelper.setPoint(this, point2);
    return this;
  }
  setPoints(points) {
    BoundsHelper.setPoints(this, points);
    return this;
  }
  addPoint(point2) {
    BoundsHelper.addPoint(this, point2);
    return this;
  }
  getPoints() {
    return BoundsHelper.getPoints(this);
  }
  hitPoint(point2, pointMatrix) {
    return BoundsHelper.hitPoint(this, point2, pointMatrix);
  }
  hitRadiusPoint(point2, pointMatrix) {
    return BoundsHelper.hitRadiusPoint(this, point2, pointMatrix);
  }
  hit(bounds, boundsMatrix) {
    return BoundsHelper.hit(this, bounds, boundsMatrix);
  }
  includes(bounds, boundsMatrix) {
    return BoundsHelper.includes(this, bounds, boundsMatrix);
  }
  intersect(bounds, boundsMatrix) {
    BoundsHelper.intersect(this, bounds, boundsMatrix);
    return this;
  }
  getIntersect(bounds, boundsMatrix) {
    return new _Bounds(BoundsHelper.getIntersectData(this, bounds, boundsMatrix));
  }
  isSame(bounds) {
    return BoundsHelper.isSame(this, bounds);
  }
  isEmpty() {
    return BoundsHelper.isEmpty(this);
  }
  reset() {
    BoundsHelper.reset(this);
  }
};
var tempBounds = new Bounds();
var AutoBounds = class {
  constructor(top, right2, bottom2, left, width, height) {
    typeof top === "object" ? this.copy(top) : this.set(top, right2, bottom2, left, width, height);
  }
  set(top = 0, right2 = 0, bottom2 = 0, left = 0, width = 0, height = 0) {
    this.top = top;
    this.right = right2;
    this.bottom = bottom2;
    this.left = left;
    this.width = width;
    this.height = height;
  }
  copy(autoSize) {
    const { top, right: right2, bottom: bottom2, left, width, height } = autoSize;
    this.set(top, right2, bottom2, left, width, height);
  }
  getBoundsFrom(parent) {
    const { top, right: right2, bottom: bottom2, left, width, height } = this;
    return new Bounds(left, top, width ? width : parent.width - left - right2, height ? height : parent.height - top - bottom2);
  }
};
var Direction4;
(function(Direction42) {
  Direction42[Direction42["top"] = 0] = "top";
  Direction42[Direction42["right"] = 1] = "right";
  Direction42[Direction42["bottom"] = 2] = "bottom";
  Direction42[Direction42["left"] = 3] = "left";
})(Direction4 || (Direction4 = {}));
var Direction9;
(function(Direction92) {
  Direction92[Direction92["topLeft"] = 0] = "topLeft";
  Direction92[Direction92["top"] = 1] = "top";
  Direction92[Direction92["topRight"] = 2] = "topRight";
  Direction92[Direction92["right"] = 3] = "right";
  Direction92[Direction92["bottomRight"] = 4] = "bottomRight";
  Direction92[Direction92["bottom"] = 5] = "bottom";
  Direction92[Direction92["bottomLeft"] = 6] = "bottomLeft";
  Direction92[Direction92["left"] = 7] = "left";
  Direction92[Direction92["center"] = 8] = "center";
  Direction92[Direction92["top-left"] = 0] = "top-left";
  Direction92[Direction92["top-right"] = 2] = "top-right";
  Direction92[Direction92["bottom-right"] = 4] = "bottom-right";
  Direction92[Direction92["bottom-left"] = 6] = "bottom-left";
})(Direction9 || (Direction9 = {}));
var directionData = [
  { x: 0, y: 0 },
  { x: 0.5, y: 0 },
  { x: 1, y: 0 },
  { x: 1, y: 0.5 },
  { x: 1, y: 1 },
  { x: 0.5, y: 1 },
  { x: 0, y: 1 },
  { x: 0, y: 0.5 },
  { x: 0.5, y: 0.5 }
];
directionData.forEach((item) => item.type = "percent");
var AroundHelper = {
  directionData,
  tempPoint: {},
  get,
  toPoint(around, bounds, to, onlySize, pointBounds) {
    const point2 = get(around);
    to.x = point2.x;
    to.y = point2.y;
    if (point2.type === "percent") {
      to.x *= bounds.width;
      to.y *= bounds.height;
      if (pointBounds) {
        to.x -= pointBounds.x;
        to.y -= pointBounds.y;
        if (point2.x)
          to.x -= point2.x === 1 ? pointBounds.width : point2.x === 0.5 ? point2.x * pointBounds.width : 0;
        if (point2.y)
          to.y -= point2.y === 1 ? pointBounds.height : point2.y === 0.5 ? point2.y * pointBounds.height : 0;
      }
    }
    if (!onlySize) {
      to.x += bounds.x;
      to.y += bounds.y;
    }
  }
};
function get(around) {
  return typeof around === "string" ? directionData[Direction9[around]] : around;
}
var { toPoint: toPoint$1 } = AroundHelper;
var AlignHelper = {
  toPoint(align, contentBounds, bounds, to, onlySize) {
    toPoint$1(align, bounds, to, onlySize, contentBounds);
  }
};
var StringNumberMap = {
  "0": 1,
  "1": 1,
  "2": 1,
  "3": 1,
  "4": 1,
  "5": 1,
  "6": 1,
  "7": 1,
  "8": 1,
  "9": 1,
  ".": 1,
  "e": 1,
  "E": 1
};
var Debug = class _Debug {
  constructor(name) {
    this.repeatMap = {};
    this.name = name;
  }
  static get(name) {
    return new _Debug(name);
  }
  static set filter(name) {
    this.filterList = getNameList(name);
  }
  static set exclude(name) {
    this.excludeList = getNameList(name);
  }
  log(...messages) {
    if (D$4.enable) {
      if (D$4.filterList.length && D$4.filterList.every((name) => name !== this.name))
        return;
      if (D$4.excludeList.length && D$4.excludeList.some((name) => name === this.name))
        return;
      console.log("%c" + this.name, "color:#21ae62", ...messages);
    }
  }
  tip(...messages) {
    if (D$4.enable)
      this.warn(...messages);
  }
  warn(...messages) {
    if (D$4.showWarn)
      console.warn(this.name, ...messages);
  }
  repeat(name, ...messages) {
    if (!this.repeatMap[name]) {
      this.warn("repeat:" + name, ...messages);
      this.repeatMap[name] = true;
    }
  }
  error(...messages) {
    try {
      throw new Error();
    } catch (e) {
      console.error(this.name, ...messages, e);
    }
  }
};
Debug.filterList = [];
Debug.excludeList = [];
Debug.showWarn = true;
function getNameList(name) {
  if (!name)
    name = [];
  else if (typeof name === "string")
    name = [name];
  return name;
}
var D$4 = Debug;
var debug$8 = Debug.get("RunTime");
var Run = {
  currentId: 0,
  currentName: "",
  idMap: {},
  nameMap: {},
  nameToIdMap: {},
  start(name, microsecond) {
    const id = IncrementId.create(IncrementId.RUNTIME);
    R.currentId = R.idMap[id] = microsecond ? performance.now() : Date.now();
    R.currentName = R.nameMap[id] = name;
    R.nameToIdMap[name] = id;
    return id;
  },
  end(id, microsecond) {
    const time = R.idMap[id], name = R.nameMap[id];
    const duration = microsecond ? (performance.now() - time) / 1e3 : Date.now() - time;
    R.idMap[id] = R.nameMap[id] = R.nameToIdMap[name] = void 0;
    debug$8.log(name, duration, "ms");
  },
  endOfName(name, microsecond) {
    const id = R.nameToIdMap[name];
    if (id !== void 0)
      R.end(id, microsecond);
  }
};
var R = Run;
function needPlugin(name) {
  console.error("need plugin: @leafer-in/" + name);
}
var debug$7 = Debug.get("UICreator");
var UICreator = {
  list: {},
  register(UI3) {
    const { __tag: tag } = UI3.prototype;
    if (list$1[tag])
      debug$7.repeat(tag);
    list$1[tag] = UI3;
  },
  get(tag, data, x, y, width, height) {
    if (!list$1[tag])
      debug$7.error("not register " + tag);
    const ui = new list$1[tag](data);
    if (x !== void 0) {
      ui.x = x;
      if (y)
        ui.y = y;
      if (width)
        ui.width = width;
      if (height)
        ui.height = height;
    }
    return ui;
  }
};
var { list: list$1 } = UICreator;
var debug$6 = Debug.get("EventCreator");
var EventCreator = {
  nameList: {},
  register(Event2) {
    let name;
    Object.keys(Event2).forEach((key) => {
      name = Event2[key];
      if (typeof name === "string")
        nameList[name] && debug$6.repeat(name), nameList[name] = Event2;
    });
  },
  changeName(oldName, newName) {
    const Event2 = nameList[oldName];
    if (Event2) {
      const constName = Object.keys(Event2).find((key) => Event2[key] === oldName);
      if (constName) {
        Event2[constName] = newName;
        nameList[newName] = Event2;
      }
    }
  },
  has(type) {
    return !!this.nameList[type];
  },
  get(type, ...params) {
    return new nameList[type](...params);
  }
};
var { nameList } = EventCreator;
var CanvasManager = class {
  constructor() {
    this.list = [];
  }
  add(canvas) {
    canvas.manager = this;
    this.list.push(canvas);
  }
  get(size) {
    let old;
    const { list: list2 } = this;
    for (let i = 0, len = list2.length; i < len; i++) {
      old = list2[i];
      if (old.recycled && old.isSameSize(size)) {
        old.recycled = false;
        old.manager || (old.manager = this);
        return old;
      }
    }
    const canvas = Creator.canvas(size);
    this.add(canvas);
    return canvas;
  }
  recycle(old) {
    old.recycled = true;
  }
  clearRecycled() {
    let canvas;
    const filter = [];
    for (let i = 0, len = this.list.length; i < len; i++) {
      canvas = this.list[i];
      canvas.recycled ? canvas.destroy() : filter.push(canvas);
    }
    this.list = filter;
  }
  clear() {
    this.list.forEach((item) => {
      item.destroy();
    });
    this.list.length = 0;
  }
  destroy() {
    this.clear();
  }
};
var DataHelper = {
  default(t2, defaultData) {
    assign(defaultData, t2);
    assign(t2, defaultData);
    return t2;
  },
  assign(t2, merge) {
    let value;
    Object.keys(merge).forEach((key) => {
      var _a;
      value = merge[key];
      if ((value === null || value === void 0 ? void 0 : value.constructor) === Object) {
        ((_a = t2[key]) === null || _a === void 0 ? void 0 : _a.constructor) === Object ? assign(t2[key], merge[key]) : t2[key] = merge[key];
      } else {
        t2[key] = merge[key];
      }
    });
  },
  copyAttrs(t2, from, include) {
    include.forEach((key) => {
      if (from[key] !== void 0)
        t2[key] = from[key];
    });
    return t2;
  },
  clone(data) {
    return JSON.parse(JSON.stringify(data));
  },
  toMap(list2) {
    const map = {};
    for (let i = 0, len = list2.length; i < len; i++)
      map[list2[i]] = true;
    return map;
  }
};
var { assign } = DataHelper;
var LeafData = class {
  get __useNaturalRatio() {
    return true;
  }
  get __isLinePath() {
    const { path } = this;
    return path && path.length === 6 && path[0] === 1;
  }
  get __blendMode() {
    if (this.eraser && this.eraser !== "path")
      return "destination-out";
    const { blendMode } = this;
    return blendMode === "pass-through" ? null : blendMode;
  }
  constructor(leaf) {
    this.__leaf = leaf;
  }
  __get(name) {
    if (this.__input) {
      const value = this.__input[name];
      if (value !== void 0)
        return value;
    }
    return this[name];
  }
  __getData() {
    const data = { tag: this.__leaf.tag }, { __input } = this;
    let inputValue;
    for (let key in this) {
      if (key[0] !== "_") {
        inputValue = __input ? __input[key] : void 0;
        data[key] = inputValue === void 0 ? this[key] : inputValue;
      }
    }
    return data;
  }
  __setInput(name, value) {
    this.__input || (this.__input = {});
    this.__input[name] = value;
  }
  __getInput(name) {
    if (this.__input) {
      const value = this.__input[name];
      if (value !== void 0)
        return value;
    }
    if (name === "path" && !this.__pathInputed)
      return;
    return this["_" + name];
  }
  __removeInput(name) {
    if (this.__input && this.__input[name] !== void 0)
      this.__input[name] = void 0;
  }
  __getInputData(names, options) {
    const data = {};
    if (names) {
      if (names instanceof Array) {
        for (let name of names)
          data[name] = this.__getInput(name);
      } else {
        for (let name in names)
          data[name] = this.__getInput(name);
      }
    } else {
      let value, inputValue, { __input } = this;
      data.tag = this.__leaf.tag;
      for (let key in this) {
        if (key[0] !== "_") {
          value = this["_" + key];
          if (value !== void 0) {
            if (key === "path" && !this.__pathInputed)
              continue;
            inputValue = __input ? __input[key] : void 0;
            data[key] = inputValue === void 0 ? value : inputValue;
          }
        }
      }
    }
    if (options) {
      if (options.matrix) {
        const { a: a2, b, c: c2, d, e, f } = this.__leaf.__localMatrix;
        data.matrix = { a: a2, b, c: c2, d, e, f };
      }
    }
    return data;
  }
  __setMiddle(name, value) {
    this.__middle || (this.__middle = {});
    this.__middle[name] = value;
  }
  __getMiddle(name) {
    return this.__middle && this.__middle[name];
  }
  __checkSingle() {
    const t2 = this;
    if (t2.blendMode === "pass-through") {
      const leaf = this.__leaf;
      if (t2.opacity < 1 && (leaf.isBranch || t2.__hasMultiPaint) || leaf.__hasEraser || t2.eraser) {
        t2.__single = true;
      } else if (t2.__single) {
        t2.__single = false;
      }
    } else {
      t2.__single = true;
    }
  }
  __removeNaturalSize() {
    this.__naturalWidth = this.__naturalHeight = void 0;
  }
  destroy() {
    this.__input = this.__middle = null;
  }
};
var Answer;
(function(Answer2) {
  Answer2[Answer2["No"] = 0] = "No";
  Answer2[Answer2["Yes"] = 1] = "Yes";
  Answer2[Answer2["NoAndSkip"] = 2] = "NoAndSkip";
  Answer2[Answer2["YesAndSkip"] = 3] = "YesAndSkip";
})(Answer || (Answer = {}));
var emptyData = {};
function isNull(value) {
  return value === void 0 || value === null;
}
function __decorate(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
}
function __awaiter(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function contextAttr(realName) {
  return (target, key) => {
    if (!realName)
      realName = key;
    Object.defineProperty(target, key, {
      get() {
        return this.context[realName];
      },
      set(value) {
        this.context[realName] = value;
      }
    });
  };
}
var contextMethodNameList = [];
function contextMethod() {
  return (_target, key) => {
    contextMethodNameList.push(key);
  };
}
var emptyArray = [];
var Canvas = class {
  set blendMode(value) {
    if (value === "normal")
      value = "source-over";
    this.context.globalCompositeOperation = value;
  }
  get blendMode() {
    return this.context.globalCompositeOperation;
  }
  set dashPattern(value) {
    this.context.setLineDash(value || emptyArray);
  }
  get dashPattern() {
    return this.context.getLineDash();
  }
  __bindContext() {
    let method;
    contextMethodNameList.forEach((name) => {
      method = this.context[name];
      if (method)
        this[name] = method.bind(this.context);
    });
    this.textBaseline = "alphabetic";
  }
  setTransform(_a, _b, _c, _d, _e, _f) {
  }
  resetTransform() {
  }
  getTransform() {
    return void 0;
  }
  save() {
  }
  restore() {
  }
  transform(a2, b, c2, d, e, f) {
    if (typeof a2 === "object") {
      this.context.transform(a2.a, a2.b, a2.c, a2.d, a2.e, a2.f);
    } else {
      this.context.transform(a2, b, c2, d, e, f);
    }
  }
  translate(_x, _y) {
  }
  scale(_x, _y) {
  }
  rotate(_angle) {
  }
  fill(_path2d, _rule) {
  }
  stroke(_path2d) {
  }
  clip(_path2d, _rule) {
  }
  fillRect(_x, _y, _width, _height) {
  }
  strokeRect(_x, _y, _width, _height) {
  }
  clearRect(_x, _y, _width, _height) {
  }
  drawImage(image, sx, sy, sw, sh, dx, dy, dw, dh) {
    switch (arguments.length) {
      case 9:
        if (sx < 0) {
          const d = -sx / sw * dw;
          sw += sx;
          sx = 0;
          dx += d;
          dw -= d;
        }
        if (sy < 0) {
          const d = -sy / sh * dh;
          sh += sy;
          sy = 0;
          dy += d;
          dh -= d;
        }
        this.context.drawImage(image, sx, sy, sw, sh, dx, dy, dw, dh);
        break;
      case 5:
        this.context.drawImage(image, sx, sy, sw, sh);
        break;
      case 3:
        this.context.drawImage(image, sx, sy);
    }
  }
  beginPath() {
  }
  moveTo(_x, _y) {
  }
  lineTo(_x, _y) {
  }
  bezierCurveTo(_cp1x, _cp1y, _cp2x, _cp2y, _x, _y) {
  }
  quadraticCurveTo(_cpx, _cpy, _x, _y) {
  }
  closePath() {
  }
  arc(_x, _y, _radius, _startAngle, _endAngle, _anticlockwise) {
  }
  arcTo(_x1, _y1, _x2, _y2, _radius) {
  }
  ellipse(_x, _y, _radiusX, _radiusY, _rotation, _startAngle, _endAngle, _anticlockwise) {
  }
  rect(_x, _y, _width, _height) {
  }
  roundRect(_x, _y, _width, _height, _radius) {
  }
  createConicGradient(_startAngle, _x, _y) {
    return void 0;
  }
  createLinearGradient(_x0, _y0, _x1, _y1) {
    return void 0;
  }
  createPattern(_image, _repetition) {
    return void 0;
  }
  createRadialGradient(_x0, _y0, _r0, _x1, _y1, _r1) {
    return void 0;
  }
  fillText(_text, _x, _y, _maxWidth) {
  }
  measureText(_text) {
    return void 0;
  }
  strokeText(_text, _x, _y, _maxWidth) {
  }
  destroy() {
    this.context = null;
  }
};
__decorate([
  contextAttr("imageSmoothingEnabled")
], Canvas.prototype, "smooth", void 0);
__decorate([
  contextAttr("imageSmoothingQuality")
], Canvas.prototype, "smoothLevel", void 0);
__decorate([
  contextAttr("globalAlpha")
], Canvas.prototype, "opacity", void 0);
__decorate([
  contextAttr()
], Canvas.prototype, "fillStyle", void 0);
__decorate([
  contextAttr()
], Canvas.prototype, "strokeStyle", void 0);
__decorate([
  contextAttr("lineWidth")
], Canvas.prototype, "strokeWidth", void 0);
__decorate([
  contextAttr("lineCap")
], Canvas.prototype, "strokeCap", void 0);
__decorate([
  contextAttr("lineJoin")
], Canvas.prototype, "strokeJoin", void 0);
__decorate([
  contextAttr("lineDashOffset")
], Canvas.prototype, "dashOffset", void 0);
__decorate([
  contextAttr()
], Canvas.prototype, "miterLimit", void 0);
__decorate([
  contextAttr()
], Canvas.prototype, "shadowBlur", void 0);
__decorate([
  contextAttr()
], Canvas.prototype, "shadowColor", void 0);
__decorate([
  contextAttr()
], Canvas.prototype, "shadowOffsetX", void 0);
__decorate([
  contextAttr()
], Canvas.prototype, "shadowOffsetY", void 0);
__decorate([
  contextAttr()
], Canvas.prototype, "filter", void 0);
__decorate([
  contextAttr()
], Canvas.prototype, "font", void 0);
__decorate([
  contextAttr()
], Canvas.prototype, "fontKerning", void 0);
__decorate([
  contextAttr()
], Canvas.prototype, "fontStretch", void 0);
__decorate([
  contextAttr()
], Canvas.prototype, "fontVariantCaps", void 0);
__decorate([
  contextAttr()
], Canvas.prototype, "textAlign", void 0);
__decorate([
  contextAttr()
], Canvas.prototype, "textBaseline", void 0);
__decorate([
  contextAttr()
], Canvas.prototype, "textRendering", void 0);
__decorate([
  contextAttr()
], Canvas.prototype, "wordSpacing", void 0);
__decorate([
  contextAttr()
], Canvas.prototype, "letterSpacing", void 0);
__decorate([
  contextAttr()
], Canvas.prototype, "direction", void 0);
__decorate([
  contextMethod()
], Canvas.prototype, "setTransform", null);
__decorate([
  contextMethod()
], Canvas.prototype, "resetTransform", null);
__decorate([
  contextMethod()
], Canvas.prototype, "getTransform", null);
__decorate([
  contextMethod()
], Canvas.prototype, "save", null);
__decorate([
  contextMethod()
], Canvas.prototype, "restore", null);
__decorate([
  contextMethod()
], Canvas.prototype, "translate", null);
__decorate([
  contextMethod()
], Canvas.prototype, "scale", null);
__decorate([
  contextMethod()
], Canvas.prototype, "rotate", null);
__decorate([
  contextMethod()
], Canvas.prototype, "fill", null);
__decorate([
  contextMethod()
], Canvas.prototype, "stroke", null);
__decorate([
  contextMethod()
], Canvas.prototype, "clip", null);
__decorate([
  contextMethod()
], Canvas.prototype, "fillRect", null);
__decorate([
  contextMethod()
], Canvas.prototype, "strokeRect", null);
__decorate([
  contextMethod()
], Canvas.prototype, "clearRect", null);
__decorate([
  contextMethod()
], Canvas.prototype, "beginPath", null);
__decorate([
  contextMethod()
], Canvas.prototype, "moveTo", null);
__decorate([
  contextMethod()
], Canvas.prototype, "lineTo", null);
__decorate([
  contextMethod()
], Canvas.prototype, "bezierCurveTo", null);
__decorate([
  contextMethod()
], Canvas.prototype, "quadraticCurveTo", null);
__decorate([
  contextMethod()
], Canvas.prototype, "closePath", null);
__decorate([
  contextMethod()
], Canvas.prototype, "arc", null);
__decorate([
  contextMethod()
], Canvas.prototype, "arcTo", null);
__decorate([
  contextMethod()
], Canvas.prototype, "ellipse", null);
__decorate([
  contextMethod()
], Canvas.prototype, "rect", null);
__decorate([
  contextMethod()
], Canvas.prototype, "roundRect", null);
__decorate([
  contextMethod()
], Canvas.prototype, "createConicGradient", null);
__decorate([
  contextMethod()
], Canvas.prototype, "createLinearGradient", null);
__decorate([
  contextMethod()
], Canvas.prototype, "createPattern", null);
__decorate([
  contextMethod()
], Canvas.prototype, "createRadialGradient", null);
__decorate([
  contextMethod()
], Canvas.prototype, "fillText", null);
__decorate([
  contextMethod()
], Canvas.prototype, "measureText", null);
__decorate([
  contextMethod()
], Canvas.prototype, "strokeText", null);
var { copy: copy$5 } = MatrixHelper;
var minSize = { width: 1, height: 1, pixelRatio: 1 };
var canvasSizeAttrs = ["width", "height", "pixelRatio"];
var LeaferCanvasBase = class extends Canvas {
  get width() {
    return this.size.width;
  }
  get height() {
    return this.size.height;
  }
  get pixelRatio() {
    return this.size.pixelRatio;
  }
  get pixelWidth() {
    return this.width * this.pixelRatio;
  }
  get pixelHeight() {
    return this.height * this.pixelRatio;
  }
  get allowBackgroundColor() {
    return this.view && this.parentView;
  }
  constructor(config, manager) {
    super();
    this.size = {};
    this.worldTransform = {};
    if (!config)
      config = minSize;
    if (!config.pixelRatio)
      config.pixelRatio = Platform.devicePixelRatio;
    this.manager = manager;
    this.innerId = IncrementId.create(IncrementId.CNAVAS);
    const { width, height, pixelRatio } = config;
    this.autoLayout = !width || !height;
    this.size.pixelRatio = pixelRatio;
    this.config = config;
    this.init();
  }
  init() {
  }
  __createContext() {
    const { view } = this;
    const { contextSettings } = this.config;
    this.context = contextSettings ? view.getContext("2d", contextSettings) : view.getContext("2d");
    this.__bindContext();
  }
  export(_filename, _options) {
    return void 0;
  }
  toBlob(_type, _quality) {
    return void 0;
  }
  toDataURL(_type, _quality) {
    return void 0;
  }
  saveAs(_filename, _quality) {
    return void 0;
  }
  resize(size) {
    if (this.isSameSize(size))
      return;
    let takeCanvas;
    if (this.context && !this.unreal && this.width) {
      takeCanvas = this.getSameCanvas();
      takeCanvas.copyWorld(this);
    }
    const s2 = this.size;
    DataHelper.copyAttrs(s2, size, canvasSizeAttrs);
    canvasSizeAttrs.forEach((key) => s2[key] || (s2[key] = 1));
    this.bounds = new Bounds(0, 0, this.width, this.height);
    if (this.context && !this.unreal) {
      this.updateViewSize();
      this.smooth = this.config.smooth;
    }
    this.updateClientBounds();
    if (this.context && !this.unreal && takeCanvas) {
      this.clearWorld(takeCanvas.bounds);
      this.copyWorld(takeCanvas);
      takeCanvas.recycle();
    }
  }
  updateViewSize() {
  }
  updateClientBounds() {
  }
  getClientBounds(update) {
    if (update)
      this.updateClientBounds();
    return this.clientBounds || this.bounds;
  }
  startAutoLayout(_autoBounds, _listener) {
  }
  stopAutoLayout() {
  }
  setCursor(_cursor) {
  }
  setWorld(matrix2, parentMatrix) {
    const { pixelRatio } = this;
    const w = this.worldTransform;
    if (parentMatrix) {
      const { a: a2, b, c: c2, d, e, f } = parentMatrix;
      this.setTransform(w.a = (matrix2.a * a2 + matrix2.b * c2) * pixelRatio, w.b = (matrix2.a * b + matrix2.b * d) * pixelRatio, w.c = (matrix2.c * a2 + matrix2.d * c2) * pixelRatio, w.d = (matrix2.c * b + matrix2.d * d) * pixelRatio, w.e = (matrix2.e * a2 + matrix2.f * c2 + e) * pixelRatio, w.f = (matrix2.e * b + matrix2.f * d + f) * pixelRatio);
    } else {
      this.setTransform(w.a = matrix2.a * pixelRatio, w.b = matrix2.b * pixelRatio, w.c = matrix2.c * pixelRatio, w.d = matrix2.d * pixelRatio, w.e = matrix2.e * pixelRatio, w.f = matrix2.f * pixelRatio);
    }
  }
  useWorldTransform(worldTransform) {
    if (worldTransform)
      this.worldTransform = worldTransform;
    const w = this.worldTransform;
    if (w)
      this.setTransform(w.a, w.b, w.c, w.d, w.e, w.f);
  }
  setStroke(color, strokeWidth, options) {
    if (strokeWidth)
      this.strokeWidth = strokeWidth;
    if (color)
      this.strokeStyle = color;
    if (options)
      this.setStrokeOptions(options);
  }
  setStrokeOptions(options) {
    this.strokeCap = options.strokeCap === "none" ? "butt" : options.strokeCap;
    this.strokeJoin = options.strokeJoin;
    this.dashPattern = options.dashPattern;
    this.dashOffset = options.dashOffset;
    this.miterLimit = options.miterLimit;
  }
  saveBlendMode(blendMode) {
    this.savedBlendMode = this.blendMode;
    this.blendMode = blendMode;
  }
  restoreBlendMode() {
    this.blendMode = this.savedBlendMode;
  }
  hitFill(_point, _fillRule) {
    return true;
  }
  hitStroke(_point, _strokeWidth) {
    return true;
  }
  hitPixel(_radiusPoint, _offset, _scale = 1) {
    return true;
  }
  setWorldShadow(x, y, blur, color) {
    const { pixelRatio } = this;
    this.shadowOffsetX = x * pixelRatio;
    this.shadowOffsetY = y * pixelRatio;
    this.shadowBlur = blur * pixelRatio;
    this.shadowColor = color || "black";
  }
  setWorldBlur(blur) {
    const { pixelRatio } = this;
    this.filter = `blur(${blur * pixelRatio}px)`;
  }
  copyWorld(canvas, from, to, blendMode) {
    if (blendMode)
      this.blendMode = blendMode;
    if (from) {
      const { pixelRatio } = this;
      if (!to)
        to = from;
      this.drawImage(canvas.view, from.x * pixelRatio, from.y * pixelRatio, from.width * pixelRatio, from.height * pixelRatio, to.x * pixelRatio, to.y * pixelRatio, to.width * pixelRatio, to.height * pixelRatio);
    } else {
      this.drawImage(canvas.view, 0, 0);
    }
    if (blendMode)
      this.blendMode = "source-over";
  }
  copyWorldToInner(canvas, fromWorld, toInnerBounds, blendMode) {
    if (blendMode)
      this.blendMode = blendMode;
    if (fromWorld.b || fromWorld.c) {
      this.save();
      this.resetTransform();
      this.copyWorld(canvas, fromWorld, BoundsHelper.tempToOuterOf(toInnerBounds, fromWorld));
      this.restore();
    } else {
      const { pixelRatio } = this;
      this.drawImage(canvas.view, fromWorld.x * pixelRatio, fromWorld.y * pixelRatio, fromWorld.width * pixelRatio, fromWorld.height * pixelRatio, toInnerBounds.x, toInnerBounds.y, toInnerBounds.width, toInnerBounds.height);
    }
    if (blendMode)
      this.blendMode = "source-over";
  }
  copyWorldByReset(canvas, from, to, blendMode, onlyResetTransform) {
    this.resetTransform();
    this.copyWorld(canvas, from, to, blendMode);
    if (!onlyResetTransform)
      this.useWorldTransform();
  }
  useGrayscaleAlpha(bounds) {
    this.setTempBounds(bounds, true, true);
    let alpha, pixel;
    const { context } = this, imageData = context.getImageData(tempBounds.x, tempBounds.y, tempBounds.width, tempBounds.height), { data } = imageData;
    for (let i = 0, len = data.length; i < len; i += 4) {
      pixel = data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114;
      if (alpha = data[i + 3])
        data[i + 3] = alpha === 255 ? pixel : alpha * (pixel / 255);
    }
    context.putImageData(imageData, tempBounds.x, tempBounds.y);
  }
  useMask(maskCanvas, fromBounds, toBounds3) {
    this.copyWorld(maskCanvas, fromBounds, toBounds3, "destination-in");
  }
  useEraser(eraserCanvas, fromBounds, toBounds3) {
    this.copyWorld(eraserCanvas, fromBounds, toBounds3, "destination-out");
  }
  fillWorld(bounds, color, blendMode) {
    if (blendMode)
      this.blendMode = blendMode;
    this.fillStyle = color;
    this.setTempBounds(bounds);
    this.fillRect(tempBounds.x, tempBounds.y, tempBounds.width, tempBounds.height);
    if (blendMode)
      this.blendMode = "source-over";
  }
  strokeWorld(bounds, color, blendMode) {
    if (blendMode)
      this.blendMode = blendMode;
    this.strokeStyle = color;
    this.setTempBounds(bounds);
    this.strokeRect(tempBounds.x, tempBounds.y, tempBounds.width, tempBounds.height);
    if (blendMode)
      this.blendMode = "source-over";
  }
  clearWorld(bounds, ceilPixel) {
    this.setTempBounds(bounds, ceilPixel);
    this.clearRect(tempBounds.x, tempBounds.y, tempBounds.width, tempBounds.height);
  }
  clipWorld(bounds, ceilPixel) {
    this.beginPath();
    this.setTempBounds(bounds, ceilPixel);
    this.rect(tempBounds.x, tempBounds.y, tempBounds.width, tempBounds.height);
    this.clip();
  }
  clear() {
    const { pixelRatio } = this;
    this.clearRect(0, 0, this.width * pixelRatio + 2, this.height * pixelRatio + 2);
  }
  setTempBounds(bounds, ceil2, intersect) {
    tempBounds.set(bounds);
    if (intersect)
      tempBounds.intersect(this.bounds);
    tempBounds.scale(this.pixelRatio);
    if (ceil2)
      tempBounds.ceil();
  }
  isSameSize(size) {
    return this.width === size.width && this.height === size.height && this.pixelRatio === size.pixelRatio;
  }
  getSameCanvas(useSameWorldTransform, useSameSmooth) {
    const canvas = this.manager ? this.manager.get(this.size) : Creator.canvas(Object.assign({}, this.size));
    canvas.save();
    if (useSameWorldTransform)
      copy$5(canvas.worldTransform, this.worldTransform), canvas.useWorldTransform();
    if (useSameSmooth)
      canvas.smooth = this.smooth;
    return canvas;
  }
  recycle(clearBounds) {
    if (!this.recycled) {
      this.restore();
      clearBounds ? this.clearWorld(clearBounds, true) : this.clear();
      this.manager ? this.manager.recycle(this) : this.destroy();
    }
  }
  updateRender(_bounds) {
  }
  unrealCanvas() {
  }
  destroy() {
    this.manager = this.view = this.parentView = null;
  }
};
var PathHelper = {
  creator: {},
  parse(_pathString, _curveMode) {
    return void 0;
  },
  convertToCanvasData(_old, _curveMode) {
    return void 0;
  }
};
var CanvasCommandOnlyMap = {
  N: 21,
  D: 22,
  X: 23,
  G: 24,
  F: 25,
  O: 26,
  P: 27,
  U: 28
};
var PathCommandMap = Object.assign({ M: 1, m: 10, L: 2, l: 20, H: 3, h: 30, V: 4, v: 40, C: 5, c: 50, S: 6, s: 60, Q: 7, q: 70, T: 8, t: 80, A: 9, a: 90, Z: 11, z: 11, R: 12 }, CanvasCommandOnlyMap);
var PathCommandLengthMap = {
  M: 3,
  m: 3,
  L: 3,
  l: 3,
  H: 2,
  h: 2,
  V: 2,
  v: 2,
  C: 7,
  c: 7,
  S: 5,
  s: 5,
  Q: 5,
  q: 5,
  T: 3,
  t: 3,
  A: 8,
  a: 8,
  Z: 1,
  z: 1,
  N: 5,
  D: 9,
  X: 6,
  G: 9,
  F: 5,
  O: 7,
  P: 4,
  U: 6
};
var NeedConvertToCanvasCommandMap = {
  m: 10,
  l: 20,
  H: 3,
  h: 30,
  V: 4,
  v: 40,
  c: 50,
  S: 6,
  s: 60,
  q: 70,
  T: 8,
  t: 80,
  A: 9,
  a: 90
};
var NeedConvertToCurveCommandMap = Object.assign(Object.assign({}, NeedConvertToCanvasCommandMap), CanvasCommandOnlyMap);
var P$4 = PathCommandMap;
var PathNumberCommandMap = {};
for (let key in P$4) {
  PathNumberCommandMap[P$4[key]] = key;
}
var PathNumberCommandLengthMap = {};
for (let key in P$4) {
  PathNumberCommandLengthMap[P$4[key]] = PathCommandLengthMap[key];
}
var RectHelper = {
  drawRoundRect(drawer, x, y, width, height, cornerRadius) {
    const data = MathHelper.fourNumber(cornerRadius, Math.min(width / 2, height / 2));
    const right2 = x + width;
    const bottom2 = y + height;
    data[0] ? drawer.moveTo(x + data[0], y) : drawer.moveTo(x, y);
    data[1] ? drawer.arcTo(right2, y, right2, bottom2, data[1]) : drawer.lineTo(right2, y);
    data[2] ? drawer.arcTo(right2, bottom2, x, bottom2, data[2]) : drawer.lineTo(right2, bottom2);
    data[3] ? drawer.arcTo(x, bottom2, x, y, data[3]) : drawer.lineTo(x, bottom2);
    data[0] ? drawer.arcTo(x, y, right2, y, data[0]) : drawer.lineTo(x, y);
  }
};
var { sin: sin$1, cos: cos$1, atan2: atan2$1, ceil, abs: abs$1, PI, sqrt: sqrt$1, pow } = Math;
var { setPoint: setPoint$1, addPoint: addPoint$1 } = TwoPointBoundsHelper;
var { set, toNumberPoints } = PointHelper;
var { M: M$5, L: L$6, C: C$5, Q: Q$4, Z: Z$5 } = PathCommandMap;
var tempPoint$1 = {};
var BezierHelper = {
  points(data, originPoints, curve, close) {
    let points = toNumberPoints(originPoints);
    data.push(M$5, points[0], points[1]);
    if (curve && points.length > 5) {
      let aX, aY, bX, bY, cX, cY, c1X, c1Y, c2X, c2Y;
      let ba, cb, d, len = points.length;
      const t2 = curve === true ? 0.5 : curve;
      if (close) {
        points = [points[len - 2], points[len - 1], ...points, points[0], points[1], points[2], points[3]];
        len = points.length;
      }
      for (let i = 2; i < len - 2; i += 2) {
        aX = points[i - 2];
        aY = points[i - 1];
        bX = points[i];
        bY = points[i + 1];
        cX = points[i + 2];
        cY = points[i + 3];
        ba = sqrt$1(pow(bX - aX, 2) + pow(bY - aY, 2));
        cb = sqrt$1(pow(cX - bX, 2) + pow(cY - bY, 2));
        d = ba + cb;
        ba = t2 * ba / d;
        cb = t2 * cb / d;
        cX -= aX;
        cY -= aY;
        c1X = bX - ba * cX;
        c1Y = bY - ba * cY;
        if (i === 2) {
          if (!close)
            data.push(Q$4, c1X, c1Y, bX, bY);
        } else {
          data.push(C$5, c2X, c2Y, c1X, c1Y, bX, bY);
        }
        c2X = bX + cb * cX;
        c2Y = bY + cb * cY;
      }
      if (!close)
        data.push(Q$4, c2X, c2Y, points[len - 2], points[len - 1]);
    } else {
      for (let i = 2, len = points.length; i < len; i += 2) {
        data.push(L$6, points[i], points[i + 1]);
      }
    }
    if (close)
      data.push(Z$5);
  },
  rect(data, x, y, width, height) {
    PathHelper.creator.path = data;
    PathHelper.creator.moveTo(x, y).lineTo(x + width, y).lineTo(x + width, y + height).lineTo(x, y + height).lineTo(x, y);
  },
  roundRect(data, x, y, width, height, radius2) {
    PathHelper.creator.path = [];
    RectHelper.drawRoundRect(PathHelper.creator, x, y, width, height, radius2);
    data.push(...PathHelper.convertToCanvasData(PathHelper.creator.path, true));
  },
  arcTo(data, fromX, fromY, x1, y1, toX, toY, radius2, setPointBounds2, setEndPoint2, setStartPoint) {
    const BAx = x1 - fromX;
    const BAy = y1 - fromY;
    const CBx = toX - x1;
    const CBy = toY - y1;
    let startRadian = atan2$1(BAy, BAx);
    let endRadian = atan2$1(CBy, CBx);
    let totalRadian = endRadian - startRadian;
    if (totalRadian < 0)
      totalRadian += PI2;
    if (totalRadian === PI || abs$1(BAx + BAy) < 1e-12 || abs$1(CBx + CBy) < 1e-12) {
      if (data)
        data.push(L$6, x1, y1);
      if (setPointBounds2) {
        setPoint$1(setPointBounds2, fromX, fromY);
        addPoint$1(setPointBounds2, x1, y1);
      }
      if (setStartPoint)
        set(setStartPoint, fromX, fromY);
      if (setEndPoint2)
        set(setEndPoint2, x1, y1);
      return;
    }
    const anticlockwise = BAx * CBy - CBx * BAy < 0;
    const sign = anticlockwise ? -1 : 1;
    const c2 = radius2 / cos$1(totalRadian / 2);
    const centerX = x1 + c2 * cos$1(startRadian + totalRadian / 2 + PI_2 * sign);
    const centerY = y1 + c2 * sin$1(startRadian + totalRadian / 2 + PI_2 * sign);
    startRadian -= PI_2 * sign;
    endRadian -= PI_2 * sign;
    return ellipse$5(data, centerX, centerY, radius2, radius2, 0, startRadian / OneRadian, endRadian / OneRadian, anticlockwise, setPointBounds2, setEndPoint2, setStartPoint);
  },
  arc(data, x, y, radius2, startAngle, endAngle, anticlockwise, setPointBounds2, setEndPoint2, setStartPoint) {
    return ellipse$5(data, x, y, radius2, radius2, 0, startAngle, endAngle, anticlockwise, setPointBounds2, setEndPoint2, setStartPoint);
  },
  ellipse(data, cx, cy, radiusX2, radiusY2, rotation, startAngle, endAngle, anticlockwise, setPointBounds2, setEndPoint2, setStartPoint) {
    const rotationRadian = rotation * OneRadian;
    const rotationSin = sin$1(rotationRadian);
    const rotationCos = cos$1(rotationRadian);
    let startRadian = startAngle * OneRadian;
    let endRadian = endAngle * OneRadian;
    if (startRadian > PI)
      startRadian -= PI2;
    if (endRadian < 0)
      endRadian += PI2;
    let totalRadian = endRadian - startRadian;
    if (totalRadian < 0)
      totalRadian += PI2;
    else if (totalRadian > PI2)
      totalRadian -= PI2;
    if (anticlockwise)
      totalRadian -= PI2;
    const parts = ceil(abs$1(totalRadian / PI_2));
    const partRadian = totalRadian / parts;
    const partRadian4Sin = sin$1(partRadian / 4);
    const control = 8 / 3 * partRadian4Sin * partRadian4Sin / sin$1(partRadian / 2);
    endRadian = startRadian + partRadian;
    let startCos = cos$1(startRadian);
    let startSin = sin$1(startRadian);
    let endCos, endSin;
    let x, y, x1, y1, x2, y2;
    let startX = x = rotationCos * radiusX2 * startCos - rotationSin * radiusY2 * startSin;
    let startY = y = rotationSin * radiusX2 * startCos + rotationCos * radiusY2 * startSin;
    let fromX = cx + x, fromY = cy + y;
    if (data)
      data.push(data.length ? L$6 : M$5, fromX, fromY);
    if (setPointBounds2)
      setPoint$1(setPointBounds2, fromX, fromY);
    if (setStartPoint)
      set(setStartPoint, fromX, fromY);
    for (let i = 0; i < parts; i++) {
      endCos = cos$1(endRadian);
      endSin = sin$1(endRadian);
      x = rotationCos * radiusX2 * endCos - rotationSin * radiusY2 * endSin;
      y = rotationSin * radiusX2 * endCos + rotationCos * radiusY2 * endSin;
      x1 = cx + startX - control * (rotationCos * radiusX2 * startSin + rotationSin * radiusY2 * startCos);
      y1 = cy + startY - control * (rotationSin * radiusX2 * startSin - rotationCos * radiusY2 * startCos);
      x2 = cx + x + control * (rotationCos * radiusX2 * endSin + rotationSin * radiusY2 * endCos);
      y2 = cy + y + control * (rotationSin * radiusX2 * endSin - rotationCos * radiusY2 * endCos);
      if (data)
        data.push(C$5, x1, y1, x2, y2, cx + x, cy + y);
      if (setPointBounds2)
        toTwoPointBounds$1(cx + startX, cy + startY, x1, y1, x2, y2, cx + x, cy + y, setPointBounds2, true);
      startX = x;
      startY = y;
      startCos = endCos;
      startSin = endSin;
      startRadian = endRadian;
      endRadian += partRadian;
    }
    if (setEndPoint2)
      set(setEndPoint2, cx + x, cy + y);
  },
  quadraticCurveTo(data, fromX, fromY, x1, y1, toX, toY) {
    data.push(C$5, (fromX + 2 * x1) / 3, (fromY + 2 * y1) / 3, (toX + 2 * x1) / 3, (toY + 2 * y1) / 3, toX, toY);
  },
  toTwoPointBoundsByQuadraticCurve(fromX, fromY, x1, y1, toX, toY, pointBounds, addMode) {
    toTwoPointBounds$1(fromX, fromY, (fromX + 2 * x1) / 3, (fromY + 2 * y1) / 3, (toX + 2 * x1) / 3, (toY + 2 * y1) / 3, toX, toY, pointBounds, addMode);
  },
  toTwoPointBounds(fromX, fromY, x1, y1, x2, y2, toX, toY, pointBounds, addMode) {
    const tList = [];
    let a2, b, c2, t2, t1, t22, v2, sqrtV;
    let f = fromX, z1 = x1, z2 = x2, o = toX;
    for (let i = 0; i < 2; ++i) {
      if (i == 1) {
        f = fromY, z1 = y1, z2 = y2, o = toY;
      }
      a2 = -3 * f + 9 * z1 - 9 * z2 + 3 * o;
      b = 6 * f - 12 * z1 + 6 * z2;
      c2 = 3 * z1 - 3 * f;
      if (Math.abs(a2) < 1e-12) {
        if (Math.abs(b) < 1e-12)
          continue;
        t2 = -c2 / b;
        if (0 < t2 && t2 < 1)
          tList.push(t2);
        continue;
      }
      v2 = b * b - 4 * c2 * a2;
      sqrtV = Math.sqrt(v2);
      if (v2 < 0)
        continue;
      t1 = (-b + sqrtV) / (2 * a2);
      if (0 < t1 && t1 < 1)
        tList.push(t1);
      t22 = (-b - sqrtV) / (2 * a2);
      if (0 < t22 && t22 < 1)
        tList.push(t22);
    }
    addMode ? addPoint$1(pointBounds, fromX, fromY) : setPoint$1(pointBounds, fromX, fromY);
    addPoint$1(pointBounds, toX, toY);
    for (let i = 0, len = tList.length; i < len; i++) {
      getPointAndSet(tList[i], fromX, fromY, x1, y1, x2, y2, toX, toY, tempPoint$1);
      addPoint$1(pointBounds, tempPoint$1.x, tempPoint$1.y);
    }
  },
  getPointAndSet(t2, fromX, fromY, x1, y1, x2, y2, toX, toY, setPoint2) {
    const o = 1 - t2, a2 = o * o * o, b = 3 * o * o * t2, c2 = 3 * o * t2 * t2, d = t2 * t2 * t2;
    setPoint2.x = a2 * fromX + b * x1 + c2 * x2 + d * toX;
    setPoint2.y = a2 * fromY + b * y1 + c2 * y2 + d * toY;
  },
  getPoint(t2, fromX, fromY, x1, y1, x2, y2, toX, toY) {
    const point2 = {};
    getPointAndSet(t2, fromX, fromY, x1, y1, x2, y2, toX, toY, point2);
    return point2;
  }
};
var { getPointAndSet, toTwoPointBounds: toTwoPointBounds$1, ellipse: ellipse$5 } = BezierHelper;
var { sin, cos, sqrt, atan2 } = Math;
var { ellipse: ellipse$4 } = BezierHelper;
var EllipseHelper = {
  ellipticalArc(data, fromX, fromY, radiusX2, radiusY2, rotation, largeFlag, sweepFlag, toX, toY, curveMode) {
    const halfX = (toX - fromX) / 2;
    const halfY = (toY - fromY) / 2;
    const rotationRadian = rotation * OneRadian;
    const rotationSin = sin(rotationRadian);
    const rotationCos = cos(rotationRadian);
    const px = -rotationCos * halfX - rotationSin * halfY;
    const py = -rotationCos * halfY + rotationSin * halfX;
    const rxSquare = radiusX2 * radiusX2;
    const rySquare = radiusY2 * radiusY2;
    const pySquare = py * py;
    const pxSquare = px * px;
    const a2 = rxSquare * rySquare - rxSquare * pySquare - rySquare * pxSquare;
    let s2 = 0;
    if (a2 < 0) {
      const t2 = sqrt(1 - a2 / (rxSquare * rySquare));
      radiusX2 *= t2;
      radiusY2 *= t2;
    } else {
      s2 = (largeFlag === sweepFlag ? -1 : 1) * sqrt(a2 / (rxSquare * pySquare + rySquare * pxSquare));
    }
    const cx = s2 * radiusX2 * py / radiusY2;
    const cy = -s2 * radiusY2 * px / radiusX2;
    const startRadian = atan2((py - cy) / radiusY2, (px - cx) / radiusX2);
    const endRadian = atan2((-py - cy) / radiusY2, (-px - cx) / radiusX2);
    let totalRadian = endRadian - startRadian;
    if (sweepFlag === 0 && totalRadian > 0) {
      totalRadian -= PI2;
    } else if (sweepFlag === 1 && totalRadian < 0) {
      totalRadian += PI2;
    }
    const centerX = fromX + halfX + rotationCos * cx - rotationSin * cy;
    const centerY = fromY + halfY + rotationSin * cx + rotationCos * cy;
    const anticlockwise = totalRadian < 0 ? 1 : 0;
    if (curveMode || Platform.ellipseToCurve) {
      ellipse$4(data, centerX, centerY, radiusX2, radiusY2, rotation, startRadian / OneRadian, endRadian / OneRadian, anticlockwise);
    } else {
      if (radiusX2 === radiusY2 && !rotation) {
        data.push(PathCommandMap.O, centerX, centerY, radiusX2, startRadian / OneRadian, endRadian / OneRadian, anticlockwise);
      } else {
        data.push(PathCommandMap.G, centerX, centerY, radiusX2, radiusY2, rotation, startRadian / OneRadian, endRadian / OneRadian, anticlockwise);
      }
    }
  }
};
var { M: M$4, m, L: L$5, l, H, h, V, v, C: C$4, c, S, s, Q: Q$3, q, T, t, A, a, Z: Z$4, z, N: N$3, D: D$3, X: X$3, G: G$3, F: F$4, O: O$3, P: P$3, U: U$3 } = PathCommandMap;
var { rect: rect$1, roundRect: roundRect$2, arcTo: arcTo$3, arc: arc$3, ellipse: ellipse$3, quadraticCurveTo: quadraticCurveTo$1 } = BezierHelper;
var { ellipticalArc } = EllipseHelper;
var debug$5 = Debug.get("PathConvert");
var setEndPoint$1 = {};
var PathConvert = {
  current: { dot: 0 },
  stringify(data, floatLength) {
    let i = 0, len = data.length, count, str = "", command, lastCommand;
    while (i < len) {
      command = data[i];
      count = PathNumberCommandLengthMap[command];
      if (command === lastCommand) {
        str += " ";
      } else {
        str += PathNumberCommandMap[command];
      }
      for (let j = 1; j < count; j++) {
        str += MathHelper.float(data[i + j], floatLength);
        j === count - 1 || (str += " ");
      }
      lastCommand = command;
      i += count;
    }
    return str;
  },
  parse(pathString, curveMode) {
    let needConvert, char, lastChar, num = "";
    const data = [];
    const convertCommand = curveMode ? NeedConvertToCurveCommandMap : NeedConvertToCanvasCommandMap;
    for (let i = 0, len = pathString.length; i < len; i++) {
      char = pathString[i];
      if (StringNumberMap[char]) {
        if (char === ".") {
          if (current.dot) {
            pushData(data, num);
            num = "";
          }
          current.dot++;
        }
        if (num === "0" && char !== ".") {
          pushData(data, num);
          num = "";
        }
        num += char;
      } else if (PathCommandMap[char]) {
        if (num) {
          pushData(data, num);
          num = "";
        }
        current.name = PathCommandMap[char];
        current.length = PathCommandLengthMap[char];
        current.index = 0;
        pushData(data, current.name);
        if (!needConvert && convertCommand[char])
          needConvert = true;
      } else {
        if (char === "-" || char === "+") {
          if (lastChar === "e" || lastChar === "E") {
            num += char;
          } else {
            if (num)
              pushData(data, num);
            num = char;
          }
        } else {
          if (num) {
            pushData(data, num);
            num = "";
          }
        }
      }
      lastChar = char;
    }
    if (num)
      pushData(data, num);
    return needConvert ? PathConvert.toCanvasData(data, curveMode) : data;
  },
  toCanvasData(old, curveMode) {
    let x = 0, y = 0, x1 = 0, y1 = 0, i = 0, len = old.length, controlX, controlY, command, lastCommand, smooth;
    const data = [];
    while (i < len) {
      command = old[i];
      switch (command) {
        case m:
          old[i + 1] += x;
          old[i + 2] += y;
        case M$4:
          x = old[i + 1];
          y = old[i + 2];
          data.push(M$4, x, y);
          i += 3;
          break;
        case h:
          old[i + 1] += x;
        case H:
          x = old[i + 1];
          data.push(L$5, x, y);
          i += 2;
          break;
        case v:
          old[i + 1] += y;
        case V:
          y = old[i + 1];
          data.push(L$5, x, y);
          i += 2;
          break;
        case l:
          old[i + 1] += x;
          old[i + 2] += y;
        case L$5:
          x = old[i + 1];
          y = old[i + 2];
          data.push(L$5, x, y);
          i += 3;
          break;
        case s:
          old[i + 1] += x;
          old[i + 2] += y;
          old[i + 3] += x;
          old[i + 4] += y;
          command = S;
        case S:
          smooth = lastCommand === C$4 || lastCommand === S;
          x1 = smooth ? x * 2 - controlX : old[i + 1];
          y1 = smooth ? y * 2 - controlY : old[i + 2];
          controlX = old[i + 1];
          controlY = old[i + 2];
          x = old[i + 3];
          y = old[i + 4];
          data.push(C$4, x1, y1, controlX, controlY, x, y);
          i += 5;
          break;
        case c:
          old[i + 1] += x;
          old[i + 2] += y;
          old[i + 3] += x;
          old[i + 4] += y;
          old[i + 5] += x;
          old[i + 6] += y;
          command = C$4;
        case C$4:
          controlX = old[i + 3];
          controlY = old[i + 4];
          x = old[i + 5];
          y = old[i + 6];
          data.push(C$4, old[i + 1], old[i + 2], controlX, controlY, x, y);
          i += 7;
          break;
        case t:
          old[i + 1] += x;
          old[i + 2] += y;
          command = T;
        case T:
          smooth = lastCommand === Q$3 || lastCommand === T;
          controlX = smooth ? x * 2 - controlX : old[i + 1];
          controlY = smooth ? y * 2 - controlY : old[i + 2];
          curveMode ? quadraticCurveTo$1(data, x, y, controlX, controlY, old[i + 1], old[i + 2]) : data.push(Q$3, controlX, controlY, old[i + 1], old[i + 2]);
          x = old[i + 1];
          y = old[i + 2];
          i += 3;
          break;
        case q:
          old[i + 1] += x;
          old[i + 2] += y;
          old[i + 3] += x;
          old[i + 4] += y;
          command = Q$3;
        case Q$3:
          controlX = old[i + 1];
          controlY = old[i + 2];
          curveMode ? quadraticCurveTo$1(data, x, y, controlX, controlY, old[i + 3], old[i + 4]) : data.push(Q$3, controlX, controlY, old[i + 3], old[i + 4]);
          x = old[i + 3];
          y = old[i + 4];
          i += 5;
          break;
        case a:
          old[i + 6] += x;
          old[i + 7] += y;
        case A:
          ellipticalArc(data, x, y, old[i + 1], old[i + 2], old[i + 3], old[i + 4], old[i + 5], old[i + 6], old[i + 7], curveMode);
          x = old[i + 6];
          y = old[i + 7];
          i += 8;
          break;
        case z:
        case Z$4:
          data.push(Z$4);
          i++;
          break;
        case N$3:
          x = old[i + 1];
          y = old[i + 2];
          curveMode ? rect$1(data, x, y, old[i + 3], old[i + 4]) : copyData(data, old, i, 5);
          i += 5;
          break;
        case D$3:
          x = old[i + 1];
          y = old[i + 2];
          curveMode ? roundRect$2(data, x, y, old[i + 3], old[i + 4], [old[i + 5], old[i + 6], old[i + 7], old[i + 8]]) : copyData(data, old, i, 9);
          i += 9;
          break;
        case X$3:
          x = old[i + 1];
          y = old[i + 2];
          curveMode ? roundRect$2(data, x, y, old[i + 3], old[i + 4], old[i + 5]) : copyData(data, old, i, 6);
          i += 6;
          break;
        case G$3:
          ellipse$3(curveMode ? data : copyData(data, old, i, 9), old[i + 1], old[i + 2], old[i + 3], old[i + 4], old[i + 5], old[i + 6], old[i + 7], old[i + 8], null, setEndPoint$1);
          x = setEndPoint$1.x;
          y = setEndPoint$1.y;
          i += 9;
          break;
        case F$4:
          curveMode ? ellipse$3(data, old[i + 1], old[i + 2], old[i + 3], old[i + 4], 0, 0, 360, false) : copyData(data, old, i, 5);
          x = old[i + 1] + old[i + 3];
          y = old[i + 2];
          i += 5;
          break;
        case O$3:
          arc$3(curveMode ? data : copyData(data, old, i, 7), old[i + 1], old[i + 2], old[i + 3], old[i + 4], old[i + 5], old[i + 6], null, setEndPoint$1);
          x = setEndPoint$1.x;
          y = setEndPoint$1.y;
          i += 7;
          break;
        case P$3:
          curveMode ? arc$3(data, old[i + 1], old[i + 2], old[i + 3], 0, 360, false) : copyData(data, old, i, 4);
          x = old[i + 1] + old[i + 3];
          y = old[i + 2];
          i += 4;
          break;
        case U$3:
          arcTo$3(curveMode ? data : copyData(data, old, i, 6), x, y, old[i + 1], old[i + 2], old[i + 3], old[i + 4], old[i + 5], null, setEndPoint$1);
          x = setEndPoint$1.x;
          y = setEndPoint$1.y;
          i += 6;
          break;
        default:
          debug$5.error(`command: ${command} [index:${i}]`, old);
          return data;
      }
      lastCommand = command;
    }
    return data;
  },
  objectToCanvasData(list2) {
    const data = [];
    list2.forEach((item) => {
      switch (item.name) {
        case "M":
          data.push(M$4, item.x, item.y);
          break;
        case "L":
          data.push(L$5, item.x, item.y);
          break;
        case "C":
          data.push(C$4, item.x1, item.y1, item.x2, item.y2, item.x, item.y);
          break;
        case "Q":
          data.push(Q$3, item.x1, item.y1, item.x, item.y);
          break;
        case "Z":
          data.push(Z$4);
      }
    });
    return data;
  },
  copyData(data, old, index, count) {
    for (let i = index, end = index + count; i < end; i++) {
      data.push(old[i]);
    }
  },
  pushData(data, strNum) {
    if (current.index === current.length) {
      current.index = 1;
      data.push(current.name);
    }
    data.push(Number(strNum));
    current.index++;
    current.dot = 0;
  }
};
var { current, pushData, copyData } = PathConvert;
var { M: M$3, L: L$4, C: C$3, Q: Q$2, Z: Z$3, N: N$2, D: D$2, X: X$2, G: G$2, F: F$3, O: O$2, P: P$2, U: U$2 } = PathCommandMap;
var { getMinDistanceFrom, getRadianFrom } = PointHelper;
var { tan, min, abs } = Math;
var startPoint = {};
var PathCommandDataHelper = {
  beginPath(data) {
    data.length = 0;
  },
  moveTo(data, x, y) {
    data.push(M$3, x, y);
  },
  lineTo(data, x, y) {
    data.push(L$4, x, y);
  },
  bezierCurveTo(data, x1, y1, x2, y2, x, y) {
    data.push(C$3, x1, y1, x2, y2, x, y);
  },
  quadraticCurveTo(data, x1, y1, x, y) {
    data.push(Q$2, x1, y1, x, y);
  },
  closePath(data) {
    data.push(Z$3);
  },
  rect(data, x, y, width, height) {
    data.push(N$2, x, y, width, height);
  },
  roundRect(data, x, y, width, height, cornerRadius) {
    if (typeof cornerRadius === "number") {
      data.push(X$2, x, y, width, height, cornerRadius);
    } else {
      const fourCorners = MathHelper.fourNumber(cornerRadius);
      if (fourCorners) {
        data.push(D$2, x, y, width, height, ...fourCorners);
      } else {
        data.push(N$2, x, y, width, height);
      }
    }
  },
  ellipse(data, x, y, radiusX2, radiusY2, rotation, startAngle, endAngle, anticlockwise) {
    if (rotation === void 0) {
      data.push(F$3, x, y, radiusX2, radiusY2);
    } else {
      if (startAngle === void 0)
        startAngle = 0;
      if (endAngle === void 0)
        endAngle = 360;
      data.push(G$2, x, y, radiusX2, radiusY2, rotation, startAngle, endAngle, anticlockwise ? 1 : 0);
    }
  },
  arc(data, x, y, radius2, startAngle, endAngle, anticlockwise) {
    if (startAngle === void 0) {
      data.push(P$2, x, y, radius2);
    } else {
      if (endAngle === void 0)
        endAngle = 360;
      data.push(O$2, x, y, radius2, startAngle, endAngle, anticlockwise ? 1 : 0);
    }
  },
  arcTo(data, x1, y1, x2, y2, radius2, lastX, lastY) {
    if (lastX !== void 0) {
      const maxRadius = tan(getRadianFrom(lastX, lastY, x1, y1, x2, y2) / 2) * (getMinDistanceFrom(lastX, lastY, x1, y1, x2, y2) / 2);
      data.push(U$2, x1, y1, x2, y2, min(radius2, abs(maxRadius)));
    } else {
      data.push(U$2, x1, y1, x2, y2, radius2);
    }
  },
  drawEllipse(data, x, y, radiusX2, radiusY2, rotation, startAngle, endAngle, anticlockwise) {
    BezierHelper.ellipse(null, x, y, radiusX2, radiusY2, rotation === void 0 ? 0 : rotation, startAngle === void 0 ? 0 : startAngle, endAngle === void 0 ? 360 : endAngle, anticlockwise, null, null, startPoint);
    data.push(M$3, startPoint.x, startPoint.y);
    ellipse$2(data, x, y, radiusX2, radiusY2, rotation, startAngle, endAngle, anticlockwise);
  },
  drawArc(data, x, y, radius2, startAngle, endAngle, anticlockwise) {
    BezierHelper.arc(null, x, y, radius2, startAngle === void 0 ? 0 : startAngle, endAngle === void 0 ? 360 : endAngle, anticlockwise, null, null, startPoint);
    data.push(M$3, startPoint.x, startPoint.y);
    arc$2(data, x, y, radius2, startAngle, endAngle, anticlockwise);
  },
  drawPoints(data, points, curve, close) {
    BezierHelper.points(data, points, curve, close);
  }
};
var { ellipse: ellipse$2, arc: arc$2 } = PathCommandDataHelper;
var { moveTo, lineTo, quadraticCurveTo, bezierCurveTo, closePath, beginPath, rect, roundRect: roundRect$1, ellipse: ellipse$1, arc: arc$1, arcTo: arcTo$2, drawEllipse, drawArc, drawPoints } = PathCommandDataHelper;
var PathCreator = class {
  set path(value) {
    this.__path = value;
  }
  get path() {
    return this.__path;
  }
  constructor(path) {
    this.set(path);
  }
  set(path) {
    if (path) {
      this.__path = typeof path === "string" ? PathHelper.parse(path) : path;
    } else {
      this.__path = [];
    }
    return this;
  }
  beginPath() {
    beginPath(this.__path);
    this.paint();
    return this;
  }
  moveTo(x, y) {
    moveTo(this.__path, x, y);
    this.paint();
    return this;
  }
  lineTo(x, y) {
    lineTo(this.__path, x, y);
    this.paint();
    return this;
  }
  bezierCurveTo(x1, y1, x2, y2, x, y) {
    bezierCurveTo(this.__path, x1, y1, x2, y2, x, y);
    this.paint();
    return this;
  }
  quadraticCurveTo(x1, y1, x, y) {
    quadraticCurveTo(this.__path, x1, y1, x, y);
    this.paint();
    return this;
  }
  closePath() {
    closePath(this.__path);
    this.paint();
    return this;
  }
  rect(x, y, width, height) {
    rect(this.__path, x, y, width, height);
    this.paint();
    return this;
  }
  roundRect(x, y, width, height, cornerRadius) {
    roundRect$1(this.__path, x, y, width, height, cornerRadius);
    this.paint();
    return this;
  }
  ellipse(x, y, radiusX2, radiusY2, rotation, startAngle, endAngle, anticlockwise) {
    ellipse$1(this.__path, x, y, radiusX2, radiusY2, rotation, startAngle, endAngle, anticlockwise);
    this.paint();
    return this;
  }
  arc(x, y, radius2, startAngle, endAngle, anticlockwise) {
    arc$1(this.__path, x, y, radius2, startAngle, endAngle, anticlockwise);
    this.paint();
    return this;
  }
  arcTo(x1, y1, x2, y2, radius2) {
    arcTo$2(this.__path, x1, y1, x2, y2, radius2);
    this.paint();
    return this;
  }
  drawEllipse(x, y, radiusX2, radiusY2, rotation, startAngle, endAngle, anticlockwise) {
    drawEllipse(this.__path, x, y, radiusX2, radiusY2, rotation, startAngle, endAngle, anticlockwise);
    this.paint();
    return this;
  }
  drawArc(x, y, radius2, startAngle, endAngle, anticlockwise) {
    drawArc(this.__path, x, y, radius2, startAngle, endAngle, anticlockwise);
    this.paint();
    return this;
  }
  drawPoints(points, curve, close) {
    drawPoints(this.__path, points, curve, close);
    this.paint();
    return this;
  }
  clearPath() {
    return this.beginPath();
  }
  paint() {
  }
};
var { M: M$2, L: L$3, C: C$2, Q: Q$1, Z: Z$2, N: N$1, D: D$1, X: X$1, G: G$1, F: F$2, O: O$1, P: P$1, U: U$1 } = PathCommandMap;
var debug$4 = Debug.get("PathDrawer");
var PathDrawer = {
  drawPathByData(drawer, data) {
    if (!data)
      return;
    let command;
    let i = 0, len = data.length;
    while (i < len) {
      command = data[i];
      switch (command) {
        case M$2:
          drawer.moveTo(data[i + 1], data[i + 2]);
          i += 3;
          break;
        case L$3:
          drawer.lineTo(data[i + 1], data[i + 2]);
          i += 3;
          break;
        case C$2:
          drawer.bezierCurveTo(data[i + 1], data[i + 2], data[i + 3], data[i + 4], data[i + 5], data[i + 6]);
          i += 7;
          break;
        case Q$1:
          drawer.quadraticCurveTo(data[i + 1], data[i + 2], data[i + 3], data[i + 4]);
          i += 5;
          break;
        case Z$2:
          drawer.closePath();
          i += 1;
          break;
        case N$1:
          drawer.rect(data[i + 1], data[i + 2], data[i + 3], data[i + 4]);
          i += 5;
          break;
        case D$1:
          drawer.roundRect(data[i + 1], data[i + 2], data[i + 3], data[i + 4], [data[i + 5], data[i + 6], data[i + 7], data[i + 8]]);
          i += 9;
          break;
        case X$1:
          drawer.roundRect(data[i + 1], data[i + 2], data[i + 3], data[i + 4], data[i + 5]);
          i += 6;
          break;
        case G$1:
          drawer.ellipse(data[i + 1], data[i + 2], data[i + 3], data[i + 4], data[i + 5] * OneRadian, data[i + 6] * OneRadian, data[i + 7] * OneRadian, data[i + 8]);
          i += 9;
          break;
        case F$2:
          drawer.ellipse(data[i + 1], data[i + 2], data[i + 3], data[i + 4], 0, 0, PI2, false);
          i += 5;
          break;
        case O$1:
          drawer.arc(data[i + 1], data[i + 2], data[i + 3], data[i + 4] * OneRadian, data[i + 5] * OneRadian, data[i + 6]);
          i += 7;
          break;
        case P$1:
          drawer.arc(data[i + 1], data[i + 2], data[i + 3], 0, PI2, false);
          i += 4;
          break;
        case U$1:
          drawer.arcTo(data[i + 1], data[i + 2], data[i + 3], data[i + 4], data[i + 5]);
          i += 6;
          break;
        default:
          debug$4.error(`command: ${command} [index:${i}]`, data);
          return;
      }
    }
  }
};
var { M: M$1, L: L$2, C: C$1, Q, Z: Z$1, N, D, X, G, F: F$1, O, P, U } = PathCommandMap;
var { toTwoPointBounds, toTwoPointBoundsByQuadraticCurve, arcTo: arcTo$1, arc, ellipse } = BezierHelper;
var { addPointBounds, copy: copy$4, addPoint, setPoint, addBounds, toBounds: toBounds$1 } = TwoPointBoundsHelper;
var debug$3 = Debug.get("PathBounds");
var radius;
var radiusX;
var radiusY;
var tempPointBounds = {};
var setPointBounds = {};
var setEndPoint = {};
var PathBounds = {
  toBounds(data, setBounds) {
    PathBounds.toTwoPointBounds(data, setPointBounds);
    toBounds$1(setPointBounds, setBounds);
  },
  toTwoPointBounds(data, setPointBounds2) {
    if (!data || !data.length)
      return setPoint(setPointBounds2, 0, 0);
    let i = 0, x = 0, y = 0, x1, y1, toX, toY, command;
    const len = data.length;
    while (i < len) {
      command = data[i];
      if (i === 0) {
        if (command === Z$1 || command === C$1 || command === Q) {
          setPoint(setPointBounds2, x, y);
        } else {
          setPoint(setPointBounds2, data[i + 1], data[i + 2]);
        }
      }
      switch (command) {
        case M$1:
        case L$2:
          x = data[i + 1];
          y = data[i + 2];
          addPoint(setPointBounds2, x, y);
          i += 3;
          break;
        case C$1:
          toX = data[i + 5];
          toY = data[i + 6];
          toTwoPointBounds(x, y, data[i + 1], data[i + 2], data[i + 3], data[i + 4], toX, toY, tempPointBounds);
          addPointBounds(setPointBounds2, tempPointBounds);
          x = toX;
          y = toY;
          i += 7;
          break;
        case Q:
          x1 = data[i + 1];
          y1 = data[i + 2];
          toX = data[i + 3];
          toY = data[i + 4];
          toTwoPointBoundsByQuadraticCurve(x, y, x1, y1, toX, toY, tempPointBounds);
          addPointBounds(setPointBounds2, tempPointBounds);
          x = toX;
          y = toY;
          i += 5;
          break;
        case Z$1:
          i += 1;
          break;
        case N:
          x = data[i + 1];
          y = data[i + 2];
          addBounds(setPointBounds2, x, y, data[i + 3], data[i + 4]);
          i += 5;
          break;
        case D:
        case X:
          x = data[i + 1];
          y = data[i + 2];
          addBounds(setPointBounds2, x, y, data[i + 3], data[i + 4]);
          i += command === D ? 9 : 6;
          break;
        case G:
          ellipse(null, data[i + 1], data[i + 2], data[i + 3], data[i + 4], data[i + 5], data[i + 6], data[i + 7], data[i + 8], tempPointBounds, setEndPoint);
          i === 0 ? copy$4(setPointBounds2, tempPointBounds) : addPointBounds(setPointBounds2, tempPointBounds);
          x = setEndPoint.x;
          y = setEndPoint.y;
          i += 9;
          break;
        case F$1:
          x = data[i + 1];
          y = data[i + 2];
          radiusX = data[i + 3];
          radiusY = data[i + 4];
          addBounds(setPointBounds2, x - radiusX, y - radiusY, radiusX * 2, radiusY * 2);
          x += radiusX;
          i += 5;
          break;
        case O:
          arc(null, data[i + 1], data[i + 2], data[i + 3], data[i + 4], data[i + 5], data[i + 6], tempPointBounds, setEndPoint);
          i === 0 ? copy$4(setPointBounds2, tempPointBounds) : addPointBounds(setPointBounds2, tempPointBounds);
          x = setEndPoint.x;
          y = setEndPoint.y;
          i += 7;
          break;
        case P:
          x = data[i + 1];
          y = data[i + 2];
          radius = data[i + 3];
          addBounds(setPointBounds2, x - radius, y - radius, radius * 2, radius * 2);
          x += radius;
          i += 4;
          break;
        case U:
          arcTo$1(null, x, y, data[i + 1], data[i + 2], data[i + 3], data[i + 4], data[i + 5], tempPointBounds, setEndPoint);
          i === 0 ? copy$4(setPointBounds2, tempPointBounds) : addPointBounds(setPointBounds2, tempPointBounds);
          x = setEndPoint.x;
          y = setEndPoint.y;
          i += 6;
          break;
        default:
          debug$3.error(`command: ${command} [index:${i}]`, data);
          return;
      }
    }
  }
};
var { M, L: L$1, C, Z } = PathCommandMap;
var { getCenterX, getCenterY } = PointHelper;
var { arcTo } = PathCommandDataHelper;
var PathCorner = {
  smooth(data, cornerRadius, _cornerSmoothing) {
    let command;
    let i = 0, x = 0, y = 0, startX = 0, startY = 0, secondX = 0, secondY = 0, lastX = 0, lastY = 0;
    const len = data.length;
    const smooth = [];
    while (i < len) {
      command = data[i];
      switch (command) {
        case M:
          startX = lastX = data[i + 1];
          startY = lastY = data[i + 2];
          i += 3;
          if (data[i] === L$1) {
            secondX = data[i + 1];
            secondY = data[i + 2];
            smooth.push(M, getCenterX(startX, secondX), getCenterY(startY, secondY));
          } else {
            smooth.push(M, startX, startY);
          }
          break;
        case L$1:
          x = data[i + 1];
          y = data[i + 2];
          i += 3;
          switch (data[i]) {
            case L$1:
              arcTo(smooth, x, y, data[i + 1], data[i + 2], cornerRadius, lastX, lastY);
              break;
            case Z:
              arcTo(smooth, x, y, startX, startY, cornerRadius, lastX, lastY);
              break;
            default:
              smooth.push(L$1, x, y);
          }
          lastX = x;
          lastY = y;
          break;
        case C:
          smooth.push(C, data[i + 1], data[i + 2], data[i + 3], data[i + 4], data[i + 5], data[i + 6]);
          i += 7;
          break;
        case Z:
          arcTo(smooth, startX, startY, secondX, secondY, cornerRadius, lastX, lastY);
          smooth.push(Z);
          i += 1;
          break;
      }
    }
    if (command !== Z) {
      smooth[1] = startX;
      smooth[2] = startY;
    }
    return smooth;
  }
};
PathHelper.creator = new PathCreator();
PathHelper.parse = PathConvert.parse;
PathHelper.convertToCanvasData = PathConvert.toCanvasData;
var pen = new PathCreator();
var { drawRoundRect } = RectHelper;
function roundRect(drawer) {
  if (drawer && !drawer.roundRect) {
    drawer.roundRect = function(x, y, width, height, cornerRadius) {
      drawRoundRect(this, x, y, width, height, cornerRadius);
    };
  }
}
function canvasPatch(drawer) {
  roundRect(drawer);
}
var FileHelper = {
  opacityTypes: ["png", "webp", "svg"],
  upperCaseTypeMap: {},
  mineType(type) {
    if (!type || type.startsWith("image"))
      return type;
    if (type === "jpg")
      type = "jpeg";
    return "image/" + type;
  },
  fileType(filename) {
    const l2 = filename.split(".");
    return l2[l2.length - 1];
  },
  isOpaqueImage(filename) {
    const type = F.fileType(filename);
    return ["jpg", "jpeg"].some((item) => item === type);
  },
  getExportOptions(options) {
    switch (typeof options) {
      case "object":
        return options;
      case "number":
        return { quality: options };
      case "boolean":
        return { blob: options };
      default:
        return {};
    }
  }
};
var F = FileHelper;
F.opacityTypes.forEach((type) => F.upperCaseTypeMap[type] = type.toUpperCase());
var debug$2 = Debug.get("TaskProcessor");
var TaskItem = class {
  constructor(task) {
    this.parallel = true;
    this.time = 1;
    this.id = IncrementId.create(IncrementId.TASK);
    this.task = task;
  }
  run() {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        if (this.task && !this.isComplete && this.parent.running)
          yield this.task();
      } catch (error) {
        debug$2.error(error);
      }
    });
  }
  complete() {
    this.isComplete = true;
    this.parent = null;
    this.task = null;
  }
  cancel() {
    this.isCancel = true;
    this.complete();
  }
};
var TaskProcessor = class {
  get total() {
    return this.list.length + this.delayNumber;
  }
  get finishedIndex() {
    return this.isComplete ? 0 : this.index + this.parallelSuccessNumber;
  }
  get remain() {
    return this.isComplete ? this.total : this.total - this.finishedIndex;
  }
  get percent() {
    const { total } = this;
    let totalTime = 0, runTime = 0;
    for (let i = 0; i < total; i++) {
      if (i <= this.finishedIndex) {
        runTime += this.list[i].time;
        if (i === this.finishedIndex)
          totalTime = runTime;
      } else {
        totalTime += this.list[i].time;
      }
    }
    return this.isComplete ? 1 : runTime / totalTime;
  }
  constructor(config) {
    this.config = { parallel: 6 };
    this.list = [];
    this.running = false;
    this.isComplete = true;
    this.index = 0;
    this.delayNumber = 0;
    if (config)
      DataHelper.assign(this.config, config);
    this.empty();
  }
  add(taskCallback, options) {
    let start, parallel, time, delay;
    const task = new TaskItem(taskCallback);
    task.parent = this;
    if (typeof options === "number") {
      delay = options;
    } else if (options) {
      parallel = options.parallel;
      start = options.start;
      time = options.time;
      delay = options.delay;
    }
    if (time)
      task.time = time;
    if (parallel === false)
      task.parallel = false;
    if (delay === void 0) {
      this.push(task, start);
    } else {
      this.delayNumber++;
      setTimeout(() => {
        if (this.delayNumber) {
          this.delayNumber--;
          this.push(task, start);
        }
      }, delay);
    }
    this.isComplete = false;
    return task;
  }
  push(task, start) {
    this.list.push(task);
    if (start !== false && !this.timer) {
      this.timer = setTimeout(() => this.start());
    }
  }
  empty() {
    this.index = 0;
    this.parallelSuccessNumber = 0;
    this.list = [];
    this.parallelList = [];
    this.delayNumber = 0;
  }
  start() {
    if (!this.running) {
      this.running = true;
      this.isComplete = false;
      this.run();
    }
  }
  pause() {
    clearTimeout(this.timer);
    this.timer = null;
    this.running = false;
  }
  resume() {
    this.start();
  }
  skip() {
    this.index++;
    this.resume();
  }
  stop() {
    this.isComplete = true;
    this.list.forEach((task) => {
      if (!task.isComplete)
        task.cancel();
    });
    this.pause();
    this.empty();
  }
  run() {
    if (!this.running)
      return;
    this.setParallelList();
    if (this.parallelList.length > 1) {
      this.runParallelTasks();
    } else {
      this.remain ? this.runTask() : this.onComplete();
    }
  }
  runTask() {
    const task = this.list[this.index];
    if (!task) {
      this.nextTask();
      return;
    }
    task.run().then(() => {
      this.onTask(task);
      this.index++;
      this.nextTask();
    }).catch((error) => {
      this.onError(error);
    });
  }
  runParallelTasks() {
    this.parallelList.forEach((task) => this.runParallelTask(task));
  }
  runParallelTask(task) {
    task.run().then(() => {
      this.onTask(task);
      this.fillParallelTask();
    }).catch((error) => {
      this.onParallelError(error);
    });
  }
  nextTask() {
    if (this.total === this.finishedIndex) {
      this.onComplete();
    } else {
      this.timer = setTimeout(() => this.run());
    }
  }
  setParallelList() {
    let task;
    this.parallelList = [];
    this.parallelSuccessNumber = 0;
    let end = this.index + this.config.parallel;
    if (end > this.list.length)
      end = this.list.length;
    for (let i = this.index; i < end; i++) {
      task = this.list[i];
      if (task.parallel) {
        this.parallelList.push(task);
      } else {
        break;
      }
    }
  }
  fillParallelTask() {
    let task;
    const parallelList = this.parallelList;
    this.parallelSuccessNumber++;
    parallelList.pop();
    const parallelWaitNumber = parallelList.length;
    const nextIndex = this.finishedIndex + parallelWaitNumber;
    if (parallelList.length) {
      if (!this.running)
        return;
      if (nextIndex < this.total) {
        task = this.list[nextIndex];
        if (task && task.parallel) {
          parallelList.push(task);
          this.runParallelTask(task);
        }
      }
    } else {
      this.index += this.parallelSuccessNumber;
      this.parallelSuccessNumber = 0;
      this.nextTask();
    }
  }
  onComplete() {
    this.stop();
    if (this.config.onComplete)
      this.config.onComplete();
  }
  onTask(task) {
    task.complete();
    if (this.config.onTask)
      this.config.onTask();
  }
  onParallelError(error) {
    this.parallelList.forEach((task) => {
      task.parallel = false;
    });
    this.parallelList.length = 0;
    this.parallelSuccessNumber = 0;
    this.onError(error);
  }
  onError(error) {
    this.pause();
    if (this.config.onError)
      this.config.onError(error);
  }
  destroy() {
    this.stop();
  }
};
var ImageManager = {
  map: {},
  recycledList: [],
  tasker: new TaskProcessor(),
  patternTasker: new TaskProcessor(),
  get isComplete() {
    return I.tasker.isComplete;
  },
  get(config) {
    let image = I.map[config.url];
    if (!image) {
      image = Creator.image(config);
      I.map[config.url] = image;
    }
    image.use++;
    return image;
  },
  recycle(image) {
    image.use--;
    setTimeout(() => {
      if (!image.use)
        I.recycledList.push(image);
    });
  },
  clearRecycled() {
    const list2 = I.recycledList;
    if (list2.length > 100) {
      list2.forEach((image) => {
        if (!image.use && image.url) {
          delete I.map[image.url];
          image.destroy();
        }
      });
      list2.length = 0;
    }
  },
  hasOpacityPixel(config) {
    return FileHelper.opacityTypes.some((item) => I.isFormat(item, config));
  },
  isFormat(format, config) {
    if (config.format === format)
      return true;
    const { url } = config;
    if (url.startsWith("data:")) {
      if (url.startsWith("data:" + FileHelper.mineType(format)))
        return true;
    } else {
      if (url.includes("." + format) || url.includes("." + FileHelper.upperCaseTypeMap[format]))
        return true;
      else if (format === "png" && !url.includes("."))
        return true;
    }
    return false;
  },
  destroy() {
    I.map = {};
    I.recycledList = [];
  }
};
var I = ImageManager;
var { IMAGE, create: create$1 } = IncrementId;
var LeaferImage = class {
  get url() {
    return this.config.url;
  }
  get completed() {
    return this.ready || !!this.error;
  }
  constructor(config) {
    this.use = 0;
    this.waitComplete = [];
    this.innerId = create$1(IMAGE);
    this.config = config || { url: "" };
    this.isSVG = ImageManager.isFormat("svg", config);
    this.hasOpacityPixel = ImageManager.hasOpacityPixel(config);
  }
  load(onSuccess, onError) {
    if (!this.loading) {
      this.loading = true;
      ImageManager.tasker.add(() => __awaiter(this, void 0, void 0, function* () {
        return yield Platform.origin.loadImage(this.url).then((img) => {
          this.ready = true;
          this.width = img.naturalWidth || img.width;
          this.height = img.naturalHeight || img.height;
          this.view = img;
          this.onComplete(true);
        }).catch((e) => {
          this.error = e;
          this.onComplete(false);
        });
      }));
    }
    this.waitComplete.push(onSuccess, onError);
    return this.waitComplete.length - 2;
  }
  unload(index, stopEvent) {
    const l2 = this.waitComplete;
    if (stopEvent) {
      const error = l2[index + 1];
      if (error)
        error({ type: "stop" });
    }
    l2[index] = l2[index + 1] = void 0;
  }
  onComplete(isSuccess) {
    let odd;
    this.waitComplete.forEach((item, index) => {
      odd = index % 2;
      if (item) {
        if (isSuccess) {
          if (!odd)
            item(this);
        } else {
          if (odd)
            item(this.error);
        }
      }
    });
    this.waitComplete.length = 0;
    this.loading = false;
  }
  getCanvas(width, height, opacity, _filters) {
    width || (width = this.width);
    height || (height = this.height);
    if (this.cache) {
      let { params, data } = this.cache;
      for (let i in params) {
        if (params[i] !== arguments[i]) {
          data = null;
          break;
        }
      }
      if (data)
        return data;
    }
    const canvas = Platform.origin.createCanvas(width, height);
    const ctx = canvas.getContext("2d");
    if (opacity)
      ctx.globalAlpha = opacity;
    ctx.drawImage(this.view, 0, 0, width, height);
    this.cache = this.use > 1 ? { data: canvas, params: arguments } : null;
    return canvas;
  }
  getPattern(canvas, repeat, transform2, paint) {
    const pattern = Platform.canvas.createPattern(canvas, repeat);
    try {
      if (transform2 && pattern.setTransform) {
        pattern.setTransform(transform2);
        transform2 = null;
      }
    } catch (_a) {
    }
    if (paint)
      paint.transform = transform2;
    return pattern;
  }
  destroy() {
    this.config = { url: "" };
    this.cache = null;
    this.waitComplete.length = 0;
  }
};
function defineKey(target, key, descriptor, noConfigurable) {
  if (!noConfigurable)
    descriptor.configurable = descriptor.enumerable = true;
  Object.defineProperty(target, key, descriptor);
}
function getDescriptor(object, name) {
  return Object.getOwnPropertyDescriptor(object, name);
}
function getNames(object) {
  return Object.getOwnPropertyNames(object);
}
function decorateLeafAttr(defaultValue, descriptorFn) {
  return (target, key) => defineLeafAttr(target, key, defaultValue, descriptorFn && descriptorFn(key));
}
function attr(partDescriptor) {
  return partDescriptor;
}
function defineLeafAttr(target, key, defaultValue, partDescriptor) {
  const defaultDescriptor = {
    get() {
      return this.__getAttr(key);
    },
    set(value) {
      this.__setAttr(key, value);
    }
  };
  defineKey(target, key, Object.assign(defaultDescriptor, partDescriptor || {}));
  defineDataProcessor(target, key, defaultValue);
}
function dataType(defaultValue) {
  return decorateLeafAttr(defaultValue);
}
function positionType(defaultValue, checkFiniteNumber) {
  return decorateLeafAttr(defaultValue, (key) => attr({
    set(value) {
      this.__setAttr(key, value, checkFiniteNumber) && (this.__layout.matrixChanged || this.__layout.matrixChange());
    }
  }));
}
function autoLayoutType(defaultValue) {
  return decorateLeafAttr(defaultValue, (key) => attr({
    set(value) {
      if (this.__setAttr(key, value)) {
        this.__layout.matrixChanged || this.__layout.matrixChange();
        this.__hasAutoLayout = !!(this.origin || this.around || this.flow);
        if (!this.__local)
          this.__layout.createLocal();
      }
    }
  }));
}
function scaleType(defaultValue, checkFiniteNumber) {
  return decorateLeafAttr(defaultValue, (key) => attr({
    set(value) {
      this.__setAttr(key, value, checkFiniteNumber) && (this.__layout.scaleChanged || this.__layout.scaleChange());
    }
  }));
}
function rotationType(defaultValue, checkFiniteNumber) {
  return decorateLeafAttr(defaultValue, (key) => attr({
    set(value) {
      this.__setAttr(key, value, checkFiniteNumber) && (this.__layout.rotationChanged || this.__layout.rotationChange());
    }
  }));
}
function boundsType(defaultValue, checkFiniteNumber) {
  return decorateLeafAttr(defaultValue, (key) => attr({
    set(value) {
      this.__setAttr(key, value, checkFiniteNumber) && doBoundsType(this);
    }
  }));
}
function naturalBoundsType(defaultValue) {
  return decorateLeafAttr(defaultValue, (key) => attr({
    set(value) {
      this.__setAttr(key, value) && (doBoundsType(this), this.__.__removeNaturalSize());
    }
  }));
}
function doBoundsType(leaf) {
  leaf.__layout.boxChanged || leaf.__layout.boxChange();
  if (leaf.__hasAutoLayout)
    leaf.__layout.matrixChanged || leaf.__layout.matrixChange();
}
function pathInputType(defaultValue) {
  return decorateLeafAttr(defaultValue, (key) => attr({
    set(value) {
      const data = this.__;
      if (data.__pathInputed !== 2)
        data.__pathInputed = value ? 1 : 0;
      if (!value)
        data.__pathForRender = void 0;
      this.__setAttr(key, value);
      doBoundsType(this);
    }
  }));
}
var pathType = boundsType;
function affectStrokeBoundsType(defaultValue) {
  return decorateLeafAttr(defaultValue, (key) => attr({
    set(value) {
      this.__setAttr(key, value) && doStrokeType(this);
    }
  }));
}
function doStrokeType(leaf) {
  leaf.__layout.strokeChanged || leaf.__layout.strokeChange();
  if (leaf.__.__useArrow)
    doBoundsType(leaf);
}
var strokeType = affectStrokeBoundsType;
function affectRenderBoundsType(defaultValue) {
  return decorateLeafAttr(defaultValue, (key) => attr({
    set(value) {
      this.__setAttr(key, value);
      this.__layout.renderChanged || this.__layout.renderChange();
    }
  }));
}
function surfaceType(defaultValue) {
  return decorateLeafAttr(defaultValue, (key) => attr({
    set(value) {
      this.__setAttr(key, value) && (this.__layout.surfaceChanged || this.__layout.surfaceChange());
    }
  }));
}
function opacityType(defaultValue) {
  return decorateLeafAttr(defaultValue, (key) => attr({
    set(value) {
      this.__setAttr(key, value) && (this.__layout.opacityChanged || this.__layout.opacityChange());
    }
  }));
}
function visibleType(defaultValue) {
  return decorateLeafAttr(defaultValue, (key) => attr({
    set(value) {
      const oldValue = this.visible;
      if (oldValue === true && value === 0) {
        if (this.animationOut)
          return this.__runAnimation("out", () => doVisible(this, key, value, oldValue));
      } else if (oldValue === 0 && value === true) {
        if (this.animation)
          this.__runAnimation("in");
      }
      doVisible(this, key, value, oldValue);
    }
  }));
}
function doVisible(leaf, key, value, oldValue) {
  if (leaf.__setAttr(key, value)) {
    leaf.__layout.opacityChanged || leaf.__layout.opacityChange();
    if (oldValue === 0 || value === 0)
      doBoundsType(leaf);
  }
}
function sortType(defaultValue) {
  return decorateLeafAttr(defaultValue, (key) => attr({
    set(value) {
      if (this.__setAttr(key, value)) {
        this.__layout.surfaceChanged || this.__layout.surfaceChange();
        this.waitParent(() => {
          this.parent.__layout.childrenSortChange();
        });
      }
    }
  }));
}
function maskType(defaultValue) {
  return decorateLeafAttr(defaultValue, (key) => attr({
    set(value) {
      if (this.__setAttr(key, value)) {
        this.__layout.boxChanged || this.__layout.boxChange();
        this.waitParent(() => {
          this.parent.__updateMask(value);
        });
      }
    }
  }));
}
function eraserType(defaultValue) {
  return decorateLeafAttr(defaultValue, (key) => attr({
    set(value) {
      this.__setAttr(key, value) && this.waitParent(() => {
        this.parent.__updateEraser(value);
      });
    }
  }));
}
function hitType(defaultValue) {
  return decorateLeafAttr(defaultValue, (key) => attr({
    set(value) {
      if (this.__setAttr(key, value)) {
        this.__layout.hitCanvasChanged = true;
        if (Debug.showHitView) {
          this.__layout.surfaceChanged || this.__layout.surfaceChange();
        }
        if (this.leafer)
          this.leafer.updateCursor();
      }
    }
  }));
}
function cursorType(defaultValue) {
  return decorateLeafAttr(defaultValue, (key) => attr({
    set(value) {
      this.__setAttr(key, value);
      if (this.leafer)
        this.leafer.updateCursor();
    }
  }));
}
function dataProcessor(processor) {
  return (target, _key) => {
    defineKey(target, "__DataProcessor", {
      get() {
        return processor;
      }
    });
  };
}
function layoutProcessor(processor) {
  return (target, _key) => {
    defineKey(target, "__LayoutProcessor", {
      get() {
        return processor;
      }
    });
  };
}
function getSetMethodName(key) {
  return "set" + key.charAt(0).toUpperCase() + key.slice(1);
}
function defineDataProcessor(target, key, defaultValue) {
  const data = target.__DataProcessor.prototype;
  const computedKey = "_" + key;
  const setMethodName = getSetMethodName(key);
  const property = {
    get() {
      const v2 = this[computedKey];
      return v2 === void 0 ? defaultValue : v2;
    },
    set(value) {
      this[computedKey] = value;
    }
  };
  if (defaultValue === void 0) {
    property.get = function() {
      return this[computedKey];
    };
  } else if (typeof defaultValue === "object") {
    const { clone } = DataHelper;
    property.get = function() {
      let v2 = this[computedKey];
      if (v2 === void 0)
        this[computedKey] = v2 = clone(defaultValue);
      return v2;
    };
  }
  if (key === "width") {
    property.get = function() {
      const v2 = this[computedKey];
      if (v2 === void 0) {
        const t2 = this;
        return t2._height && t2.__naturalWidth && t2.__useNaturalRatio ? t2._height * t2.__naturalWidth / t2.__naturalHeight : t2.__naturalWidth || defaultValue;
      } else {
        return v2;
      }
    };
  } else if (key === "height") {
    property.get = function() {
      const v2 = this[computedKey];
      if (v2 === void 0) {
        const t2 = this;
        return t2._width && t2.__naturalHeight && t2.__useNaturalRatio ? t2._width * t2.__naturalHeight / t2.__naturalWidth : t2.__naturalHeight || defaultValue;
      } else {
        return v2;
      }
    };
  }
  let descriptor, find = data;
  while (!descriptor && find) {
    descriptor = getDescriptor(find, key);
    find = find.__proto__;
  }
  if (descriptor && descriptor.set)
    property.set = descriptor.set;
  if (data[setMethodName]) {
    property.set = data[setMethodName];
    delete data[setMethodName];
  }
  defineKey(data, key, property);
}
var debug$1 = new Debug("rewrite");
var list = [];
var excludeNames = ["destroy", "constructor"];
function rewrite(method) {
  return (target, key) => {
    list.push({ name: target.constructor.name + "." + key, run: () => {
      target[key] = method;
    } });
  };
}
function rewriteAble() {
  return (_target) => {
    doRewrite();
  };
}
function doRewrite(error) {
  if (list.length) {
    list.forEach((item) => {
      if (error)
        debug$1.error(item.name, "Class@rewriteAble()");
      item.run();
    });
    list.length = 0;
  }
}
setTimeout(() => doRewrite(true));
function useModule(module, exclude) {
  return (target) => {
    const names = module.prototype ? getNames(module.prototype) : Object.keys(module);
    names.forEach((name) => {
      if (!excludeNames.includes(name) && (!exclude || !exclude.includes(name))) {
        if (module.prototype) {
          const d = getDescriptor(module.prototype, name);
          if (d.writable)
            target.prototype[name] = module.prototype[name];
        } else {
          target.prototype[name] = module[name];
        }
      }
    });
  };
}
function registerUI() {
  return (target) => {
    UICreator.register(target);
  };
}
function registerUIEvent() {
  return (target) => {
    EventCreator.register(target);
  };
}
var { copy: copy$3, toInnerPoint: toInnerPoint$1, toOuterPoint: toOuterPoint$1, scaleOfOuter, rotateOfOuter, skewOfOuter, multiplyParent: multiplyParent$2, divideParent, getLayout } = MatrixHelper;
var matrix = {};
var LeafHelper = {
  updateAllMatrix(leaf, checkAutoLayout, waitAutoLayout) {
    if (checkAutoLayout && leaf.__hasAutoLayout && leaf.__layout.matrixChanged)
      waitAutoLayout = true;
    updateMatrix$1(leaf, checkAutoLayout, waitAutoLayout);
    if (leaf.isBranch) {
      const { children } = leaf;
      for (let i = 0, len = children.length; i < len; i++) {
        updateAllMatrix$1(children[i], checkAutoLayout, waitAutoLayout);
      }
    }
  },
  updateMatrix(leaf, checkAutoLayout, waitAutoLayout) {
    const layout = leaf.__layout;
    if (checkAutoLayout) {
      if (waitAutoLayout) {
        layout.waitAutoLayout = true;
        if (leaf.__hasAutoLayout)
          layout.matrixChanged = false;
      }
    } else if (layout.waitAutoLayout) {
      layout.waitAutoLayout = false;
    }
    if (layout.matrixChanged)
      leaf.__updateLocalMatrix();
    if (!layout.waitAutoLayout)
      leaf.__updateWorldMatrix();
  },
  updateBounds(leaf) {
    const layout = leaf.__layout;
    if (layout.boundsChanged)
      leaf.__updateLocalBounds();
    if (!layout.waitAutoLayout)
      leaf.__updateWorldBounds();
  },
  updateAllWorldOpacity(leaf) {
    leaf.__updateWorldOpacity();
    if (leaf.isBranch) {
      const { children } = leaf;
      for (let i = 0, len = children.length; i < len; i++) {
        updateAllWorldOpacity(children[i]);
      }
    }
  },
  updateAllChange(leaf) {
    updateAllWorldOpacity(leaf);
    leaf.__updateChange();
    if (leaf.isBranch) {
      const { children } = leaf;
      for (let i = 0, len = children.length; i < len; i++) {
        updateAllChange(children[i]);
      }
    }
  },
  worldHittable(t2) {
    while (t2) {
      if (!t2.__.hittable)
        return false;
      t2 = t2.parent;
    }
    return true;
  },
  moveWorld(t2, x, y = 0, isInnerPoint) {
    const local = typeof x === "object" ? Object.assign({}, x) : { x, y };
    isInnerPoint ? toOuterPoint$1(t2.localTransform, local, local, true) : t2.parent && toInnerPoint$1(t2.parent.worldTransform, local, local, true);
    L.moveLocal(t2, local.x, local.y);
  },
  moveLocal(t2, x, y = 0) {
    if (typeof x === "object") {
      t2.x += x.x;
      t2.y += x.y;
    } else {
      t2.x += x;
      t2.y += y;
    }
  },
  zoomOfWorld(t2, origin, scaleX, scaleY, resize) {
    L.zoomOfLocal(t2, getTempLocal(t2, origin), scaleX, scaleY, resize);
  },
  zoomOfLocal(t2, origin, scaleX, scaleY = scaleX, resize) {
    copy$3(matrix, t2.__localMatrix);
    scaleOfOuter(matrix, origin, scaleX, scaleY);
    if (t2.origin || t2.around) {
      L.setTransform(t2, matrix, resize);
    } else {
      moveByMatrix(t2, matrix);
      t2.scaleResize(scaleX, scaleY, resize !== true);
    }
  },
  rotateOfWorld(t2, origin, angle) {
    L.rotateOfLocal(t2, getTempLocal(t2, origin), angle);
  },
  rotateOfLocal(t2, origin, angle) {
    copy$3(matrix, t2.__localMatrix);
    rotateOfOuter(matrix, origin, angle);
    if (t2.origin || t2.around) {
      L.setTransform(t2, matrix);
    } else {
      moveByMatrix(t2, matrix);
      t2.rotation = MathHelper.formatRotation(t2.rotation + angle);
    }
  },
  skewOfWorld(t2, origin, skewX, skewY, resize) {
    L.skewOfLocal(t2, getTempLocal(t2, origin), skewX, skewY, resize);
  },
  skewOfLocal(t2, origin, skewX, skewY = 0, resize) {
    copy$3(matrix, t2.__localMatrix);
    skewOfOuter(matrix, origin, skewX, skewY);
    L.setTransform(t2, matrix, resize);
  },
  transformWorld(t2, transform2, resize) {
    copy$3(matrix, t2.worldTransform);
    multiplyParent$2(matrix, transform2);
    if (t2.parent)
      divideParent(matrix, t2.parent.worldTransform);
    L.setTransform(t2, matrix, resize);
  },
  transform(t2, transform2, resize) {
    copy$3(matrix, t2.localTransform);
    multiplyParent$2(matrix, transform2);
    L.setTransform(t2, matrix, resize);
  },
  setTransform(t2, transform2, resize) {
    const layout = getLayout(transform2, t2.origin && L.getInnerOrigin(t2, t2.origin), t2.around && L.getInnerOrigin(t2, t2.around));
    if (resize) {
      const scaleX = layout.scaleX / t2.scaleX;
      const scaleY = layout.scaleY / t2.scaleY;
      delete layout.scaleX;
      delete layout.scaleY;
      t2.set(layout);
      t2.scaleResize(scaleX, scaleY, resize !== true);
    } else {
      t2.set(layout);
    }
  },
  getFlipTransform(t2, axis) {
    const m2 = getMatrixData();
    const sign = axis === "x" ? 1 : -1;
    scaleOfOuter(m2, L.getLocalOrigin(t2, "center"), -1 * sign, 1 * sign);
    return m2;
  },
  getLocalOrigin(t2, origin) {
    return PointHelper.tempToOuterOf(L.getInnerOrigin(t2, origin), t2.localTransform);
  },
  getInnerOrigin(t2, origin) {
    const innerOrigin = {};
    AroundHelper.toPoint(origin, t2.boxBounds, innerOrigin);
    return innerOrigin;
  },
  getRelativeWorld(t2, relative, temp) {
    copy$3(matrix, t2.worldTransform);
    divideParent(matrix, relative.worldTransform);
    return temp ? matrix : Object.assign({}, matrix);
  },
  drop(t2, parent, index, resize) {
    t2.setTransform(L.getRelativeWorld(t2, parent, true), resize);
    parent.add(t2, index);
  },
  hasParent(p, parent) {
    if (!parent)
      return false;
    while (p) {
      if (parent === p)
        return true;
      p = p.parent;
    }
  }
};
var L = LeafHelper;
var { updateAllMatrix: updateAllMatrix$1, updateMatrix: updateMatrix$1, updateAllWorldOpacity, updateAllChange } = L;
function moveByMatrix(t2, matrix2) {
  const { e, f } = t2.__localMatrix;
  t2.x += matrix2.e - e;
  t2.y += matrix2.f - f;
}
function getTempLocal(t2, world) {
  t2.__layout.update();
  return t2.parent ? PointHelper.tempToInnerOf(world, t2.parent.__world) : world;
}
var LeafBoundsHelper = {
  worldBounds(target) {
    return target.__world;
  },
  localBoxBounds(target) {
    return target.__.eraser || target.__.visible === 0 ? null : target.__local || target.__layout;
  },
  localStrokeBounds(target) {
    return target.__.eraser || target.__.visible === 0 ? null : target.__layout.localStrokeBounds;
  },
  localRenderBounds(target) {
    return target.__.eraser || target.__.visible === 0 ? null : target.__layout.localRenderBounds;
  },
  maskLocalBoxBounds(target) {
    return target.__.mask ? target.__localBoxBounds : null;
  },
  maskLocalStrokeBounds(target) {
    return target.__.mask ? target.__layout.localStrokeBounds : null;
  },
  maskLocalRenderBounds(target) {
    return target.__.mask ? target.__layout.localRenderBounds : null;
  },
  excludeRenderBounds(child, options) {
    if (options.bounds && !options.bounds.hit(child.__world, options.matrix))
      return true;
    if (options.hideBounds && options.hideBounds.includes(child.__world, options.matrix))
      return true;
    return false;
  }
};
var { updateBounds: updateBounds$1 } = LeafHelper;
var BranchHelper = {
  sort(a2, b) {
    return a2.__.zIndex === b.__.zIndex ? a2.__tempNumber - b.__tempNumber : a2.__.zIndex - b.__.zIndex;
  },
  pushAllChildBranch(branch, leafList) {
    branch.__tempNumber = 1;
    if (branch.__.__childBranchNumber) {
      const { children } = branch;
      for (let i = 0, len = children.length; i < len; i++) {
        branch = children[i];
        if (branch.isBranch) {
          branch.__tempNumber = 1;
          leafList.add(branch);
          pushAllChildBranch(branch, leafList);
        }
      }
    }
  },
  pushAllParent(leaf, leafList) {
    const { keys } = leafList;
    if (keys) {
      while (leaf.parent) {
        if (keys[leaf.parent.innerId] === void 0) {
          leafList.add(leaf.parent);
          leaf = leaf.parent;
        } else {
          break;
        }
      }
    } else {
      while (leaf.parent) {
        leafList.add(leaf.parent);
        leaf = leaf.parent;
      }
    }
  },
  pushAllBranchStack(branch, pushList) {
    let start = pushList.length;
    const { children } = branch;
    for (let i = 0, len = children.length; i < len; i++) {
      if (children[i].isBranch) {
        pushList.push(children[i]);
      }
    }
    for (let i = start, len = pushList.length; i < len; i++) {
      pushAllBranchStack(pushList[i], pushList);
    }
  },
  updateBounds(branch, exclude) {
    const branchStack = [branch];
    pushAllBranchStack(branch, branchStack);
    updateBoundsByBranchStack(branchStack, exclude);
  },
  updateBoundsByBranchStack(branchStack, exclude) {
    let branch, children;
    for (let i = branchStack.length - 1; i > -1; i--) {
      branch = branchStack[i];
      children = branch.children;
      for (let j = 0, len = children.length; j < len; j++) {
        updateBounds$1(children[j]);
      }
      if (exclude && exclude === branch)
        continue;
      updateBounds$1(branch);
    }
  }
};
var { pushAllChildBranch, pushAllBranchStack, updateBoundsByBranchStack } = BranchHelper;
var WaitHelper = {
  run(wait) {
    if (wait && wait.length) {
      const len = wait.length;
      for (let i = 0; i < len; i++) {
        wait[i]();
      }
      wait.length === len ? wait.length = 0 : wait.splice(0, len);
    }
  }
};
var { getRelativeWorld: getRelativeWorld$1 } = LeafHelper;
var { toOuterOf: toOuterOf$2, getPoints, copy: copy$2 } = BoundsHelper;
var localContent = "_localContentBounds";
var worldContent = "_worldContentBounds";
var worldBox = "_worldBoxBounds";
var worldStroke = "_worldStrokeBounds";
var LeafLayout = class {
  get contentBounds() {
    return this._contentBounds || this.boxBounds;
  }
  set contentBounds(bounds) {
    this._contentBounds = bounds;
  }
  get strokeBounds() {
    return this._strokeBounds || this.boxBounds;
  }
  get renderBounds() {
    return this._renderBounds || this.boxBounds;
  }
  get localContentBounds() {
    toOuterOf$2(this.contentBounds, this.leaf.__localMatrix, this[localContent] || (this[localContent] = {}));
    return this[localContent];
  }
  get localStrokeBounds() {
    return this._localStrokeBounds || this;
  }
  get localRenderBounds() {
    return this._localRenderBounds || this;
  }
  get worldContentBounds() {
    toOuterOf$2(this.contentBounds, this.leaf.__world, this[worldContent] || (this[worldContent] = {}));
    return this[worldContent];
  }
  get worldBoxBounds() {
    toOuterOf$2(this.boxBounds, this.leaf.__world, this[worldBox] || (this[worldBox] = {}));
    return this[worldBox];
  }
  get worldStrokeBounds() {
    toOuterOf$2(this.strokeBounds, this.leaf.__world, this[worldStroke] || (this[worldStroke] = {}));
    return this[worldStroke];
  }
  get a() {
    return 1;
  }
  get b() {
    return 0;
  }
  get c() {
    return 0;
  }
  get d() {
    return 1;
  }
  get e() {
    return this.leaf.__.x;
  }
  get f() {
    return this.leaf.__.y;
  }
  get x() {
    return this.e + this.boxBounds.x;
  }
  get y() {
    return this.f + this.boxBounds.y;
  }
  get width() {
    return this.boxBounds.width;
  }
  get height() {
    return this.boxBounds.height;
  }
  constructor(leaf) {
    this.leaf = leaf;
    this.boxBounds = { x: 0, y: 0, width: 0, height: 0 };
    if (this.leaf.__local)
      this._localRenderBounds = this._localStrokeBounds = this.leaf.__local;
    this.boxChange();
    this.matrixChange();
  }
  createLocal() {
    const local = this.leaf.__local = { a: 1, b: 0, c: 0, d: 1, e: 0, f: 0, x: 0, y: 0, width: 0, height: 0 };
    if (!this._localStrokeBounds)
      this._localStrokeBounds = local;
    if (!this._localRenderBounds)
      this._localRenderBounds = local;
  }
  update() {
    const { leafer } = this.leaf;
    if (leafer) {
      if (leafer.ready)
        leafer.watcher.changed && leafer.layouter.layout();
      else
        leafer.start();
    } else {
      let root = this.leaf;
      while (root.parent && !root.parent.leafer) {
        root = root.parent;
      }
      Platform.layout(root);
    }
  }
  getTransform(relative = "world") {
    this.update();
    const { leaf } = this;
    switch (relative) {
      case "world":
        return leaf.__world;
      case "local":
        return leaf.__localMatrix;
      case "inner":
        return MatrixHelper.defaultMatrix;
      case "page":
        relative = leaf.zoomLayer;
      default:
        return getRelativeWorld$1(leaf, relative);
    }
  }
  getBounds(type, relative = "world") {
    this.update();
    switch (relative) {
      case "world":
        return this.getWorldBounds(type);
      case "local":
        return this.getLocalBounds(type);
      case "inner":
        return this.getInnerBounds(type);
      case "page":
        relative = this.leaf.zoomLayer;
      default:
        return new Bounds(this.getInnerBounds(type)).toOuterOf(this.getTransform(relative));
    }
  }
  getInnerBounds(type = "box") {
    switch (type) {
      case "render":
        return this.renderBounds;
      case "content":
        if (this.contentBounds)
          return this.contentBounds;
      case "box":
        return this.boxBounds;
      case "stroke":
        return this.strokeBounds;
    }
  }
  getLocalBounds(type = "box") {
    switch (type) {
      case "render":
        return this.localRenderBounds;
      case "stroke":
        return this.localStrokeBounds;
      case "content":
        if (this.contentBounds)
          return this.localContentBounds;
      case "box":
        return this.leaf.__localBoxBounds;
    }
  }
  getWorldBounds(type = "box") {
    switch (type) {
      case "render":
        return this.leaf.__world;
      case "stroke":
        return this.worldStrokeBounds;
      case "content":
        if (this.contentBounds)
          return this.worldContentBounds;
      case "box":
        return this.worldBoxBounds;
    }
  }
  getLayoutBounds(type, relative = "world", unscale) {
    const { leaf } = this;
    let point2, matrix2, layoutBounds, bounds = this.getInnerBounds(type);
    switch (relative) {
      case "world":
        point2 = leaf.getWorldPoint(bounds);
        matrix2 = leaf.__world;
        break;
      case "local":
        const { scaleX, scaleY, rotation, skewX, skewY } = leaf.__;
        layoutBounds = { scaleX, scaleY, rotation, skewX, skewY };
        point2 = leaf.getLocalPointByInner(bounds);
        break;
      case "inner":
        point2 = bounds;
        matrix2 = MatrixHelper.defaultMatrix;
        break;
      case "page":
        relative = leaf.zoomLayer;
      default:
        point2 = leaf.getWorldPoint(bounds, relative);
        matrix2 = getRelativeWorld$1(leaf, relative, true);
    }
    if (!layoutBounds)
      layoutBounds = MatrixHelper.getLayout(matrix2);
    copy$2(layoutBounds, bounds);
    PointHelper.copy(layoutBounds, point2);
    if (unscale) {
      const { scaleX, scaleY } = layoutBounds;
      const uScaleX = Math.abs(scaleX);
      const uScaleY = Math.abs(scaleY);
      if (uScaleX !== 1 || uScaleY !== 1) {
        layoutBounds.scaleX /= uScaleX;
        layoutBounds.scaleY /= uScaleY;
        layoutBounds.width *= uScaleX;
        layoutBounds.height *= uScaleY;
      }
    }
    return layoutBounds;
  }
  getLayoutPoints(type, relative = "world") {
    const { leaf } = this;
    const points = getPoints(this.getInnerBounds(type));
    let relativeLeaf;
    switch (relative) {
      case "world":
        relativeLeaf = null;
        break;
      case "local":
        relativeLeaf = leaf.parent;
        break;
      case "inner":
        break;
      case "page":
        relative = leaf.zoomLayer;
      default:
        relativeLeaf = relative;
    }
    if (relativeLeaf !== void 0)
      points.forEach((point2) => leaf.innerToWorld(point2, null, false, relativeLeaf));
    return points;
  }
  shrinkContent() {
    const { x, y, width, height } = this.boxBounds;
    this._contentBounds = { x, y, width, height };
  }
  spreadStroke() {
    const { x, y, width, height } = this.strokeBounds;
    this._strokeBounds = { x, y, width, height };
    this._localStrokeBounds = { x, y, width, height };
    if (!this.renderSpread)
      this.spreadRenderCancel();
  }
  spreadRender() {
    const { x, y, width, height } = this.renderBounds;
    this._renderBounds = { x, y, width, height };
    this._localRenderBounds = { x, y, width, height };
  }
  shrinkContentCancel() {
    this._contentBounds = void 0;
  }
  spreadStrokeCancel() {
    const same = this.renderBounds === this.strokeBounds;
    this._strokeBounds = this.boxBounds;
    this._localStrokeBounds = this.leaf.__localBoxBounds;
    if (same)
      this.spreadRenderCancel();
  }
  spreadRenderCancel() {
    this._renderBounds = this._strokeBounds;
    this._localRenderBounds = this._localStrokeBounds;
  }
  boxChange() {
    this.boxChanged = true;
    this.localBoxChanged || this.localBoxChange();
    this.hitCanvasChanged = true;
  }
  localBoxChange() {
    this.localBoxChanged = true;
    this.boundsChanged = true;
  }
  strokeChange() {
    this.strokeChanged = true;
    this.strokeSpread || (this.strokeSpread = 1);
    this.boundsChanged = true;
    this.hitCanvasChanged = true;
  }
  renderChange() {
    this.renderChanged = true;
    this.renderSpread || (this.renderSpread = 1);
    this.boundsChanged = true;
  }
  scaleChange() {
    this.scaleChanged = true;
    this._scaleOrRotationChange();
  }
  rotationChange() {
    this.rotationChanged = true;
    this.affectRotation = true;
    this._scaleOrRotationChange();
  }
  _scaleOrRotationChange() {
    this.affectScaleOrRotation = true;
    this.matrixChange();
    if (!this.leaf.__local)
      this.createLocal();
  }
  matrixChange() {
    this.matrixChanged = true;
    this.localBoxChanged || this.localBoxChange();
  }
  surfaceChange() {
    this.surfaceChanged = true;
  }
  opacityChange() {
    this.opacityChanged = true;
    this.surfaceChanged || this.surfaceChange();
  }
  childrenSortChange() {
    if (!this.childrenSortChanged) {
      this.childrenSortChanged = true;
      this.leaf.forceUpdate("surface");
    }
  }
  destroy() {
  }
};
var Event = class {
  constructor(type, target) {
    this.bubbles = false;
    this.type = type;
    if (target)
      this.target = target;
  }
  stopDefault() {
    this.isStopDefault = true;
    if (this.origin)
      Platform.event.stopDefault(this.origin);
  }
  stopNow() {
    this.isStopNow = true;
    this.isStop = true;
    if (this.origin)
      Platform.event.stopNow(this.origin);
  }
  stop() {
    this.isStop = true;
    if (this.origin)
      Platform.event.stop(this.origin);
  }
};
var ChildEvent = class extends Event {
  constructor(type, child, parent) {
    super(type, child);
    this.parent = parent;
    this.child = child;
  }
};
ChildEvent.ADD = "child.add";
ChildEvent.REMOVE = "child.remove";
ChildEvent.CREATED = "created";
ChildEvent.MOUNTED = "mounted";
ChildEvent.UNMOUNTED = "unmounted";
ChildEvent.DESTROY = "destroy";
var PropertyEvent = class extends Event {
  constructor(type, target, attrName, oldValue, newValue) {
    super(type, target);
    this.attrName = attrName;
    this.oldValue = oldValue;
    this.newValue = newValue;
  }
};
PropertyEvent.CHANGE = "property.change";
PropertyEvent.LEAFER_CHANGE = "property.leafer_change";
var ImageEvent = class extends Event {
  constructor(type, data) {
    super(type);
    Object.assign(this, data);
  }
};
ImageEvent.LOAD = "image.load";
ImageEvent.LOADED = "image.loaded";
ImageEvent.ERROR = "image.error";
var ResizeEvent = class _ResizeEvent extends Event {
  get bigger() {
    if (!this.old)
      return true;
    const { width, height } = this.old;
    return this.width >= width && this.height >= height;
  }
  get smaller() {
    return !this.bigger;
  }
  get samePixelRatio() {
    if (!this.old)
      return true;
    return this.pixelRatio === this.old.pixelRatio;
  }
  constructor(size, oldSize) {
    if (typeof size === "object") {
      super(_ResizeEvent.RESIZE);
      Object.assign(this, size);
    } else {
      super(size);
    }
    this.old = oldSize;
  }
};
ResizeEvent.RESIZE = "resize";
var WatchEvent = class extends Event {
  constructor(type, data) {
    super(type);
    this.data = data;
  }
};
WatchEvent.REQUEST = "watch.request";
WatchEvent.DATA = "watch.data";
var LayoutEvent = class extends Event {
  constructor(type, data, times) {
    super(type);
    if (data) {
      this.data = data;
      this.times = times;
    }
  }
};
LayoutEvent.CHECK_UPDATE = "layout.check_update";
LayoutEvent.REQUEST = "layout.request";
LayoutEvent.START = "layout.start";
LayoutEvent.BEFORE = "layout.before";
LayoutEvent.LAYOUT = "layout";
LayoutEvent.AFTER = "layout.after";
LayoutEvent.AGAIN = "layout.again";
LayoutEvent.END = "layout.end";
var RenderEvent = class extends Event {
  constructor(type, times, bounds, options) {
    super(type);
    if (times)
      this.times = times;
    if (bounds) {
      this.renderBounds = bounds;
      this.renderOptions = options;
    }
  }
};
RenderEvent.REQUEST = "render.request";
RenderEvent.CHILD_START = "render.child_start";
RenderEvent.START = "render.start";
RenderEvent.BEFORE = "render.before";
RenderEvent.RENDER = "render";
RenderEvent.AFTER = "render.after";
RenderEvent.AGAIN = "render.again";
RenderEvent.END = "render.end";
RenderEvent.NEXT = "render.next";
var LeaferEvent = class extends Event {
};
LeaferEvent.START = "leafer.start";
LeaferEvent.BEFORE_READY = "leafer.before_ready";
LeaferEvent.READY = "leafer.ready";
LeaferEvent.AFTER_READY = "leafer.after_ready";
LeaferEvent.VIEW_READY = "leafer.view_ready";
LeaferEvent.VIEW_COMPLETED = "leafer.view_completed";
LeaferEvent.STOP = "leafer.stop";
LeaferEvent.RESTART = "leafer.restart";
LeaferEvent.END = "leafer.end";
var empty = {};
var Eventer = class {
  set event(map) {
    this.on(map);
  }
  on(type, listener, options) {
    if (!listener) {
      let event, map2 = type;
      for (let key in map2)
        event = map2[key], event instanceof Array ? this.on(key, event[0], event[1]) : this.on(key, event);
      return;
    }
    let capture, once2;
    if (options) {
      if (options === "once") {
        once2 = true;
      } else if (typeof options === "boolean") {
        capture = options;
      } else {
        capture = options.capture;
        once2 = options.once;
      }
    }
    let events;
    const map = __getListenerMap(this, capture, true);
    const typeList = typeof type === "string" ? type.split(" ") : type;
    const item = once2 ? { listener, once: once2 } : { listener };
    typeList.forEach((type2) => {
      if (type2) {
        events = map[type2];
        if (events) {
          if (events.findIndex((item2) => item2.listener === listener) === -1)
            events.push(item);
        } else {
          map[type2] = [item];
        }
      }
    });
  }
  off(type, listener, options) {
    if (type) {
      const typeList = typeof type === "string" ? type.split(" ") : type;
      if (listener) {
        let capture;
        if (options)
          capture = typeof options === "boolean" ? options : options === "once" ? false : options.capture;
        let events, index;
        const map = __getListenerMap(this, capture);
        typeList.forEach((type2) => {
          if (type2) {
            events = map[type2];
            if (events) {
              index = events.findIndex((item) => item.listener === listener);
              if (index > -1)
                events.splice(index, 1);
              if (!events.length)
                delete map[type2];
            }
          }
        });
      } else {
        const { __bubbleMap: b, __captureMap: c2 } = this;
        typeList.forEach((type2) => {
          if (b)
            delete b[type2];
          if (c2)
            delete c2[type2];
        });
      }
    } else {
      this.__bubbleMap = this.__captureMap = void 0;
    }
  }
  on_(type, listener, bind, options) {
    if (bind)
      listener = listener.bind(bind);
    this.on(type, listener, options);
    return { type, current: this, listener, options };
  }
  off_(id) {
    if (!id)
      return;
    const list2 = id instanceof Array ? id : [id];
    list2.forEach((item) => item.current.off(item.type, item.listener, item.options));
    list2.length = 0;
  }
  once(type, listener, capture) {
    this.on(type, listener, { once: true, capture });
  }
  emit(type, event, capture) {
    if (!event && EventCreator.has(type))
      event = EventCreator.get(type, { type, target: this, current: this });
    const map = __getListenerMap(this, capture);
    const list2 = map[type];
    if (list2) {
      let item;
      for (let i = 0, len = list2.length; i < len; i++) {
        item = list2[i];
        item.listener(event);
        if (item.once) {
          this.off(type, item.listener, capture);
          i--, len--;
        }
        if (event && event.isStopNow)
          break;
      }
    }
    this.syncEventer && this.syncEventer.emitEvent(event, capture);
  }
  emitEvent(event, capture) {
    event.current = this;
    this.emit(event.type, event, capture);
  }
  hasEvent(type, capture) {
    if (this.syncEventer && this.syncEventer.hasEvent(type, capture))
      return true;
    const { __bubbleMap: b, __captureMap: c2 } = this;
    const hasB = b && b[type], hasC = c2 && c2[type];
    return !!(capture === void 0 ? hasB || hasC : capture ? hasC : hasB);
  }
  destroy() {
    this.__captureMap = this.__bubbleMap = this.syncEventer = null;
  }
};
function __getListenerMap(eventer, capture, create2) {
  if (capture) {
    const { __captureMap: c2 } = eventer;
    if (c2) {
      return c2;
    } else {
      return create2 ? eventer.__captureMap = {} : empty;
    }
  } else {
    const { __bubbleMap: b } = eventer;
    if (b) {
      return b;
    } else {
      return create2 ? eventer.__bubbleMap = {} : empty;
    }
  }
}
var { on, on_, off, off_, once, emit, emitEvent, hasEvent, destroy } = Eventer.prototype;
var LeafEventer = { on, on_, off, off_, once, emit, emitEvent, hasEvent, destroyEventer: destroy };
var { isFinite } = Number;
var debug = Debug.get("setAttr");
var LeafDataProxy = {
  __setAttr(name, newValue, checkFiniteNumber) {
    if (this.leaferIsCreated) {
      const oldValue = this.__.__getInput(name);
      if (checkFiniteNumber && !isFinite(newValue) && newValue !== void 0) {
        debug.warn(this.innerName, name, newValue);
        newValue = void 0;
      }
      if (typeof newValue === "object" || oldValue !== newValue) {
        this.__realSetAttr(name, newValue);
        const { CHANGE } = PropertyEvent;
        const event = new PropertyEvent(CHANGE, this, name, oldValue, newValue);
        if (this.isLeafer) {
          this.emitEvent(new PropertyEvent(PropertyEvent.LEAFER_CHANGE, this, name, oldValue, newValue));
        } else {
          if (this.hasEvent(CHANGE))
            this.emitEvent(event);
        }
        this.leafer.emitEvent(event);
        return true;
      } else {
        return false;
      }
    } else {
      this.__realSetAttr(name, newValue);
      return true;
    }
  },
  __realSetAttr(name, newValue) {
    const data = this.__;
    data[name] = newValue;
    if (this.__proxyData)
      this.setProxyAttr(name, newValue);
    if (data.normalStyle)
      this.lockNormalStyle || data.normalStyle[name] === void 0 || (data.normalStyle[name] = newValue);
  },
  __getAttr(name) {
    if (this.__proxyData)
      return this.getProxyAttr(name);
    return this.__.__get(name);
  }
};
var { setLayout, multiplyParent: multiplyParent$1, translateInner, defaultWorld } = MatrixHelper;
var { toPoint, tempPoint } = AroundHelper;
var LeafMatrix = {
  __updateWorldMatrix() {
    multiplyParent$1(this.__local || this.__layout, this.parent ? this.parent.__world : defaultWorld, this.__world, !!this.__layout.affectScaleOrRotation, this.__, this.parent && this.parent.__);
  },
  __updateLocalMatrix() {
    if (this.__local) {
      const layout = this.__layout, local = this.__local, data = this.__;
      if (layout.affectScaleOrRotation) {
        if (layout.scaleChanged || layout.rotationChanged) {
          setLayout(local, data, null, null, layout.affectRotation);
          layout.scaleChanged = layout.rotationChanged = false;
        }
      }
      local.e = data.x + data.offsetX;
      local.f = data.y + data.offsetY;
      if (data.around || data.origin) {
        toPoint(data.around || data.origin, layout.boxBounds, tempPoint);
        translateInner(local, -tempPoint.x, -tempPoint.y, !data.around);
      }
    }
    this.__layout.matrixChanged = false;
  }
};
var { updateMatrix, updateAllMatrix } = LeafHelper;
var { updateBounds } = BranchHelper;
var { toOuterOf: toOuterOf$1, copyAndSpread, copy: copy$1 } = BoundsHelper;
var { toBounds } = PathBounds;
var LeafBounds = {
  __updateWorldBounds() {
    toOuterOf$1(this.__layout.renderBounds, this.__world, this.__world);
    if (this.__layout.resized) {
      this.__onUpdateSize();
      this.__layout.resized = false;
    }
  },
  __updateLocalBounds() {
    const layout = this.__layout;
    if (layout.boxChanged) {
      if (!this.__.__pathInputed)
        this.__updatePath();
      this.__updateRenderPath();
      this.__updateBoxBounds();
      layout.resized = true;
    }
    if (layout.localBoxChanged) {
      if (this.__local)
        this.__updateLocalBoxBounds();
      layout.localBoxChanged = false;
      if (layout.strokeSpread)
        layout.strokeChanged = true;
      if (layout.renderSpread)
        layout.renderChanged = true;
      if (this.parent)
        this.parent.__layout.boxChange();
    }
    layout.boxChanged = false;
    if (layout.strokeChanged) {
      layout.strokeSpread = this.__updateStrokeSpread();
      if (layout.strokeSpread) {
        if (layout.strokeBounds === layout.boxBounds)
          layout.spreadStroke();
        this.__updateStrokeBounds();
        this.__updateLocalStrokeBounds();
      } else {
        layout.spreadStrokeCancel();
      }
      layout.strokeChanged = false;
      if (layout.renderSpread || layout.strokeSpread !== layout.strokeBoxSpread)
        layout.renderChanged = true;
      if (this.parent)
        this.parent.__layout.strokeChange();
      layout.resized = true;
    }
    if (layout.renderChanged) {
      layout.renderSpread = this.__updateRenderSpread();
      if (layout.renderSpread) {
        if (layout.renderBounds === layout.boxBounds || layout.renderBounds === layout.strokeBounds)
          layout.spreadRender();
        this.__updateRenderBounds();
        this.__updateLocalRenderBounds();
      } else {
        layout.spreadRenderCancel();
      }
      layout.renderChanged = false;
      if (this.parent)
        this.parent.__layout.renderChange();
    }
    layout.boundsChanged = false;
  },
  __updateLocalBoxBounds() {
    if (this.__hasMotionPath)
      this.__updateMotionPath();
    if (this.__hasAutoLayout)
      this.__updateAutoLayout();
    toOuterOf$1(this.__layout.boxBounds, this.__local, this.__local);
  },
  __updateLocalStrokeBounds() {
    toOuterOf$1(this.__layout.strokeBounds, this.__localMatrix, this.__layout.localStrokeBounds);
  },
  __updateLocalRenderBounds() {
    toOuterOf$1(this.__layout.renderBounds, this.__localMatrix, this.__layout.localRenderBounds);
  },
  __updateBoxBounds() {
    const b = this.__layout.boxBounds;
    const data = this.__;
    if (data.__pathInputed) {
      toBounds(data.path, b);
    } else {
      b.x = 0;
      b.y = 0;
      b.width = data.width;
      b.height = data.height;
    }
  },
  __updateAutoLayout() {
    this.__layout.matrixChanged = true;
    if (this.isBranch) {
      if (this.leaferIsReady)
        this.leafer.layouter.addExtra(this);
      if (this.__.flow) {
        if (this.__layout.boxChanged)
          this.__updateFlowLayout();
        updateAllMatrix(this);
        updateBounds(this, this);
        if (this.__.__autoSide)
          this.__updateBoxBounds(true);
      } else {
        updateAllMatrix(this);
        updateBounds(this, this);
      }
    } else {
      updateMatrix(this);
    }
  },
  __updateNaturalSize() {
    const { __: data, __layout: layout } = this;
    data.__naturalWidth = layout.boxBounds.width;
    data.__naturalHeight = layout.boxBounds.height;
  },
  __updateStrokeBounds() {
    const layout = this.__layout;
    copyAndSpread(layout.strokeBounds, layout.boxBounds, layout.strokeBoxSpread);
  },
  __updateRenderBounds() {
    const layout = this.__layout;
    layout.renderSpread > 0 ? copyAndSpread(layout.renderBounds, layout.boxBounds, layout.renderSpread) : copy$1(layout.renderBounds, layout.strokeBounds);
  }
};
var LeafRender = {
  __render(canvas, options) {
    if (this.__worldOpacity) {
      canvas.setWorld(this.__nowWorld = this.__getNowWorld(options));
      canvas.opacity = this.__.opacity;
      if (this.__.__single) {
        if (this.__.eraser === "path")
          return this.__renderEraser(canvas, options);
        const tempCanvas = canvas.getSameCanvas(true, true);
        this.__draw(tempCanvas, options);
        if (this.__worldFlipped) {
          canvas.copyWorldByReset(tempCanvas, this.__nowWorld, null, this.__.__blendMode, true);
        } else {
          canvas.copyWorldToInner(tempCanvas, this.__nowWorld, this.__layout.renderBounds, this.__.__blendMode);
        }
        tempCanvas.recycle(this.__nowWorld);
      } else {
        this.__draw(canvas, options);
      }
    }
  },
  __clip(canvas, options) {
    if (this.__worldOpacity) {
      canvas.setWorld(this.__nowWorld = this.__getNowWorld(options));
      this.__drawRenderPath(canvas);
      this.windingRule ? canvas.clip(this.windingRule) : canvas.clip();
    }
  },
  __updateWorldOpacity() {
    this.__worldOpacity = this.__.visible ? this.parent ? this.parent.__worldOpacity * this.__.opacity : this.__.opacity : 0;
    if (this.__layout.opacityChanged)
      this.__layout.opacityChanged = false;
  }
};
var { excludeRenderBounds } = LeafBoundsHelper;
var BranchRender = {
  __updateChange() {
    const { __layout: layout } = this;
    if (layout.childrenSortChanged) {
      this.__updateSortChildren();
      layout.childrenSortChanged = false;
    }
    this.__.__checkSingle();
  },
  __render(canvas, options) {
    this.__nowWorld = this.__getNowWorld(options);
    if (this.__worldOpacity) {
      if (this.__.__single) {
        if (this.__.eraser === "path")
          return this.__renderEraser(canvas, options);
        const tempCanvas = canvas.getSameCanvas(false, true);
        this.__renderBranch(tempCanvas, options);
        const nowWorld = this.__nowWorld;
        canvas.opacity = this.__.opacity;
        canvas.copyWorldByReset(tempCanvas, nowWorld, nowWorld, this.__.__blendMode, true);
        tempCanvas.recycle(nowWorld);
      } else {
        this.__renderBranch(canvas, options);
      }
    }
  },
  __renderBranch(canvas, options) {
    if (this.__hasMask) {
      this.__renderMask(canvas, options);
    } else {
      const { children } = this;
      for (let i = 0, len = children.length; i < len; i++) {
        if (excludeRenderBounds(children[i], options))
          continue;
        children[i].__render(canvas, options);
      }
    }
  },
  __clip(canvas, options) {
    if (this.__worldOpacity) {
      const { children } = this;
      for (let i = 0, len = children.length; i < len; i++) {
        if (excludeRenderBounds(children[i], options))
          continue;
        children[i].__clip(canvas, options);
      }
    }
  }
};
var { LEAF, create } = IncrementId;
var { toInnerPoint, toOuterPoint, multiplyParent } = MatrixHelper;
var { toOuterOf } = BoundsHelper;
var { copy, move } = PointHelper;
var { moveLocal, zoomOfLocal, rotateOfLocal, skewOfLocal, moveWorld, zoomOfWorld, rotateOfWorld, skewOfWorld, transform, transformWorld, setTransform, getFlipTransform, getLocalOrigin, getRelativeWorld, drop } = LeafHelper;
var Leaf = class Leaf2 {
  get tag() {
    return this.__tag;
  }
  set tag(_value) {
  }
  get __tag() {
    return "Leaf";
  }
  get innerName() {
    return this.__.name || this.tag + this.innerId;
  }
  get __DataProcessor() {
    return LeafData;
  }
  get __LayoutProcessor() {
    return LeafLayout;
  }
  get leaferIsCreated() {
    return this.leafer && this.leafer.created;
  }
  get leaferIsReady() {
    return this.leafer && this.leafer.ready;
  }
  get isLeafer() {
    return false;
  }
  get isBranch() {
    return false;
  }
  get isBranchLeaf() {
    return false;
  }
  get __localMatrix() {
    return this.__local || this.__layout;
  }
  get __localBoxBounds() {
    return this.__local || this.__layout;
  }
  get worldTransform() {
    return this.__layout.getTransform("world");
  }
  get localTransform() {
    return this.__layout.getTransform("local");
  }
  get boxBounds() {
    return this.getBounds("box", "inner");
  }
  get renderBounds() {
    return this.getBounds("render", "inner");
  }
  get worldBoxBounds() {
    return this.getBounds("box");
  }
  get worldStrokeBounds() {
    return this.getBounds("stroke");
  }
  get worldRenderBounds() {
    return this.getBounds("render");
  }
  get worldOpacity() {
    this.__layout.update();
    return this.__worldOpacity;
  }
  get __worldFlipped() {
    return this.__world.scaleX < 0 || this.__world.scaleY < 0;
  }
  get __onlyHitMask() {
    return this.__hasMask && !this.__.hitChildren;
  }
  get __ignoreHitWorld() {
    return (this.__hasMask || this.__hasEraser) && this.__.hitChildren;
  }
  get __inLazyBounds() {
    const { leafer } = this;
    return leafer && leafer.created && leafer.lazyBounds.hit(this.__world);
  }
  get pathInputed() {
    return this.__.__pathInputed;
  }
  set event(map) {
    this.on(map);
  }
  constructor(data) {
    this.innerId = create(LEAF);
    this.reset(data);
    if (this.__bubbleMap)
      this.__emitLifeEvent(ChildEvent.CREATED);
  }
  reset(data) {
    if (this.leafer)
      this.leafer.forceRender(this.__world);
    this.__world = { a: 1, b: 0, c: 0, d: 1, e: 0, f: 0, x: 0, y: 0, width: 0, height: 0, scaleX: 1, scaleY: 1 };
    if (data !== null)
      this.__local = { a: 1, b: 0, c: 0, d: 1, e: 0, f: 0, x: 0, y: 0, width: 0, height: 0 };
    this.__worldOpacity = 1;
    this.__ = new this.__DataProcessor(this);
    this.__layout = new this.__LayoutProcessor(this);
    if (this.__level)
      this.resetCustom();
    if (data) {
      if (data.__)
        data = data.toJSON();
      data.children ? this.set(data) : Object.assign(this, data);
    }
  }
  resetCustom() {
    this.__hasMask = this.__hasEraser = null;
    this.forceUpdate();
  }
  waitParent(item, bind) {
    if (bind)
      item = item.bind(bind);
    this.parent ? item() : this.on(ChildEvent.ADD, item, "once");
  }
  waitLeafer(item, bind) {
    if (bind)
      item = item.bind(bind);
    this.leafer ? item() : this.on(ChildEvent.MOUNTED, item, "once");
  }
  nextRender(item, bind, off2) {
    this.leafer ? this.leafer.nextRender(item, bind, off2) : this.waitLeafer(() => this.leafer.nextRender(item, bind, off2));
  }
  removeNextRender(item) {
    this.nextRender(item, null, "off");
  }
  __bindLeafer(leafer) {
    if (this.isLeafer && leafer !== null)
      leafer = this;
    if (this.leafer && !leafer)
      this.leafer.leafs--;
    this.leafer = leafer;
    if (leafer) {
      leafer.leafs++;
      this.__level = this.parent ? this.parent.__level + 1 : 1;
      if (this.animation)
        this.__runAnimation("in");
      if (this.__bubbleMap)
        this.__emitLifeEvent(ChildEvent.MOUNTED);
    } else {
      this.__emitLifeEvent(ChildEvent.UNMOUNTED);
    }
    if (this.isBranch) {
      const { children } = this;
      for (let i = 0, len = children.length; i < len; i++) {
        children[i].__bindLeafer(leafer);
      }
    }
  }
  set(_data, _isTemp) {
  }
  get(_name) {
    return void 0;
  }
  setAttr(name, value) {
    this[name] = value;
  }
  getAttr(name) {
    return this[name];
  }
  getComputedAttr(name) {
    return this.__[name];
  }
  toJSON(options) {
    if (options)
      this.__layout.update();
    return this.__.__getInputData(null, options);
  }
  toString(options) {
    return JSON.stringify(this.toJSON(options));
  }
  toSVG() {
    return void 0;
  }
  __SVG(_data) {
  }
  toHTML() {
    return void 0;
  }
  __setAttr(_attrName, _newValue) {
    return true;
  }
  __getAttr(_attrName) {
    return void 0;
  }
  setProxyAttr(_attrName, _newValue) {
  }
  getProxyAttr(_attrName) {
    return void 0;
  }
  find(_condition, _options) {
    return void 0;
  }
  findTag(_tag) {
    return void 0;
  }
  findOne(_condition, _options) {
    return void 0;
  }
  findId(_id) {
    return void 0;
  }
  focus(_value) {
  }
  updateState() {
  }
  updateLayout() {
    this.__layout.update();
  }
  forceUpdate(attrName) {
    if (attrName === void 0)
      attrName = "width";
    else if (attrName === "surface")
      attrName = "blendMode";
    const value = this.__.__getInput(attrName);
    this.__[attrName] = value === void 0 ? null : void 0;
    this[attrName] = value;
  }
  forceRender(_bounds) {
    this.forceUpdate("surface");
  }
  __updateWorldMatrix() {
  }
  __updateLocalMatrix() {
  }
  __updateWorldBounds() {
  }
  __updateLocalBounds() {
  }
  __updateLocalBoxBounds() {
  }
  __updateLocalStrokeBounds() {
  }
  __updateLocalRenderBounds() {
  }
  __updateBoxBounds() {
  }
  __updateContentBounds() {
  }
  __updateStrokeBounds() {
  }
  __updateRenderBounds() {
  }
  __updateAutoLayout() {
  }
  __updateFlowLayout() {
  }
  __updateNaturalSize() {
  }
  __updateStrokeSpread() {
    return 0;
  }
  __updateRenderSpread() {
    return 0;
  }
  __onUpdateSize() {
  }
  __updateEraser(value) {
    this.__hasEraser = value ? true : this.children.some((item) => item.__.eraser);
  }
  __renderEraser(canvas, options) {
    canvas.save();
    this.__clip(canvas, options);
    const { renderBounds: r } = this.__layout;
    canvas.clearRect(r.x, r.y, r.width, r.height);
    canvas.restore();
  }
  __updateMask(value) {
    this.__hasMask = value ? true : this.children.some((item) => item.__.mask);
  }
  __renderMask(_canvas, _options) {
  }
  __getNowWorld(options) {
    if (options.matrix) {
      if (!this.__cameraWorld)
        this.__cameraWorld = {};
      const cameraWorld = this.__cameraWorld;
      multiplyParent(this.__world, options.matrix, cameraWorld, void 0, this.__world);
      toOuterOf(this.__layout.renderBounds, cameraWorld, cameraWorld);
      return cameraWorld;
    } else {
      return this.__world;
    }
  }
  getTransform(relative) {
    return this.__layout.getTransform(relative || "local");
  }
  getBounds(type, relative) {
    return this.__layout.getBounds(type, relative);
  }
  getLayoutBounds(type, relative, unscale) {
    return this.__layout.getLayoutBounds(type, relative, unscale);
  }
  getLayoutPoints(type, relative) {
    return this.__layout.getLayoutPoints(type, relative);
  }
  getWorldBounds(inner, relative, change) {
    const matrix2 = relative ? getRelativeWorld(this, relative) : this.worldTransform;
    const to = change ? inner : {};
    toOuterOf(inner, matrix2, to);
    return to;
  }
  worldToLocal(world, to, distance, relative) {
    if (this.parent) {
      this.parent.worldToInner(world, to, distance, relative);
    } else {
      if (to)
        copy(to, world);
    }
  }
  localToWorld(local, to, distance, relative) {
    if (this.parent) {
      this.parent.innerToWorld(local, to, distance, relative);
    } else {
      if (to)
        copy(to, local);
    }
  }
  worldToInner(world, to, distance, relative) {
    if (relative) {
      relative.innerToWorld(world, to, distance);
      world = to ? to : world;
    }
    toInnerPoint(this.worldTransform, world, to, distance);
  }
  innerToWorld(inner, to, distance, relative) {
    toOuterPoint(this.worldTransform, inner, to, distance);
    if (relative)
      relative.worldToInner(to ? to : inner, null, distance);
  }
  getBoxPoint(world, relative, distance, change) {
    return this.getBoxPointByInner(this.getInnerPoint(world, relative, distance, change), null, null, true);
  }
  getBoxPointByInner(inner, _relative, _distance, change) {
    const point2 = change ? inner : Object.assign({}, inner), { x, y } = this.boxBounds;
    move(point2, -x, -y);
    return point2;
  }
  getInnerPoint(world, relative, distance, change) {
    const point2 = change ? world : {};
    this.worldToInner(world, point2, distance, relative);
    return point2;
  }
  getInnerPointByBox(box, _relative, _distance, change) {
    const point2 = change ? box : Object.assign({}, box), { x, y } = this.boxBounds;
    move(point2, x, y);
    return point2;
  }
  getInnerPointByLocal(local, _relative, distance, change) {
    return this.getInnerPoint(local, this.parent, distance, change);
  }
  getLocalPoint(world, relative, distance, change) {
    const point2 = change ? world : {};
    this.worldToLocal(world, point2, distance, relative);
    return point2;
  }
  getLocalPointByInner(inner, _relative, distance, change) {
    return this.getWorldPoint(inner, this.parent, distance, change);
  }
  getPagePoint(world, relative, distance, change) {
    const layer = this.leafer ? this.leafer.zoomLayer : this;
    return layer.getInnerPoint(world, relative, distance, change);
  }
  getWorldPoint(inner, relative, distance, change) {
    const point2 = change ? inner : {};
    this.innerToWorld(inner, point2, distance, relative);
    return point2;
  }
  getWorldPointByBox(box, relative, distance, change) {
    return this.getWorldPoint(this.getInnerPointByBox(box, null, null, change), relative, distance, true);
  }
  getWorldPointByLocal(local, relative, distance, change) {
    const point2 = change ? local : {};
    this.localToWorld(local, point2, distance, relative);
    return point2;
  }
  getWorldPointByPage(page, relative, distance, change) {
    const layer = this.leafer ? this.leafer.zoomLayer : this;
    return layer.getWorldPoint(page, relative, distance, change);
  }
  setTransform(matrix2, resize) {
    setTransform(this, matrix2, resize);
  }
  transform(matrix2, resize) {
    transform(this, matrix2, resize);
  }
  move(x, y) {
    moveLocal(this, x, y);
  }
  moveInner(x, y) {
    moveWorld(this, x, y, true);
  }
  scaleOf(origin, scaleX, scaleY, resize) {
    zoomOfLocal(this, getLocalOrigin(this, origin), scaleX, scaleY, resize);
  }
  rotateOf(origin, rotation) {
    rotateOfLocal(this, getLocalOrigin(this, origin), rotation);
  }
  skewOf(origin, skewX, skewY, resize) {
    skewOfLocal(this, getLocalOrigin(this, origin), skewX, skewY, resize);
  }
  transformWorld(worldTransform, resize) {
    transformWorld(this, worldTransform, resize);
  }
  moveWorld(x, y) {
    moveWorld(this, x, y);
  }
  scaleOfWorld(worldOrigin, scaleX, scaleY, resize) {
    zoomOfWorld(this, worldOrigin, scaleX, scaleY, resize);
  }
  rotateOfWorld(worldOrigin, rotation) {
    rotateOfWorld(this, worldOrigin, rotation);
  }
  skewOfWorld(worldOrigin, skewX, skewY, resize) {
    skewOfWorld(this, worldOrigin, skewX, skewY, resize);
  }
  flip(axis) {
    transform(this, getFlipTransform(this, axis));
  }
  scaleResize(scaleX, scaleY = scaleX, _noResize) {
    this.scaleX *= scaleX;
    this.scaleY *= scaleY;
  }
  __scaleResize(_scaleX, _scaleY) {
  }
  resizeWidth(_width) {
  }
  resizeHeight(_height) {
  }
  __hitWorld(_point) {
    return true;
  }
  __hit(_local) {
    return true;
  }
  __hitFill(_inner) {
    return true;
  }
  __hitStroke(_inner, _strokeWidth) {
    return true;
  }
  __hitPixel(_inner) {
    return true;
  }
  __drawHitPath(_canvas) {
  }
  __updateHitCanvas() {
  }
  __render(_canvas, _options) {
  }
  __drawFast(_canvas, _options) {
  }
  __draw(_canvas, _options) {
  }
  __clip(_canvas, _options) {
  }
  __renderShape(_canvas, _options, _ignoreFill, _ignoreStroke) {
  }
  __updateWorldOpacity() {
  }
  __updateChange() {
  }
  __drawPath(_canvas) {
  }
  __drawRenderPath(_canvas) {
  }
  __updatePath() {
  }
  __updateRenderPath() {
  }
  getMotionPathData() {
    return needPlugin("path");
  }
  getMotionPoint(_motionDistance) {
    return needPlugin("path");
  }
  getMotionTotal() {
    return 0;
  }
  __updateMotionPath() {
  }
  __runAnimation(_type, _complete) {
  }
  __updateSortChildren() {
  }
  add(_child, _index) {
  }
  remove(_child, destroy2) {
    if (this.parent)
      this.parent.remove(this, destroy2);
  }
  dropTo(parent, index, resize) {
    drop(this, parent, index, resize);
  }
  on(_type, _listener, _options) {
  }
  off(_type, _listener, _options) {
  }
  on_(_type, _listener, _bind, _options) {
    return void 0;
  }
  off_(_id) {
  }
  once(_type, _listener, _capture) {
  }
  emit(_type, _event, _capture) {
  }
  emitEvent(_event, _capture) {
  }
  hasEvent(_type, _capture) {
    return false;
  }
  static changeAttr(attrName, defaultValue, fn) {
    fn ? this.addAttr(attrName, defaultValue, fn) : defineDataProcessor(this.prototype, attrName, defaultValue);
  }
  static addAttr(attrName, defaultValue, fn) {
    if (!fn)
      fn = boundsType;
    fn(defaultValue)(this.prototype, attrName);
  }
  __emitLifeEvent(type) {
    if (this.hasEvent(type))
      this.emitEvent(new ChildEvent(type, this, this.parent));
  }
  destroy() {
    if (!this.destroyed) {
      if (this.parent)
        this.remove();
      if (this.children)
        this.clear();
      this.__emitLifeEvent(ChildEvent.DESTROY);
      this.__.destroy();
      this.__layout.destroy();
      this.destroyEventer();
      this.destroyed = true;
    }
  }
};
Leaf = __decorate([
  useModule(LeafDataProxy),
  useModule(LeafMatrix),
  useModule(LeafBounds),
  useModule(LeafEventer),
  useModule(LeafRender)
], Leaf);
var { setListWithFn } = BoundsHelper;
var { sort } = BranchHelper;
var { localBoxBounds, localStrokeBounds, localRenderBounds, maskLocalBoxBounds, maskLocalStrokeBounds, maskLocalRenderBounds } = LeafBoundsHelper;
var Branch = class Branch2 extends Leaf {
  __updateStrokeSpread() {
    const { children } = this;
    for (let i = 0, len = children.length; i < len; i++) {
      if (children[i].__layout.strokeSpread)
        return 1;
    }
    return 0;
  }
  __updateRenderSpread() {
    const { children } = this;
    for (let i = 0, len = children.length; i < len; i++) {
      if (children[i].__layout.renderSpread)
        return 1;
    }
    return 0;
  }
  __updateBoxBounds() {
    setListWithFn(this.__layout.boxBounds, this.children, this.__hasMask ? maskLocalBoxBounds : localBoxBounds);
  }
  __updateStrokeBounds() {
    setListWithFn(this.__layout.strokeBounds, this.children, this.__hasMask ? maskLocalStrokeBounds : localStrokeBounds);
  }
  __updateRenderBounds() {
    setListWithFn(this.__layout.renderBounds, this.children, this.__hasMask ? maskLocalRenderBounds : localRenderBounds);
  }
  __updateSortChildren() {
    let affectSort;
    const { children } = this;
    if (children.length > 1) {
      for (let i = 0, len = children.length; i < len; i++) {
        children[i].__tempNumber = i;
        if (children[i].__.zIndex)
          affectSort = true;
      }
      children.sort(sort);
      this.__layout.affectChildrenSort = affectSort;
    }
  }
  add(child, index) {
    if (child === this)
      return;
    const noIndex = index === void 0;
    if (!child.__) {
      if (child instanceof Array)
        return child.forEach((item) => {
          this.add(item, index);
          noIndex || index++;
        });
      else
        child = UICreator.get(child.tag, child);
    }
    if (child.parent)
      child.parent.remove(child);
    child.parent = this;
    noIndex ? this.children.push(child) : this.children.splice(index, 0, child);
    if (child.isBranch)
      this.__.__childBranchNumber = (this.__.__childBranchNumber || 0) + 1;
    child.__layout.boxChanged || child.__layout.boxChange();
    child.__layout.matrixChanged || child.__layout.matrixChange();
    if (child.__bubbleMap)
      child.__emitLifeEvent(ChildEvent.ADD);
    if (this.leafer) {
      child.__bindLeafer(this.leafer);
      if (this.leafer.created)
        this.__emitChildEvent(ChildEvent.ADD, child);
    }
    this.__layout.affectChildrenSort && this.__layout.childrenSortChange();
  }
  addMany(...children) {
    this.add(children);
  }
  remove(child, destroy2) {
    if (child) {
      if (child.__) {
        if (child.animationOut)
          child.__runAnimation("out", () => this.__remove(child, destroy2));
        else
          this.__remove(child, destroy2);
      } else
        this.find(child).forEach((item) => this.remove(item, destroy2));
    } else if (child === void 0) {
      super.remove(null, destroy2);
    }
  }
  removeAll(destroy2) {
    const { children } = this;
    if (children.length) {
      this.children = [];
      this.__preRemove();
      this.__.__childBranchNumber = 0;
      children.forEach((child) => {
        this.__realRemoveChild(child);
        if (destroy2)
          child.destroy();
      });
    }
  }
  clear() {
    this.removeAll(true);
  }
  __remove(child, destroy2) {
    const index = this.children.indexOf(child);
    if (index > -1) {
      this.children.splice(index, 1);
      if (child.isBranch)
        this.__.__childBranchNumber = (this.__.__childBranchNumber || 1) - 1;
      this.__preRemove();
      this.__realRemoveChild(child);
      if (destroy2)
        child.destroy();
    }
  }
  __preRemove() {
    if (this.__hasMask)
      this.__updateMask();
    if (this.__hasEraser)
      this.__updateEraser();
    this.__layout.boxChange();
    this.__layout.affectChildrenSort && this.__layout.childrenSortChange();
  }
  __realRemoveChild(child) {
    child.__emitLifeEvent(ChildEvent.REMOVE);
    child.parent = null;
    if (this.leafer) {
      child.__bindLeafer(null);
      if (this.leafer.created) {
        this.__emitChildEvent(ChildEvent.REMOVE, child);
        if (this.leafer.hitCanvasManager)
          this.leafer.hitCanvasManager.clear();
      }
    }
  }
  __emitChildEvent(type, child) {
    const event = new ChildEvent(type, child, this);
    if (this.hasEvent(type) && !this.isLeafer)
      this.emitEvent(event);
    this.leafer.emitEvent(event);
  }
};
Branch = __decorate([
  useModule(BranchRender)
], Branch);
var LeafList = class _LeafList {
  get length() {
    return this.list.length;
  }
  constructor(item) {
    this.reset();
    if (item)
      item instanceof Array ? this.addList(item) : this.add(item);
  }
  has(leaf) {
    return leaf && this.keys[leaf.innerId] !== void 0;
  }
  indexAt(index) {
    return this.list[index];
  }
  indexOf(leaf) {
    const index = this.keys[leaf.innerId];
    return index === void 0 ? -1 : index;
  }
  add(leaf) {
    const { list: list2, keys } = this;
    if (keys[leaf.innerId] === void 0) {
      list2.push(leaf);
      keys[leaf.innerId] = list2.length - 1;
    }
  }
  addAt(leaf, index = 0) {
    const { keys } = this;
    if (keys[leaf.innerId] === void 0) {
      const { list: list2 } = this;
      for (let i = index, len = list2.length; i < len; i++)
        keys[list2[i].innerId]++;
      if (index === 0) {
        list2.unshift(leaf);
      } else {
        if (index > list2.length)
          index = list2.length;
        list2.splice(index, 0, leaf);
      }
      keys[leaf.innerId] = index;
    }
  }
  addList(list2) {
    for (let i = 0; i < list2.length; i++)
      this.add(list2[i]);
  }
  remove(leaf) {
    const { list: list2 } = this;
    let findIndex;
    for (let i = 0, len = list2.length; i < len; i++) {
      if (findIndex !== void 0) {
        this.keys[list2[i].innerId] = i - 1;
      } else if (list2[i].innerId === leaf.innerId) {
        findIndex = i;
        delete this.keys[leaf.innerId];
      }
    }
    if (findIndex !== void 0)
      list2.splice(findIndex, 1);
  }
  sort(reverse) {
    const { list: list2 } = this;
    if (reverse) {
      list2.sort((a2, b) => b.__level - a2.__level);
    } else {
      list2.sort((a2, b) => a2.__level - b.__level);
    }
  }
  forEach(itemCallback) {
    this.list.forEach(itemCallback);
  }
  clone() {
    const list2 = new _LeafList();
    list2.list = [...this.list];
    list2.keys = Object.assign({}, this.keys);
    return list2;
  }
  update() {
    this.keys = {};
    const { list: list2, keys } = this;
    for (let i = 0, len = list2.length; i < len; i++)
      keys[list2[i].innerId] = i;
  }
  reset() {
    this.list = [];
    this.keys = {};
  }
  destroy() {
    this.reset();
  }
};
var LeafLevelList = class {
  get length() {
    return this._length;
  }
  constructor(item) {
    this._length = 0;
    this.reset();
    if (item)
      item instanceof Array ? this.addList(item) : this.add(item);
  }
  has(leaf) {
    return this.keys[leaf.innerId] !== void 0;
  }
  without(leaf) {
    return this.keys[leaf.innerId] === void 0;
  }
  sort(reverse) {
    const { levels } = this;
    if (reverse) {
      levels.sort((a2, b) => b - a2);
    } else {
      levels.sort((a2, b) => a2 - b);
    }
  }
  addList(list2) {
    list2.forEach((leaf) => {
      this.add(leaf);
    });
  }
  add(leaf) {
    const { keys, levelMap } = this;
    if (!keys[leaf.innerId]) {
      keys[leaf.innerId] = 1;
      if (!levelMap[leaf.__level]) {
        levelMap[leaf.__level] = [leaf];
        this.levels.push(leaf.__level);
      } else {
        levelMap[leaf.__level].push(leaf);
      }
      this._length++;
    }
  }
  forEach(itemCallback) {
    let list2;
    this.levels.forEach((level) => {
      list2 = this.levelMap[level];
      for (let i = 0, len = list2.length; i < len; i++) {
        itemCallback(list2[i]);
      }
    });
  }
  reset() {
    this.levelMap = {};
    this.keys = {};
    this.levels = [];
    this._length = 0;
  }
  destroy() {
    this.levelMap = null;
  }
};
var version = "1.0.10";

// node_modules/.pnpm/@leafer-ui+draw@1.0.10/node_modules/@leafer-ui/draw/lib/draw.esm.js
function __decorate2(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
}
function effectType(defaultValue) {
  return decorateLeafAttr(defaultValue, (key) => attr({
    set(value) {
      this.__setAttr(key, value);
      if (value)
        this.__.__useEffect = true;
      this.__layout.renderChanged || this.__layout.renderChange();
    }
  }));
}
function resizeType(defaultValue) {
  return decorateLeafAttr(defaultValue, (key) => attr({
    set(value) {
      this.__setAttr(key, value);
      this.__layout.boxChanged || this.__layout.boxChange();
      this.__updateSize();
    }
  }));
}
function zoomLayerType() {
  return (target, key) => {
    const privateKey = "_" + key;
    defineKey(target, key, {
      set(value) {
        if (this.isLeafer)
          this[privateKey] = value;
      },
      get() {
        return this.isApp ? this.tree.zoomLayer : this.isLeafer ? this[privateKey] || this : this.leafer && this.leafer.zoomLayer;
      }
    });
  };
}
var TextConvert = {};
var ColorConvert = {};
var UnitConvert = {
  number(value, percentRefer) {
    if (typeof value === "object")
      return value.type === "percent" ? value.value * percentRefer : value.value;
    return value;
  }
};
var PathArrow = {};
var Paint = {};
var PaintImage = {};
var PaintGradient = {};
var Effect = {};
var Export = {};
var State = {
  setStyleName(_leaf, _styleName, _value) {
    return needPlugin("state");
  },
  set(_leaf, _stateName) {
    return needPlugin("state");
  }
};
var Transition = {
  list: {},
  register(attrName, fn) {
    Transition.list[attrName] = fn;
  },
  get(attrName) {
    return Transition.list[attrName];
  }
};
var { parse, objectToCanvasData } = PathConvert;
var emptyPaint = {};
var debug$12 = Debug.get("UIData");
var UIData = class extends LeafData {
  get scale() {
    const { scaleX, scaleY } = this;
    return scaleX !== scaleY ? { x: scaleX, y: scaleY } : scaleX;
  }
  get __strokeWidth() {
    const { strokeWidth, strokeWidthFixed } = this;
    if (strokeWidthFixed) {
      const ui = this.__leaf;
      let { scaleX } = ui.__nowWorld || ui.__world;
      if (scaleX < 0)
        scaleX = -scaleX;
      return scaleX > 1 ? strokeWidth / scaleX : strokeWidth;
    } else
      return strokeWidth;
  }
  get __hasStroke() {
    return this.stroke && this.strokeWidth;
  }
  get __hasMultiPaint() {
    const t2 = this;
    if (t2.__isFills && t2.fill.length > 1 || t2.__isStrokes && t2.stroke.length > 1 || t2.__useEffect)
      return true;
    return t2.fill && this.__hasStroke;
  }
  get __clipAfterFill() {
    return this.cornerRadius || this.__pathInputed;
  }
  get __autoWidth() {
    return !this._width;
  }
  get __autoHeight() {
    return !this._height;
  }
  get __autoSide() {
    return !this._width || !this._height;
  }
  get __autoSize() {
    return !this._width && !this._height;
  }
  setVisible(value) {
    this._visible = value;
    const { leafer } = this.__leaf;
    if (leafer)
      leafer.watcher.hasVisible = true;
  }
  setWidth(value) {
    if (value < 0) {
      this._width = -value;
      this.__leaf.scaleX *= -1;
      debug$12.warn("width < 0, instead -scaleX ", this);
    } else
      this._width = value;
  }
  setHeight(value) {
    if (value < 0) {
      this._height = -value;
      this.__leaf.scaleY *= -1;
      debug$12.warn("height < 0, instead -scaleY", this);
    } else
      this._height = value;
  }
  setFill(value) {
    if (this.__naturalWidth)
      this.__removeNaturalSize();
    if (typeof value === "string" || !value) {
      if (this.__isFills) {
        this.__removeInput("fill");
        PaintImage.recycleImage("fill", this);
        this.__isFills = false;
        if (this.__pixelFill)
          this.__pixelFill = false;
      }
      this._fill = value;
    } else if (typeof value === "object") {
      this.__setInput("fill", value);
      this.__leaf.__layout.boxChanged || this.__leaf.__layout.boxChange();
      this.__isFills = true;
      this._fill || (this._fill = emptyPaint);
    }
  }
  setStroke(value) {
    if (typeof value === "string" || !value) {
      if (this.__isStrokes) {
        this.__removeInput("stroke");
        PaintImage.recycleImage("stroke", this);
        this.__isStrokes = false;
        if (this.__pixelStroke)
          this.__pixelStroke = false;
      }
      this._stroke = value;
    } else if (typeof value === "object") {
      this.__setInput("stroke", value);
      this.__leaf.__layout.boxChanged || this.__leaf.__layout.boxChange();
      this.__isStrokes = true;
      this._stroke || (this._stroke = emptyPaint);
    }
  }
  setPath(value) {
    const isString = typeof value === "string";
    if (isString || value && typeof value[0] === "object") {
      this.__setInput("path", value);
      this._path = isString ? parse(value) : objectToCanvasData(value);
    } else {
      if (this.__input)
        this.__removeInput("path");
      this._path = value;
    }
  }
  setShadow(value) {
    this.__setInput("shadow", value);
    if (value instanceof Array) {
      if (value.some((item) => item.visible === false))
        value = value.filter((item) => item.visible !== false);
      this._shadow = value.length ? value : null;
    } else
      this._shadow = value && value.visible !== false ? [value] : null;
  }
  setInnerShadow(value) {
    this.__setInput("innerShadow", value);
    if (value instanceof Array) {
      if (value.some((item) => item.visible === false))
        value = value.filter((item) => item.visible !== false);
      this._innerShadow = value.length ? value : null;
    } else
      this._innerShadow = value && value.visible !== false ? [value] : null;
  }
  __computePaint() {
    const { fill, stroke } = this.__input;
    if (fill)
      Paint.compute("fill", this.__leaf);
    if (stroke)
      Paint.compute("stroke", this.__leaf);
    this.__needComputePaint = false;
  }
};
var GroupData = class extends UIData {
};
var BoxData = class extends GroupData {
  get __boxStroke() {
    return !this.__pathInputed;
  }
  get __drawAfterFill() {
    return this.overflow === "hide" && this.__clipAfterFill && this.__leaf.children.length;
  }
  get __clipAfterFill() {
    return this.__leaf.isOverflow || super.__clipAfterFill;
  }
};
var LeaferData = class extends GroupData {
  __getInputData(names, options) {
    const data = super.__getInputData(names, options);
    canvasSizeAttrs.forEach((key) => delete data[key]);
    return data;
  }
};
var FrameData = class extends BoxData {
};
var LineData = class extends UIData {
};
var RectData = class extends UIData {
  get __boxStroke() {
    return !this.__pathInputed;
  }
};
var EllipseData = class extends UIData {
  get __boxStroke() {
    return !this.__pathInputed;
  }
};
var PolygonData = class extends UIData {
};
var StarData = class extends UIData {
};
var PathData = class extends UIData {
  get __pathInputed() {
    return 2;
  }
};
var PenData = class extends GroupData {
};
var fontWeightMap = {
  "thin": 100,
  "extra-light": 200,
  "light": 300,
  "normal": 400,
  "medium": 500,
  "semi-bold": 600,
  "bold": 700,
  "extra-bold": 800,
  "black": 900
};
var TextData = class extends UIData {
  get __useNaturalRatio() {
    return false;
  }
  setFontWeight(value) {
    if (typeof value === "string") {
      this.__setInput("fontWeight", value);
      this._fontWeight = fontWeightMap[value] || 400;
    } else {
      if (this.__input)
        this.__removeInput("fontWeight");
      this._fontWeight = value;
    }
  }
};
var ImageData = class extends RectData {
  setUrl(value) {
    this.__setImageFill(value);
    this._url = value;
  }
  __setImageFill(value) {
    if (this.__leaf.image)
      this.__leaf.image = null;
    this.fill = value ? { type: "image", mode: "stretch", url: value } : void 0;
  }
  __getData() {
    const data = super.__getData();
    delete data.fill;
    return data;
  }
  __getInputData(names, options) {
    const data = super.__getInputData(names, options);
    delete data.fill;
    return data;
  }
};
var CanvasData = class extends RectData {
  get __isCanvas() {
    return true;
  }
  get __drawAfterFill() {
    return true;
  }
  __getInputData(names, options) {
    const data = super.__getInputData(names, options);
    data.url = this.__leaf.canvas.toDataURL("image/png");
    return data;
  }
};
var UIBounds = {
  __updateStrokeSpread() {
    let width = 0, boxWidth = 0;
    const data = this.__, { strokeAlign, strokeWidth } = data;
    if ((data.stroke || data.hitStroke === "all") && strokeWidth && strokeAlign !== "inside") {
      boxWidth = width = strokeAlign === "center" ? strokeWidth / 2 : strokeWidth;
      if (!data.__boxStroke) {
        const miterLimitAddWidth = data.__isLinePath ? 0 : 10 * width;
        const storkeCapAddWidth = data.strokeCap === "none" ? 0 : strokeWidth;
        width += Math.max(miterLimitAddWidth, storkeCapAddWidth);
      }
    }
    if (data.__useArrow)
      width += strokeWidth * 5;
    this.__layout.strokeBoxSpread = boxWidth;
    return width;
  },
  __updateRenderSpread() {
    let width = 0;
    const { shadow, innerShadow, blur, backgroundBlur } = this.__;
    if (shadow)
      shadow.forEach((item) => width = Math.max(width, Math.max(Math.abs(item.y), Math.abs(item.x)) + (item.spread > 0 ? item.spread : 0) + item.blur * 1.5));
    if (blur)
      width = Math.max(width, blur);
    let shapeWidth = width = Math.ceil(width);
    if (innerShadow)
      innerShadow.forEach((item) => shapeWidth = Math.max(shapeWidth, Math.max(Math.abs(item.y), Math.abs(item.x)) + (item.spread < 0 ? -item.spread : 0) + item.blur * 1.5));
    if (backgroundBlur)
      shapeWidth = Math.max(shapeWidth, backgroundBlur);
    this.__layout.renderShapeSpread = shapeWidth;
    return width + (this.__layout.strokeSpread || 0);
  }
};
var UIRender = {
  __updateChange() {
    const data = this.__;
    if (data.__useEffect) {
      const { shadow, innerShadow, blur, backgroundBlur } = this.__;
      data.__useEffect = !!(shadow || innerShadow || blur || backgroundBlur);
    }
    data.__checkSingle();
    const complex = data.__isFills || data.__isStrokes || data.cornerRadius || data.__useEffect;
    if (complex) {
      data.__complex = true;
    } else {
      data.__complex && (data.__complex = false);
    }
  },
  __drawFast(canvas, options) {
    drawFast(this, canvas, options);
  },
  __draw(canvas, options) {
    const data = this.__;
    if (data.__complex) {
      if (data.__needComputePaint)
        data.__computePaint();
      const { fill, stroke, __drawAfterFill } = data;
      this.__drawRenderPath(canvas);
      if (data.__useEffect) {
        const shape = Paint.shape(this, canvas, options);
        this.__nowWorld = this.__getNowWorld(options);
        const { shadow, innerShadow } = data;
        if (shadow)
          Effect.shadow(this, canvas, shape);
        if (fill)
          data.__isFills ? Paint.fills(fill, this, canvas) : Paint.fill(fill, this, canvas);
        if (__drawAfterFill)
          this.__drawAfterFill(canvas, options);
        if (innerShadow)
          Effect.innerShadow(this, canvas, shape);
        if (stroke)
          data.__isStrokes ? Paint.strokes(stroke, this, canvas) : Paint.stroke(stroke, this, canvas);
        if (shape.worldCanvas)
          shape.worldCanvas.recycle();
        shape.canvas.recycle();
      } else {
        if (fill)
          data.__isFills ? Paint.fills(fill, this, canvas) : Paint.fill(fill, this, canvas);
        if (__drawAfterFill)
          this.__drawAfterFill(canvas, options);
        if (stroke)
          data.__isStrokes ? Paint.strokes(stroke, this, canvas) : Paint.stroke(stroke, this, canvas);
      }
    } else {
      if (data.__pathInputed) {
        drawFast(this, canvas, options);
      } else {
        this.__drawFast(canvas, options);
      }
    }
  },
  __renderShape(canvas, options, ignoreFill, ignoreStroke) {
    if (this.__worldOpacity) {
      canvas.setWorld(this.__nowWorld = this.__getNowWorld(options));
      const { fill, stroke } = this.__;
      this.__drawRenderPath(canvas);
      if (fill && !ignoreFill)
        this.__.__pixelFill ? Paint.fills(fill, this, canvas) : Paint.fill("#000000", this, canvas);
      if (this.__.__isCanvas)
        this.__drawAfterFill(canvas, options);
      if (stroke && !ignoreStroke)
        this.__.__pixelStroke ? Paint.strokes(stroke, this, canvas) : Paint.stroke("#000000", this, canvas);
    }
  },
  __drawAfterFill(canvas, options) {
    if (this.__.__clipAfterFill) {
      canvas.save();
      this.windingRule ? canvas.clip(this.windingRule) : canvas.clip();
      this.__drawContent(canvas, options);
      canvas.restore();
    } else
      this.__drawContent(canvas, options);
  }
};
function drawFast(ui, canvas, options) {
  const { fill, stroke, __drawAfterFill } = ui.__;
  ui.__drawRenderPath(canvas);
  if (fill)
    Paint.fill(fill, ui, canvas);
  if (__drawAfterFill)
    ui.__drawAfterFill(canvas, options);
  if (stroke)
    Paint.stroke(stroke, ui, canvas);
}
var RectRender = {
  __drawFast(canvas, options) {
    let { width, height, fill, stroke, __drawAfterFill } = this.__;
    if (fill) {
      canvas.fillStyle = fill;
      canvas.fillRect(0, 0, width, height);
    }
    if (__drawAfterFill)
      this.__drawAfterFill(canvas, options);
    if (stroke) {
      const { strokeAlign, __strokeWidth } = this.__;
      if (!__strokeWidth)
        return;
      canvas.setStroke(stroke, __strokeWidth, this.__);
      const half = __strokeWidth / 2;
      switch (strokeAlign) {
        case "center":
          canvas.strokeRect(0, 0, width, height);
          break;
        case "inside":
          width -= __strokeWidth, height -= __strokeWidth;
          if (width < 0 || height < 0) {
            canvas.save();
            this.__clip(canvas, options);
            canvas.strokeRect(half, half, width, height);
            canvas.restore();
          } else
            canvas.strokeRect(half, half, width, height);
          break;
        case "outside":
          canvas.strokeRect(-half, -half, width + __strokeWidth, height + __strokeWidth);
          break;
      }
    }
  }
};
var UI_1;
var UI = UI_1 = class UI2 extends Leaf {
  get app() {
    return this.leafer && this.leafer.app;
  }
  get isFrame() {
    return false;
  }
  set scale(value) {
    MathHelper.assignScale(this, value);
  }
  get scale() {
    return this.__.scale;
  }
  get pen() {
    const { path } = this.__;
    pen.set(this.path = path || []);
    if (!path)
      this.__drawPathByBox(pen);
    return pen;
  }
  get editConfig() {
    return void 0;
  }
  get editOuter() {
    return "";
  }
  get editInner() {
    return "";
  }
  constructor(data) {
    super(data);
  }
  reset(_data) {
  }
  set(data, isTemp) {
    if (isTemp) {
      this.lockNormalStyle = true;
      Object.assign(this, data);
      this.lockNormalStyle = false;
    } else
      Object.assign(this, data);
  }
  get(name) {
    return typeof name === "string" ? this.__.__getInput(name) : this.__.__getInputData(name);
  }
  createProxyData() {
    return void 0;
  }
  find(_condition, _options) {
    return void 0;
  }
  findTag(tag) {
    return this.find({ tag });
  }
  findOne(_condition, _options) {
    return void 0;
  }
  findId(id) {
    return this.findOne({ id });
  }
  getPath(curve, pathForRender) {
    this.__layout.update();
    let path = pathForRender ? this.__.__pathForRender : this.__.path;
    if (!path)
      pen.set(path = []), this.__drawPathByBox(pen);
    return curve ? PathConvert.toCanvasData(path, true) : path;
  }
  getPathString(curve, pathForRender, floatLength) {
    return PathConvert.stringify(this.getPath(curve, pathForRender), floatLength);
  }
  load() {
    this.__.__computePaint();
  }
  __onUpdateSize() {
    if (this.__.__input) {
      const data = this.__;
      data.lazy && !this.__inLazyBounds && !Export.running ? data.__needComputePaint = true : data.__computePaint();
    }
  }
  __updateRenderPath() {
    if (this.__.path) {
      const data = this.__;
      data.__pathForRender = data.cornerRadius ? PathCorner.smooth(data.path, data.cornerRadius, data.cornerSmoothing) : data.path;
      if (data.__useArrow)
        PathArrow.addArrows(this, !data.cornerRadius);
    }
  }
  __drawRenderPath(canvas) {
    canvas.beginPath();
    this.__drawPathByData(canvas, this.__.__pathForRender);
  }
  __drawPath(canvas) {
    canvas.beginPath();
    this.__drawPathByData(canvas, this.__.path);
  }
  __drawPathByData(drawer, data) {
    data ? PathDrawer.drawPathByData(drawer, data) : this.__drawPathByBox(drawer);
  }
  __drawPathByBox(drawer) {
    const { x, y, width, height } = this.__layout.boxBounds;
    if (this.__.cornerRadius) {
      const { cornerRadius } = this.__;
      drawer.roundRect(x, y, width, height, typeof cornerRadius === "number" ? [cornerRadius] : cornerRadius);
    } else
      drawer.rect(x, y, width, height);
  }
  animate(_keyframe, _options, _type, _isTemp) {
    return needPlugin("animate");
  }
  killAnimate(_type) {
  }
  export(filename, options) {
    return Export.export(this, filename, options);
  }
  clone(data) {
    const json = this.toJSON();
    if (data)
      Object.assign(json, data);
    return UI_1.one(json);
  }
  static one(data, x, y, width, height) {
    return UICreator.get(data.tag || this.prototype.__tag, data, x, y, width, height);
  }
  static registerUI() {
    registerUI()(this);
  }
  static registerData(data) {
    dataProcessor(data)(this.prototype);
  }
  static setEditConfig(_config) {
  }
  static setEditOuter(_toolName) {
  }
  static setEditInner(_editorName) {
  }
  destroy() {
    this.fill = this.stroke = null;
    if (this.__animate)
      this.killAnimate();
    super.destroy();
  }
};
__decorate2([
  dataProcessor(UIData)
], UI.prototype, "__", void 0);
__decorate2([
  zoomLayerType()
], UI.prototype, "zoomLayer", void 0);
__decorate2([
  dataType("")
], UI.prototype, "id", void 0);
__decorate2([
  dataType("")
], UI.prototype, "name", void 0);
__decorate2([
  dataType("")
], UI.prototype, "className", void 0);
__decorate2([
  surfaceType("pass-through")
], UI.prototype, "blendMode", void 0);
__decorate2([
  opacityType(1)
], UI.prototype, "opacity", void 0);
__decorate2([
  visibleType(true)
], UI.prototype, "visible", void 0);
__decorate2([
  surfaceType(false)
], UI.prototype, "locked", void 0);
__decorate2([
  sortType(0)
], UI.prototype, "zIndex", void 0);
__decorate2([
  maskType(false)
], UI.prototype, "mask", void 0);
__decorate2([
  eraserType(false)
], UI.prototype, "eraser", void 0);
__decorate2([
  positionType(0, true)
], UI.prototype, "x", void 0);
__decorate2([
  positionType(0, true)
], UI.prototype, "y", void 0);
__decorate2([
  boundsType(100, true)
], UI.prototype, "width", void 0);
__decorate2([
  boundsType(100, true)
], UI.prototype, "height", void 0);
__decorate2([
  scaleType(1, true)
], UI.prototype, "scaleX", void 0);
__decorate2([
  scaleType(1, true)
], UI.prototype, "scaleY", void 0);
__decorate2([
  rotationType(0, true)
], UI.prototype, "rotation", void 0);
__decorate2([
  rotationType(0, true)
], UI.prototype, "skewX", void 0);
__decorate2([
  rotationType(0, true)
], UI.prototype, "skewY", void 0);
__decorate2([
  positionType(0, true)
], UI.prototype, "offsetX", void 0);
__decorate2([
  positionType(0, true)
], UI.prototype, "offsetY", void 0);
__decorate2([
  positionType(0, true)
], UI.prototype, "scrollX", void 0);
__decorate2([
  positionType(0, true)
], UI.prototype, "scrollY", void 0);
__decorate2([
  autoLayoutType()
], UI.prototype, "origin", void 0);
__decorate2([
  autoLayoutType()
], UI.prototype, "around", void 0);
__decorate2([
  dataType(false)
], UI.prototype, "lazy", void 0);
__decorate2([
  naturalBoundsType(1)
], UI.prototype, "pixelRatio", void 0);
__decorate2([
  pathInputType()
], UI.prototype, "path", void 0);
__decorate2([
  pathType()
], UI.prototype, "windingRule", void 0);
__decorate2([
  pathType(true)
], UI.prototype, "closed", void 0);
__decorate2([
  boundsType(0)
], UI.prototype, "padding", void 0);
__decorate2([
  boundsType(false)
], UI.prototype, "lockRatio", void 0);
__decorate2([
  boundsType()
], UI.prototype, "widthRange", void 0);
__decorate2([
  boundsType()
], UI.prototype, "heightRange", void 0);
__decorate2([
  dataType(false)
], UI.prototype, "draggable", void 0);
__decorate2([
  dataType()
], UI.prototype, "dragBounds", void 0);
__decorate2([
  dataType(false)
], UI.prototype, "editable", void 0);
__decorate2([
  hitType(true)
], UI.prototype, "hittable", void 0);
__decorate2([
  hitType("path")
], UI.prototype, "hitFill", void 0);
__decorate2([
  strokeType("path")
], UI.prototype, "hitStroke", void 0);
__decorate2([
  hitType(false)
], UI.prototype, "hitBox", void 0);
__decorate2([
  hitType(true)
], UI.prototype, "hitChildren", void 0);
__decorate2([
  hitType(true)
], UI.prototype, "hitSelf", void 0);
__decorate2([
  hitType()
], UI.prototype, "hitRadius", void 0);
__decorate2([
  cursorType("")
], UI.prototype, "cursor", void 0);
__decorate2([
  surfaceType()
], UI.prototype, "fill", void 0);
__decorate2([
  strokeType()
], UI.prototype, "stroke", void 0);
__decorate2([
  strokeType("inside")
], UI.prototype, "strokeAlign", void 0);
__decorate2([
  strokeType(1)
], UI.prototype, "strokeWidth", void 0);
__decorate2([
  strokeType(false)
], UI.prototype, "strokeWidthFixed", void 0);
__decorate2([
  strokeType("none")
], UI.prototype, "strokeCap", void 0);
__decorate2([
  strokeType("miter")
], UI.prototype, "strokeJoin", void 0);
__decorate2([
  strokeType()
], UI.prototype, "dashPattern", void 0);
__decorate2([
  strokeType()
], UI.prototype, "dashOffset", void 0);
__decorate2([
  strokeType(10)
], UI.prototype, "miterLimit", void 0);
__decorate2([
  pathType(0)
], UI.prototype, "cornerRadius", void 0);
__decorate2([
  pathType()
], UI.prototype, "cornerSmoothing", void 0);
__decorate2([
  effectType()
], UI.prototype, "shadow", void 0);
__decorate2([
  effectType()
], UI.prototype, "innerShadow", void 0);
__decorate2([
  effectType()
], UI.prototype, "blur", void 0);
__decorate2([
  effectType()
], UI.prototype, "backgroundBlur", void 0);
__decorate2([
  effectType()
], UI.prototype, "grayscale", void 0);
__decorate2([
  dataType({})
], UI.prototype, "data", void 0);
__decorate2([
  rewrite(Leaf.prototype.reset)
], UI.prototype, "reset", null);
UI = UI_1 = __decorate2([
  useModule(UIBounds),
  useModule(UIRender),
  rewriteAble()
], UI);
var Group = class Group2 extends UI {
  get __tag() {
    return "Group";
  }
  get isBranch() {
    return true;
  }
  constructor(data) {
    super(data);
  }
  reset(data) {
    this.__setBranch();
    super.reset(data);
  }
  __setBranch() {
    if (!this.children)
      this.children = [];
  }
  set(data, isTemp) {
    if (data.children) {
      const { children } = data;
      delete data.children;
      this.children ? this.clear() : this.__setBranch();
      super.set(data, isTemp);
      children.forEach((child) => this.add(child));
      data.children = children;
    } else
      super.set(data, isTemp);
  }
  toJSON(options) {
    const data = super.toJSON(options);
    data.children = this.children.map((child) => child.toJSON(options));
    return data;
  }
  pick(_hitPoint, _options) {
    return void 0;
  }
  addAt(child, index) {
    this.add(child, index);
  }
  addAfter(child, after) {
    this.add(child, this.children.indexOf(after) + 1);
  }
  addBefore(child, before) {
    this.add(child, this.children.indexOf(before));
  }
  add(_child, _index) {
  }
  addMany(..._children) {
  }
  remove(_child, _destroy) {
  }
  removeAll(_destroy) {
  }
  clear() {
  }
};
__decorate2([
  dataProcessor(GroupData)
], Group.prototype, "__", void 0);
Group = __decorate2([
  useModule(Branch),
  registerUI()
], Group);
var Leafer_1;
var debug2 = Debug.get("Leafer");
var Leafer = Leafer_1 = class Leafer2 extends Group {
  get __tag() {
    return "Leafer";
  }
  get isApp() {
    return false;
  }
  get app() {
    return this.parent || this;
  }
  get isLeafer() {
    return true;
  }
  get imageReady() {
    return this.viewReady && ImageManager.isComplete;
  }
  get layoutLocked() {
    return !this.layouter.running;
  }
  get FPS() {
    return this.renderer ? this.renderer.FPS : 60;
  }
  get cursorPoint() {
    return this.interaction && this.interaction.hoverData || { x: this.width / 2, y: this.height / 2 };
  }
  get clientBounds() {
    return this.canvas && this.canvas.getClientBounds();
  }
  constructor(userConfig, data) {
    super(data);
    this.config = {
      type: "design",
      start: true,
      hittable: true,
      smooth: true,
      lazySpeard: 100,
      zoom: {
        min: 0.01,
        max: 256
      },
      move: {
        holdSpaceKey: true,
        holdMiddleKey: true,
        autoDistance: 2
      }
    };
    this.leafs = 0;
    this.__eventIds = [];
    this.__controllers = [];
    this.__readyWait = [];
    this.__viewReadyWait = [];
    this.__viewCompletedWait = [];
    this.__nextRenderWait = [];
    this.userConfig = userConfig;
    if (userConfig && (userConfig.view || userConfig.width))
      this.init(userConfig);
    Leafer_1.list.add(this);
  }
  init(userConfig, parentApp) {
    if (this.canvas)
      return;
    this.__setLeafer(this);
    if (userConfig)
      DataHelper.assign(this.config, userConfig);
    let start;
    const { config } = this;
    this.initType(config.type);
    const canvas = this.canvas = Creator.canvas(config);
    this.__controllers.push(this.renderer = Creator.renderer(this, canvas, config), this.watcher = Creator.watcher(this, config), this.layouter = Creator.layouter(this, config));
    if (this.isApp)
      this.__setApp();
    this.__checkAutoLayout(config, parentApp);
    this.view = canvas.view;
    if (parentApp) {
      this.__bindApp(parentApp);
      start = parentApp.running;
    } else {
      this.selector = Creator.selector(this);
      this.interaction = Creator.interaction(this, canvas, this.selector, config);
      if (this.interaction) {
        this.__controllers.unshift(this.interaction);
        this.hitCanvasManager = Creator.hitCanvasManager();
      }
      this.canvasManager = new CanvasManager();
      start = config.start;
    }
    this.hittable = config.hittable;
    this.fill = config.fill;
    this.canvasManager.add(canvas);
    this.__listenEvents();
    if (start)
      this.__startTimer = setTimeout(this.start.bind(this));
    WaitHelper.run(this.__initWait);
    this.onInit();
  }
  onInit() {
  }
  initType(_type) {
  }
  set(data) {
    this.waitInit(() => {
      super.set(data);
    });
  }
  start() {
    clearTimeout(this.__startTimer);
    if (!this.running && this.canvas) {
      this.running = true;
      this.ready ? this.emitLeafer(LeaferEvent.RESTART) : this.emitLeafer(LeaferEvent.START);
      this.__controllers.forEach((item) => item.start());
      if (!this.isApp)
        this.renderer.render();
    }
  }
  stop() {
    clearTimeout(this.__startTimer);
    if (this.running && this.canvas) {
      this.__controllers.forEach((item) => item.stop());
      this.running = false;
      this.emitLeafer(LeaferEvent.STOP);
    }
  }
  unlockLayout() {
    this.layouter.start();
    this.updateLayout();
  }
  lockLayout() {
    this.updateLayout();
    this.layouter.stop();
  }
  resize(size) {
    const data = DataHelper.copyAttrs({}, size, canvasSizeAttrs);
    Object.keys(data).forEach((key) => this[key] = data[key]);
  }
  forceRender(bounds) {
    this.renderer.addBlock(bounds ? new Bounds(bounds) : this.canvas.bounds);
    if (this.viewReady)
      this.renderer.update();
  }
  updateCursor(cursor) {
    const i = this.interaction;
    if (i)
      cursor ? i.setCursor(cursor) : i.updateCursor();
  }
  updateLazyBounds() {
    this.lazyBounds = this.canvas.bounds.clone().spread(this.config.lazySpeard);
  }
  __doResize(size) {
    const { canvas } = this;
    if (!canvas || canvas.isSameSize(size))
      return;
    const old = DataHelper.copyAttrs({}, this.canvas, canvasSizeAttrs);
    canvas.resize(size);
    this.updateLazyBounds();
    this.__onResize(new ResizeEvent(size, old));
  }
  __onResize(event) {
    this.emitEvent(event);
    DataHelper.copyAttrs(this.__, event, canvasSizeAttrs);
    setTimeout(() => {
      if (this.canvasManager)
        this.canvasManager.clearRecycled();
    }, 0);
  }
  __setApp() {
  }
  __bindApp(app) {
    this.selector = app.selector;
    this.interaction = app.interaction;
    this.canvasManager = app.canvasManager;
    this.hitCanvasManager = app.hitCanvasManager;
  }
  __setLeafer(leafer) {
    this.leafer = leafer;
    this.__level = 1;
  }
  __checkAutoLayout(config, parentApp) {
    if (!parentApp) {
      if (!config.width || !config.height)
        this.autoLayout = new AutoBounds(config);
      this.canvas.startAutoLayout(this.autoLayout, this.__onResize.bind(this));
    }
  }
  __setAttr(attrName, newValue) {
    if (this.canvas) {
      if (canvasSizeAttrs.includes(attrName)) {
        if (!newValue)
          debug2.warn(attrName + " is 0");
        this.__changeCanvasSize(attrName, newValue);
      } else if (attrName === "fill") {
        this.__changeFill(newValue);
      } else if (attrName === "hittable") {
        if (!this.parent)
          this.canvas.hittable = newValue;
      } else if (attrName === "zIndex") {
        this.canvas.zIndex = newValue;
        setTimeout(() => this.parent && this.parent.__updateSortChildren());
      }
    }
    return super.__setAttr(attrName, newValue);
  }
  __getAttr(attrName) {
    if (this.canvas && canvasSizeAttrs.includes(attrName))
      return this.canvas[attrName];
    return super.__getAttr(attrName);
  }
  __changeCanvasSize(attrName, newValue) {
    const data = DataHelper.copyAttrs({}, this.canvas, canvasSizeAttrs);
    data[attrName] = this.config[attrName] = newValue;
    if (newValue)
      this.canvas.stopAutoLayout();
    this.__doResize(data);
  }
  __changeFill(newValue) {
    this.config.fill = newValue;
    if (this.canvas.allowBackgroundColor)
      this.canvas.backgroundColor = newValue;
    else
      this.forceRender();
  }
  __onCreated() {
    this.created = true;
  }
  __onReady() {
    if (this.ready)
      return;
    this.ready = true;
    this.emitLeafer(LeaferEvent.BEFORE_READY);
    this.emitLeafer(LeaferEvent.READY);
    this.emitLeafer(LeaferEvent.AFTER_READY);
    WaitHelper.run(this.__readyWait);
  }
  __onViewReady() {
    if (this.viewReady)
      return;
    this.viewReady = true;
    this.emitLeafer(LeaferEvent.VIEW_READY);
    WaitHelper.run(this.__viewReadyWait);
  }
  __onNextRender() {
    if (this.viewReady) {
      WaitHelper.run(this.__nextRenderWait);
      const { imageReady } = this;
      if (imageReady && !this.viewCompleted)
        this.__checkViewCompleted();
      if (!imageReady)
        this.viewCompleted = false;
    }
  }
  __checkViewCompleted(emit2 = true) {
    this.nextRender(() => {
      if (this.imageReady) {
        if (emit2)
          this.emitLeafer(LeaferEvent.VIEW_COMPLETED);
        WaitHelper.run(this.__viewCompletedWait);
        this.viewCompleted = true;
      }
    });
  }
  __onWatchData() {
    if (this.watcher.childrenChanged && this.interaction) {
      this.nextRender(() => this.interaction.updateCursor());
    }
  }
  waitInit(item, bind) {
    if (bind)
      item = item.bind(bind);
    if (!this.__initWait)
      this.__initWait = [];
    this.canvas ? item() : this.__initWait.push(item);
  }
  waitReady(item, bind) {
    if (bind)
      item = item.bind(bind);
    this.ready ? item() : this.__readyWait.push(item);
  }
  waitViewReady(item, bind) {
    if (bind)
      item = item.bind(bind);
    this.viewReady ? item() : this.__viewReadyWait.push(item);
  }
  waitViewCompleted(item, bind) {
    if (bind)
      item = item.bind(bind);
    this.__viewCompletedWait.push(item);
    if (this.viewCompleted)
      this.__checkViewCompleted(false);
    else if (!this.running)
      this.start();
  }
  nextRender(item, bind, off2) {
    if (bind)
      item = item.bind(bind);
    const list2 = this.__nextRenderWait;
    if (off2) {
      for (let i = 0; i < list2.length; i++) {
        if (list2[i] === item) {
          list2.splice(i, 1);
          break;
        }
      }
    } else
      list2.push(item);
  }
  zoom(_zoomType, _padding, _fixedScale) {
    return needPlugin("view");
  }
  getValidMove(moveX, moveY) {
    return { x: moveX, y: moveY };
  }
  getValidScale(changeScale) {
    return changeScale;
  }
  getWorldPointByClient(clientPoint, updateClient) {
    return this.interaction && this.interaction.getLocal(clientPoint, updateClient);
  }
  getPagePointByClient(clientPoint, updateClient) {
    return this.getPagePoint(this.getWorldPointByClient(clientPoint, updateClient));
  }
  updateClientBounds() {
    this.canvas && this.canvas.updateClientBounds();
  }
  receiveEvent(_event) {
  }
  __checkUpdateLayout() {
    this.__layout.update();
  }
  emitLeafer(type) {
    this.emitEvent(new LeaferEvent(type, this));
  }
  __listenEvents() {
    const runId = Run.start("FirstCreate " + this.innerName);
    this.once(LeaferEvent.START, () => Run.end(runId));
    this.once(LayoutEvent.START, () => this.updateLazyBounds());
    this.once(LayoutEvent.END, () => this.__onReady());
    this.once(RenderEvent.START, () => this.__onCreated());
    this.once(RenderEvent.END, () => this.__onViewReady());
    this.__eventIds.push(this.on_(WatchEvent.DATA, this.__onWatchData, this), this.on_(RenderEvent.NEXT, this.__onNextRender, this), this.on_(LayoutEvent.CHECK_UPDATE, this.__checkUpdateLayout, this));
  }
  __removeListenEvents() {
    this.off_(this.__eventIds);
    this.__eventIds.length = 0;
  }
  destroy(sync) {
    const doDestory = () => {
      if (!this.destroyed) {
        Leafer_1.list.remove(this);
        try {
          this.stop();
          this.emitEvent(new LeaferEvent(LeaferEvent.END, this));
          this.__removeListenEvents();
          this.__controllers.forEach((item) => !(this.parent && item === this.interaction) && item.destroy());
          this.__controllers.length = 0;
          if (!this.parent) {
            if (this.selector)
              this.selector.destroy();
            if (this.hitCanvasManager)
              this.hitCanvasManager.destroy();
            this.canvasManager.destroy();
          }
          this.canvas.destroy();
          this.config.view = this.view = null;
          if (this.userConfig)
            this.userConfig.view = null;
          super.destroy();
          setTimeout(() => {
            ImageManager.clearRecycled();
          }, 100);
        } catch (e) {
          debug2.error(e);
        }
      }
    };
    sync ? doDestory() : setTimeout(doDestory);
  }
};
Leafer.list = new LeafList();
__decorate2([
  dataProcessor(LeaferData)
], Leafer.prototype, "__", void 0);
__decorate2([
  boundsType()
], Leafer.prototype, "pixelRatio", void 0);
Leafer = Leafer_1 = __decorate2([
  registerUI()
], Leafer);
var Rect = class Rect2 extends UI {
  get __tag() {
    return "Rect";
  }
  constructor(data) {
    super(data);
  }
};
__decorate2([
  dataProcessor(RectData)
], Rect.prototype, "__", void 0);
Rect = __decorate2([
  useModule(RectRender),
  rewriteAble(),
  registerUI()
], Rect);
var { copy: copy2, add: add2, includes: includes$1 } = BoundsHelper;
var rect2 = Rect.prototype;
var group = Group.prototype;
var childrenRenderBounds = {};
var Box = class Box2 extends Group {
  get __tag() {
    return "Box";
  }
  get isBranchLeaf() {
    return true;
  }
  constructor(data) {
    super(data);
    this.__layout.renderChanged || this.__layout.renderChange();
  }
  __updateStrokeSpread() {
    return 0;
  }
  __updateRectRenderSpread() {
    return 0;
  }
  __updateRenderSpread() {
    return this.__updateRectRenderSpread() || -1;
  }
  __updateRectBoxBounds() {
  }
  __updateBoxBounds(_secondLayout) {
    const data = this.__;
    if (this.children.length) {
      if (data.__autoSide) {
        super.__updateBoxBounds();
        const { boxBounds } = this.__layout;
        if (!data.__autoSize) {
          if (data.__autoWidth) {
            boxBounds.width += boxBounds.x, boxBounds.x = 0;
            boxBounds.height = data.height, boxBounds.y = 0;
          } else {
            boxBounds.height += boxBounds.y, boxBounds.y = 0;
            boxBounds.width = data.width, boxBounds.x = 0;
          }
        }
        this.__updateNaturalSize();
      } else
        this.__updateRectBoxBounds();
    } else
      this.__updateRectBoxBounds();
  }
  __updateStrokeBounds() {
  }
  __updateRenderBounds() {
    let isOverflow;
    const { renderBounds } = this.__layout;
    if (this.children.length) {
      super.__updateRenderBounds();
      copy2(childrenRenderBounds, renderBounds);
      this.__updateRectRenderBounds();
      isOverflow = !includes$1(renderBounds, childrenRenderBounds);
      if (isOverflow && this.__.overflow !== "hide")
        add2(renderBounds, childrenRenderBounds);
    } else
      this.__updateRectRenderBounds();
    !this.isOverflow !== !isOverflow && (this.isOverflow = isOverflow);
  }
  __updateRectRenderBounds() {
  }
  __updateRectChange() {
  }
  __updateChange() {
    super.__updateChange();
    this.__updateRectChange();
  }
  __renderRect(_canvas, _options) {
  }
  __renderGroup(_canvas, _options) {
  }
  __render(canvas, options) {
    if (this.__.__drawAfterFill) {
      this.__renderRect(canvas, options);
    } else {
      this.__renderRect(canvas, options);
      if (this.children.length)
        this.__renderGroup(canvas, options);
    }
  }
  __drawContent(canvas, options) {
    this.__renderGroup(canvas, options);
    if (this.__.__hasStroke) {
      canvas.setWorld(this.__nowWorld);
      this.__drawRenderPath(canvas);
    }
  }
};
__decorate2([
  dataProcessor(BoxData)
], Box.prototype, "__", void 0);
__decorate2([
  dataType(false)
], Box.prototype, "resizeChildren", void 0);
__decorate2([
  affectRenderBoundsType("show")
], Box.prototype, "overflow", void 0);
__decorate2([
  rewrite(rect2.__updateStrokeSpread)
], Box.prototype, "__updateStrokeSpread", null);
__decorate2([
  rewrite(rect2.__updateRenderSpread)
], Box.prototype, "__updateRectRenderSpread", null);
__decorate2([
  rewrite(rect2.__updateBoxBounds)
], Box.prototype, "__updateRectBoxBounds", null);
__decorate2([
  rewrite(rect2.__updateStrokeBounds)
], Box.prototype, "__updateStrokeBounds", null);
__decorate2([
  rewrite(rect2.__updateRenderBounds)
], Box.prototype, "__updateRectRenderBounds", null);
__decorate2([
  rewrite(rect2.__updateChange)
], Box.prototype, "__updateRectChange", null);
__decorate2([
  rewrite(rect2.__render)
], Box.prototype, "__renderRect", null);
__decorate2([
  rewrite(group.__render)
], Box.prototype, "__renderGroup", null);
Box = __decorate2([
  rewriteAble(),
  registerUI()
], Box);
var Frame = class Frame2 extends Box {
  get __tag() {
    return "Frame";
  }
  get isFrame() {
    return true;
  }
  constructor(data) {
    super(data);
  }
};
__decorate2([
  dataProcessor(FrameData)
], Frame.prototype, "__", void 0);
__decorate2([
  surfaceType("#FFFFFF")
], Frame.prototype, "fill", void 0);
__decorate2([
  affectRenderBoundsType("hide")
], Frame.prototype, "overflow", void 0);
Frame = __decorate2([
  registerUI()
], Frame);
var { moveTo: moveTo$3, closePath: closePath$2, ellipse: ellipse2 } = PathCommandDataHelper;
var Ellipse = class Ellipse2 extends UI {
  get __tag() {
    return "Ellipse";
  }
  constructor(data) {
    super(data);
  }
  __updatePath() {
    const { width, height, innerRadius, startAngle, endAngle } = this.__;
    const rx = width / 2, ry = height / 2;
    const path = this.__.path = [];
    if (innerRadius) {
      if (startAngle || endAngle) {
        if (innerRadius < 1)
          ellipse2(path, rx, ry, rx * innerRadius, ry * innerRadius, 0, startAngle, endAngle, false);
        ellipse2(path, rx, ry, rx, ry, 0, endAngle, startAngle, true);
        if (innerRadius < 1)
          closePath$2(path);
      } else {
        if (innerRadius < 1) {
          ellipse2(path, rx, ry, rx * innerRadius, ry * innerRadius);
          moveTo$3(path, width, ry);
        }
        ellipse2(path, rx, ry, rx, ry, 0, 360, 0, true);
      }
      if (Platform.ellipseToCurve)
        this.__.path = this.getPath(true);
    } else {
      if (startAngle || endAngle) {
        moveTo$3(path, rx, ry);
        ellipse2(path, rx, ry, rx, ry, 0, startAngle, endAngle, false);
        closePath$2(path);
      } else {
        ellipse2(path, rx, ry, rx, ry);
      }
    }
  }
};
__decorate2([
  dataProcessor(EllipseData)
], Ellipse.prototype, "__", void 0);
__decorate2([
  pathType(0)
], Ellipse.prototype, "innerRadius", void 0);
__decorate2([
  pathType(0)
], Ellipse.prototype, "startAngle", void 0);
__decorate2([
  pathType(0)
], Ellipse.prototype, "endAngle", void 0);
Ellipse = __decorate2([
  registerUI()
], Ellipse);
var { moveTo: moveTo$2, lineTo: lineTo$2, drawPoints: drawPoints$1 } = PathCommandDataHelper;
var { rotate, getAngle, getDistance, defaultPoint } = PointHelper;
var { toBounds: toBounds2 } = PathBounds;
var Line = class Line2 extends UI {
  get __tag() {
    return "Line";
  }
  get toPoint() {
    const { width, rotation } = this.__;
    const to = getPointData();
    if (width)
      to.x = width;
    if (rotation)
      rotate(to, rotation);
    return to;
  }
  set toPoint(value) {
    this.width = getDistance(defaultPoint, value);
    this.rotation = getAngle(defaultPoint, value);
    if (this.height)
      this.height = 0;
  }
  constructor(data) {
    super(data);
  }
  __updatePath() {
    const data = this.__;
    const path = data.path = [];
    if (data.points) {
      drawPoints$1(path, data.points, false, data.closed);
    } else {
      moveTo$2(path, 0, 0);
      lineTo$2(path, this.width, 0);
    }
  }
  __updateRenderPath() {
    const data = this.__;
    if (!this.pathInputed && data.points && data.curve) {
      drawPoints$1(data.__pathForRender = [], data.points, data.curve, data.closed);
      if (data.__useArrow)
        PathArrow.addArrows(this, false);
    } else
      super.__updateRenderPath();
  }
  __updateBoxBounds() {
    if (this.points) {
      toBounds2(this.__.__pathForRender, this.__layout.boxBounds);
    } else
      super.__updateBoxBounds();
  }
};
__decorate2([
  dataProcessor(LineData)
], Line.prototype, "__", void 0);
__decorate2([
  affectStrokeBoundsType("center")
], Line.prototype, "strokeAlign", void 0);
__decorate2([
  boundsType(0)
], Line.prototype, "height", void 0);
__decorate2([
  pathType()
], Line.prototype, "points", void 0);
__decorate2([
  pathType(0)
], Line.prototype, "curve", void 0);
__decorate2([
  pathType(false)
], Line.prototype, "closed", void 0);
Line = __decorate2([
  registerUI()
], Line);
var { sin: sin$12, cos: cos$12, PI: PI$12 } = Math;
var { moveTo: moveTo$1, lineTo: lineTo$1, closePath: closePath$1, drawPoints: drawPoints2 } = PathCommandDataHelper;
var line = Line.prototype;
var Polygon = class Polygon2 extends UI {
  get __tag() {
    return "Polygon";
  }
  constructor(data) {
    super(data);
  }
  __updatePath() {
    const path = this.__.path = [];
    if (this.__.points) {
      drawPoints2(path, this.__.points, false, true);
    } else {
      const { width, height, sides } = this.__;
      const rx = width / 2, ry = height / 2;
      moveTo$1(path, rx, 0);
      for (let i = 1; i < sides; i++) {
        lineTo$1(path, rx + rx * sin$12(i * 2 * PI$12 / sides), ry - ry * cos$12(i * 2 * PI$12 / sides));
      }
    }
    closePath$1(path);
  }
  __updateRenderPath() {
  }
  __updateBoxBounds() {
  }
};
__decorate2([
  dataProcessor(PolygonData)
], Polygon.prototype, "__", void 0);
__decorate2([
  pathType(3)
], Polygon.prototype, "sides", void 0);
__decorate2([
  pathType()
], Polygon.prototype, "points", void 0);
__decorate2([
  pathType(0)
], Polygon.prototype, "curve", void 0);
__decorate2([
  rewrite(line.__updateRenderPath)
], Polygon.prototype, "__updateRenderPath", null);
__decorate2([
  rewrite(line.__updateBoxBounds)
], Polygon.prototype, "__updateBoxBounds", null);
Polygon = __decorate2([
  rewriteAble(),
  registerUI()
], Polygon);
var { sin: sin2, cos: cos2, PI: PI3 } = Math;
var { moveTo: moveTo2, lineTo: lineTo2, closePath: closePath2 } = PathCommandDataHelper;
var Star = class Star2 extends UI {
  get __tag() {
    return "Star";
  }
  constructor(data) {
    super(data);
  }
  __updatePath() {
    const { width, height, corners, innerRadius } = this.__;
    const rx = width / 2, ry = height / 2;
    const path = this.__.path = [];
    moveTo2(path, rx, 0);
    for (let i = 1; i < corners * 2; i++) {
      lineTo2(path, rx + (i % 2 === 0 ? rx : rx * innerRadius) * sin2(i * PI3 / corners), ry - (i % 2 === 0 ? ry : ry * innerRadius) * cos2(i * PI3 / corners));
    }
    closePath2(path);
  }
};
__decorate2([
  dataProcessor(StarData)
], Star.prototype, "__", void 0);
__decorate2([
  pathType(5)
], Star.prototype, "corners", void 0);
__decorate2([
  pathType(0.382)
], Star.prototype, "innerRadius", void 0);
Star = __decorate2([
  registerUI()
], Star);
var Image = class Image2 extends Rect {
  get __tag() {
    return "Image";
  }
  get ready() {
    return this.image ? this.image.ready : false;
  }
  constructor(data) {
    super(data);
    this.on(ImageEvent.LOADED, (e) => {
      if (e.attrName === "fill" && e.attrValue.url === this.url)
        this.image = e.image;
    });
  }
  destroy() {
    this.image = null;
    super.destroy();
  }
};
__decorate2([
  dataProcessor(ImageData)
], Image.prototype, "__", void 0);
__decorate2([
  boundsType("")
], Image.prototype, "url", void 0);
Image = __decorate2([
  registerUI()
], Image);
var MyImage = Image;
var Canvas2 = class Canvas3 extends Rect {
  get __tag() {
    return "Canvas";
  }
  get ready() {
    return !this.url;
  }
  constructor(data) {
    super(data);
    this.canvas = Creator.canvas(this.__);
    this.context = this.canvas.context;
    if (data && data.url)
      this.drawImage(data.url);
  }
  drawImage(url) {
    new LeaferImage({ url }).load((image) => {
      this.context.drawImage(image.view, 0, 0);
      this.url = void 0;
      this.paint();
      this.emitEvent(new ImageEvent(ImageEvent.LOADED, { image }));
    });
  }
  draw(ui, offset, scale, rotation) {
    const matrix2 = new Matrix(ui.worldTransform).invert();
    const m2 = new Matrix();
    if (offset)
      m2.translate(offset.x, offset.y);
    if (scale)
      typeof scale === "number" ? m2.scale(scale) : m2.scale(scale.x, scale.y);
    if (rotation)
      m2.rotate(rotation);
    matrix2.multiplyParent(m2);
    ui.__render(this.canvas, { matrix: matrix2.withScale() });
    this.paint();
  }
  paint() {
    this.forceRender();
  }
  __drawContent(canvas, _options) {
    const { width, height } = this.__, { view } = this.canvas;
    canvas.drawImage(view, 0, 0, view.width, view.height, 0, 0, width, height);
  }
  __updateSize() {
    const { canvas } = this;
    if (canvas) {
      const { smooth } = this.__;
      if (canvas.smooth !== smooth)
        canvas.smooth = smooth;
      canvas.resize(this.__);
    }
  }
  destroy() {
    if (this.canvas) {
      this.canvas.destroy();
      this.canvas = this.context = null;
    }
    super.destroy();
  }
};
__decorate2([
  dataProcessor(CanvasData)
], Canvas2.prototype, "__", void 0);
__decorate2([
  resizeType(100)
], Canvas2.prototype, "width", void 0);
__decorate2([
  resizeType(100)
], Canvas2.prototype, "height", void 0);
__decorate2([
  resizeType(1)
], Canvas2.prototype, "pixelRatio", void 0);
__decorate2([
  resizeType(true)
], Canvas2.prototype, "smooth", void 0);
__decorate2([
  resizeType()
], Canvas2.prototype, "contextSettings", void 0);
Canvas2 = __decorate2([
  registerUI()
], Canvas2);
var { copyAndSpread: copyAndSpread2, includes, isSame, spread, setList } = BoundsHelper;
var Text = class Text2 extends UI {
  get __tag() {
    return "Text";
  }
  get textDrawData() {
    this.__layout.update();
    return this.__.__textDrawData;
  }
  constructor(data) {
    super(data);
  }
  __drawHitPath(canvas) {
    const { __lineHeight, fontSize, __baseLine, __textDrawData: data } = this.__;
    canvas.beginPath();
    if (this.__.__letterSpacing < 0) {
      this.__drawPathByData(canvas);
    } else {
      data.rows.forEach((row) => canvas.rect(row.x, row.y - __baseLine, row.width, __lineHeight < fontSize ? fontSize : __lineHeight));
    }
  }
  __drawPathByData(drawer, _data) {
    const { x, y, width, height } = this.__layout.boxBounds;
    drawer.rect(x, y, width, height);
  }
  __drawRenderPath(canvas) {
    canvas.font = this.__.__font;
  }
  __updateTextDrawData() {
    const data = this.__;
    const { lineHeight, letterSpacing, fontFamily, fontSize, fontWeight, italic, textCase, textOverflow, padding } = data;
    data.__lineHeight = UnitConvert.number(lineHeight, fontSize);
    data.__letterSpacing = UnitConvert.number(letterSpacing, fontSize);
    data.__padding = padding ? MathHelper.fourNumber(padding) : void 0;
    data.__baseLine = data.__lineHeight - (data.__lineHeight - fontSize * 0.7) / 2;
    data.__font = `${italic ? "italic " : ""}${textCase === "small-caps" ? "small-caps " : ""}${fontWeight !== "normal" ? fontWeight + " " : ""}${fontSize}px ${fontFamily}`;
    data.__clipText = textOverflow !== "show" && !data.__autoSize;
    data.__textDrawData = TextConvert.getDrawData(data.text, this.__);
  }
  __updateBoxBounds() {
    const data = this.__;
    const layout = this.__layout;
    const { fontSize, italic, padding, __autoWidth: autoWidth, __autoHeight: autoHeight } = data;
    this.__updateTextDrawData();
    const { bounds } = data.__textDrawData;
    const b = layout.boxBounds;
    if (data.__lineHeight < fontSize)
      spread(bounds, fontSize / 2);
    if (autoWidth || autoHeight) {
      b.x = autoWidth ? bounds.x : 0;
      b.y = autoHeight ? bounds.y : 0;
      b.width = autoWidth ? bounds.width : data.width;
      b.height = autoHeight ? bounds.height : data.height;
      if (padding) {
        const [top, right2, bottom2, left] = data.__padding;
        if (autoWidth)
          b.x -= left, b.width += right2 + left;
        if (autoHeight)
          b.y -= top, b.height += bottom2 + top;
      }
      this.__updateNaturalSize();
    } else
      super.__updateBoxBounds();
    if (italic)
      b.width += fontSize * 0.16;
    const contentBounds = includes(b, bounds) ? b : bounds;
    if (!isSame(contentBounds, layout.contentBounds)) {
      layout.contentBounds = contentBounds;
      layout.renderChanged = true;
      setList(data.__textBoxBounds = {}, [b, bounds]);
    } else
      data.__textBoxBounds = contentBounds;
  }
  __updateRenderSpread() {
    let width = super.__updateRenderSpread();
    if (!width)
      width = this.__layout.boxBounds === this.__layout.contentBounds ? 0 : 1;
    return width;
  }
  __updateRenderBounds() {
    copyAndSpread2(this.__layout.renderBounds, this.__.__textBoxBounds, this.__layout.renderSpread);
  }
};
__decorate2([
  dataProcessor(TextData)
], Text.prototype, "__", void 0);
__decorate2([
  boundsType(0)
], Text.prototype, "width", void 0);
__decorate2([
  boundsType(0)
], Text.prototype, "height", void 0);
__decorate2([
  dataType(false)
], Text.prototype, "resizeFontSize", void 0);
__decorate2([
  surfaceType("#000000")
], Text.prototype, "fill", void 0);
__decorate2([
  affectStrokeBoundsType("outside")
], Text.prototype, "strokeAlign", void 0);
__decorate2([
  hitType("all")
], Text.prototype, "hitFill", void 0);
__decorate2([
  boundsType("")
], Text.prototype, "text", void 0);
__decorate2([
  boundsType("L")
], Text.prototype, "fontFamily", void 0);
__decorate2([
  boundsType(12)
], Text.prototype, "fontSize", void 0);
__decorate2([
  boundsType("normal")
], Text.prototype, "fontWeight", void 0);
__decorate2([
  boundsType(false)
], Text.prototype, "italic", void 0);
__decorate2([
  boundsType("none")
], Text.prototype, "textCase", void 0);
__decorate2([
  boundsType("none")
], Text.prototype, "textDecoration", void 0);
__decorate2([
  boundsType(0)
], Text.prototype, "letterSpacing", void 0);
__decorate2([
  boundsType({ type: "percent", value: 1.5 })
], Text.prototype, "lineHeight", void 0);
__decorate2([
  boundsType(0)
], Text.prototype, "paraIndent", void 0);
__decorate2([
  boundsType(0)
], Text.prototype, "paraSpacing", void 0);
__decorate2([
  boundsType("left")
], Text.prototype, "textAlign", void 0);
__decorate2([
  boundsType("top")
], Text.prototype, "verticalAlign", void 0);
__decorate2([
  boundsType(true)
], Text.prototype, "autoSizeAlign", void 0);
__decorate2([
  boundsType("normal")
], Text.prototype, "textWrap", void 0);
__decorate2([
  boundsType("show")
], Text.prototype, "textOverflow", void 0);
Text = __decorate2([
  registerUI()
], Text);
var Path = class Path2 extends UI {
  get __tag() {
    return "Path";
  }
  constructor(data) {
    super(data);
  }
};
__decorate2([
  dataProcessor(PathData)
], Path.prototype, "__", void 0);
__decorate2([
  affectStrokeBoundsType("center")
], Path.prototype, "strokeAlign", void 0);
Path = __decorate2([
  registerUI()
], Path);
var Pen = class Pen2 extends Group {
  get __tag() {
    return "Pen";
  }
  constructor(data) {
    super(data);
  }
  setStyle(data) {
    const path = this.pathElement = new Path(data);
    this.pathStyle = data;
    this.__path = path.path || (path.path = []);
    this.add(path);
    return this;
  }
  beginPath() {
    return this;
  }
  moveTo(_x, _y) {
    return this;
  }
  lineTo(_x, _y) {
    return this;
  }
  bezierCurveTo(_x1, _y1, _x2, _y2, _x, _y) {
    return this;
  }
  quadraticCurveTo(_x1, _y1, _x, _y) {
    return this;
  }
  closePath() {
    return this;
  }
  rect(_x, _y, _width, _height) {
    return this;
  }
  roundRect(_x, _y, _width, _height, _cornerRadius) {
    return this;
  }
  ellipse(_x, _y, _radiusX, _radiusY, _rotation, _startAngle, _endAngle, _anticlockwise) {
    return this;
  }
  arc(_x, _y, _radius, _startAngle, _endAngle, _anticlockwise) {
    return this;
  }
  arcTo(_x1, _y1, _x2, _y2, _radius) {
    return this;
  }
  drawEllipse(_x, _y, _radiusX, _radiusY, _rotation, _startAngle, _endAngle, _anticlockwise) {
    return this;
  }
  drawArc(_x, _y, _radius, _startAngle, _endAngle, _anticlockwise) {
    return this;
  }
  drawPoints(_points, _curve, _close) {
    return this;
  }
  clearPath() {
    return this;
  }
  paint() {
    if (!this.pathElement.__layout.boxChanged)
      this.pathElement.forceUpdate("path");
  }
};
__decorate2([
  dataProcessor(PenData)
], Pen.prototype, "__", void 0);
__decorate2([
  penPathType()
], Pen.prototype, "path", void 0);
Pen = __decorate2([
  useModule(PathCreator, ["set", "path", "paint"]),
  registerUI()
], Pen);
function penPathType() {
  return (target, key) => {
    defineKey(target, key, {
      get() {
        return this.__path;
      }
    });
  };
}

export {
  Platform,
  Creator,
  IncrementId,
  MathHelper,
  OneRadian,
  PI2,
  PI_2,
  getPointData,
  getBoundsData,
  getMatrixData,
  MatrixHelper,
  PointHelper,
  Point,
  tempPoint$2,
  Matrix,
  tempMatrix,
  TwoPointBoundsHelper,
  BoundsHelper,
  Bounds,
  tempBounds,
  AutoBounds,
  Direction4,
  Direction9,
  AroundHelper,
  AlignHelper,
  StringNumberMap,
  Debug,
  Run,
  needPlugin,
  UICreator,
  EventCreator,
  CanvasManager,
  DataHelper,
  LeafData,
  Answer,
  emptyData,
  isNull,
  canvasSizeAttrs,
  LeaferCanvasBase,
  PathHelper,
  PathCommandMap,
  NeedConvertToCanvasCommandMap,
  PathNumberCommandMap,
  PathNumberCommandLengthMap,
  RectHelper,
  BezierHelper,
  EllipseHelper,
  PathConvert,
  PathCommandDataHelper,
  PathCreator,
  PathDrawer,
  PathBounds,
  PathCorner,
  pen,
  canvasPatch,
  FileHelper,
  TaskItem,
  TaskProcessor,
  ImageManager,
  LeaferImage,
  defineKey,
  getDescriptor,
  decorateLeafAttr,
  attr,
  defineLeafAttr,
  dataType,
  positionType,
  autoLayoutType,
  scaleType,
  rotationType,
  boundsType,
  naturalBoundsType,
  doBoundsType,
  pathInputType,
  pathType,
  affectStrokeBoundsType,
  doStrokeType,
  strokeType,
  affectRenderBoundsType,
  surfaceType,
  opacityType,
  visibleType,
  sortType,
  maskType,
  eraserType,
  hitType,
  cursorType,
  dataProcessor,
  layoutProcessor,
  defineDataProcessor,
  rewrite,
  rewriteAble,
  useModule,
  registerUI,
  registerUIEvent,
  LeafHelper,
  LeafBoundsHelper,
  BranchHelper,
  WaitHelper,
  LeafLayout,
  Event,
  ChildEvent,
  PropertyEvent,
  ImageEvent,
  ResizeEvent,
  WatchEvent,
  LayoutEvent,
  RenderEvent,
  LeaferEvent,
  Eventer,
  LeafEventer,
  LeafDataProxy,
  LeafMatrix,
  LeafBounds,
  LeafRender,
  BranchRender,
  Leaf,
  Branch,
  LeafList,
  LeafLevelList,
  version,
  effectType,
  resizeType,
  zoomLayerType,
  TextConvert,
  ColorConvert,
  UnitConvert,
  PathArrow,
  Paint,
  PaintImage,
  PaintGradient,
  Effect,
  Export,
  State,
  Transition,
  UIData,
  GroupData,
  BoxData,
  LeaferData,
  FrameData,
  LineData,
  RectData,
  EllipseData,
  PolygonData,
  StarData,
  PathData,
  PenData,
  TextData,
  ImageData,
  CanvasData,
  UIBounds,
  UIRender,
  RectRender,
  UI,
  Group,
  Leafer,
  Rect,
  Box,
  Frame,
  Ellipse,
  Line,
  Polygon,
  Star,
  Image,
  MyImage,
  Canvas2 as Canvas,
  Text,
  Path,
  Pen
};
//# sourceMappingURL=chunk-ART566W7.js.map
